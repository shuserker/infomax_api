#!/usr/bin/env python3
"""
Python 들여쓰기 문제 전용 수정 도구
Specialized Python Indentation Fixer

들여쓰기 오류를 자동으로 감지하고 수정합니다.
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import verify_folder_reorganization.py
import shutil
from pathlib import Path
from typing import deployment_verification_checklist.md, Dict, Tuple
from datetime import datetime
import logging
import sys
import datetime
import re

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class IndentationFixer:
    """들여쓰기 문제 전용 수정기"""
    
    def __init__(self):
        self.workspace_root = Path.cwd()
        self.backup_dir = self.workspace_root / ".indentation_backup"
        self.backup_dir.mkdir(exist_ok=True)
        
        # 핵심 모듈들
        self.core_modules = [
            'naming_convention_manager.py',
            'file_renaming_system.py', 
            'python_naming_standardizer.py',
            'shell_batch_script_standardizer.py',
            'documentation_standardizer.py',
            'config_data_standardizer.py',
            'system_output_message_standardizer.py',
            'folder_structure_reorganizer.py',
            'naming_standardization_verification_system.py'
        ]

    def fix_all_core_modules(self):
        """모든 핵심 모듈의 들여쓰기 수정"""
        logger.info("🔧 핵심 모듈 들여쓰기 수정 시작")
        
        results = []
        for module_name in self.core_modules:
            module_path = self.workspace_root / module_name
            if module_path.exists():
                result = self.fix_file_indentation(module_path)
                results.append(result)
                logger.info(f"{'✅' if result['success'] else '❌'} {module_name}: {result['message']}")
            else:
                logger.warning(f"⚠️ {module_name} 파일을 찾을 수 없습니다")
        
        return results

    def fix_file_indentation(self, file_path: Path) -> Dict:
        """개별 파일의 들여쓰기 수정"""
        try:
            # 백업 생성
            backup_path = self._create_backup(file_path)
            
            # 파일 읽기
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 들여쓰기 수정
            fixed_content = self._fix_indentation(content)
            
            # 수정된 내용 저장
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            # 구문 검증
            try:
                compile(fixed_content, str(file_path), 'exec')
                return {
                    'success': True,
                    'message': '들여쓰기 수정 및 구문 검증 완료',
                    'backup_path': backup_path
                }
            except SyntaxError as e:
                return {
                    'success': False,
                    'message': f'구문 검증 실패: {e.msg} (라인 {e.lineno})',
                    'backup_path': backup_path
                }
                
        except Exception as e:
            return {
                'success': False,
                'message': f'수정 실패: {str(e)}',
                'backup_path': None
            }

    def _fix_indentation(self, content: str) -> str:
        """들여쓰기 수정 로직"""
        lines = content.split('/n')
        fixed_lines = []
        
        # 현재 들여쓰기 레벨 추적
        indent_level = 0
        in_multiline_string = False
        string_delimiter = None
        
        for i, line in enumerate(lines):
            original_line = line
            stripped_line = line.strip()
            
            # 빈 줄은 그대로 유지
            if not stripped_line:
                fixed_lines.append('')
                continue
            
            # 주석만 있는 줄은 현재 들여쓰기 레벨 유지
            if stripped_line.startswith('#'):
                fixed_lines.append('    ' * indent_level + stripped_line)
                continue
            
            # 멀티라인 문자열 처리
            if in_multiline_string:
                fixed_lines.append(original_line)
                if string_delimiter in line and line.count(string_delimiter) % 2 == 1:
                    in_multiline_string = False
                    string_delimiter = None
                continue
            
            # 멀티라인 문자열 시작 감지
            for delimiter in ['"""', "'''"]:
                if delimiter in stripped_line and stripped_line.count(delimiter) % 2 == 1:
                    in_multiline_string = True
                    string_delimiter = delimiter
                    break
            
            # 들여쓰기 레벨 조정
            if self._should_decrease_indent(stripped_line):
                indent_level = max(0, indent_level - 1)
            
            # 현재 라인 들여쓰기 적용
            fixed_line = '    ' * indent_level + stripped_line
            fixed_lines.append(fixed_line)
            
            # 다음 라인을 위한 들여쓰기 레벨 조정
            if self._should_increase_indent(stripped_line):
                indent_level += 1
        
        return '/n'.join(fixed_lines)

    def _should_increase_indent(self, line: str) -> bool:
        """들여쓰기를 증가시켜야 하는 라인인지 확인"""
        line = line.strip()
        
        # 콜론으로 끝나는 구문들
        if line.endswith(':'):
            # 단순한 딕셔너리나 리스트가 아닌 경우
            if not re.match(r'^["/'].*["/']:/s*', line):  # 딕셔너리 키가 아닌 경우
                return True
        
        # 특정 키워드로 시작하는 구문들
        keywords = ['def ', 'class ', 'if ', 'elif ', 'else:', 'for ', 'while ', 'try:', 'except', 'finally:', 'with ']
        for keyword in keywords:
            if line.startswith(keyword):
                return True
        
        return False

    def _should_decrease_indent(self, line: str) -> bool:
        """들여쓰기를 감소시켜야 하는 라인인지 확인"""
        line = line.strip()
        
        # 블록을 종료하는 키워드들
        decrease_keywords = ['elif ', 'else:', 'except', 'finally:', 'def ', 'class ']
        for keyword in decrease_keywords:
            if line.startswith(keyword):
                return True
        
        return False

    def _create_backup(self, file_path: Path) -> Path:
        """파일 백업 생성"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.name}.indent_backup_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        return backup_path

    def test_imports(self) -> Dict:
# REMOVED:         """수정 후 import 테스트"""
        logger.info("🧪 모듈 import .naming_backup/scripts/🧪POSCO_테스트_실행.bat 중...")
        
        results = {}
        for module_name in self.core_modules:
            module_import_name = module_name.replace('.py', '')
            try:
                # 기존 모듈 캐시 제거
                if module_import_name in sys.modules:
                    del sys.modules[module_import_name]
                
                # import 시도
                __import__(module_import_name)
                results[module_import_name] = {'success': True, 'error': None}
                logger.info(f"✅ {module_import_name}: Import 성공")
                
            except Exception as e:
                results[module_import_name] = {'success': False, 'error': str(e)}
                logger.error(f"❌ {module_import_name}: {str(e)}")
        
        return results

def main():
    """메인 실행 함수"""
    print("🔧 POSCO 핵심 모듈 들여쓰기 수정 시작")
    print("=" * 60)
    
    fixer = IndentationFixer()
    
    # 1. 들여쓰기 수정
    print("/n1️⃣ 들여쓰기 수정 중...")
    fix_results = fixer.fix_all_core_modules()
    
    successful_fixes = sum(1 for r in fix_results if r['success'])
    print(f"✅ 성공적 수정: {successful_fixes}/{len(fix_results)}개 파일")
    
    # 2. Import 테스트
    print("/n2️⃣ 모듈 import .naming_backup/scripts/🧪POSCO_테스트_실행.bat 중...")
    import_results = fixer.test_imports()
    
    successful_imports = sum(1 for r in import_results.values() if r['success'])
    print(f"✅ 성공적 import: {successful_imports}/{len(import_results)}개 모듈")
    
    # 3. 결과 요약
    print("/n" + "=" * 60)
    print("🎉 핵심 모듈 들여쓰기 수정 완료!")
    print("=" * 60)
    
    print("/n📊 수정 결과:")
    for result in fix_results:
        if 'backup_path' in result and result['backup_path']:
            module_name = result['backup_path'].name.split('.')[0]
            status = "✅" if result['success'] else "❌"
            print(f"  {status} {module_name}: {result['message']}")
    
    print("/n📊 Import 결과:")
    for module_name, result in import_results.items():
        status = "✅" if result['success'] else "❌"
        message = "성공" if result['success'] else result['error'][:50] + "..."
        print(f"  {status} {module_name}: {message}")
    
    if successful_imports == len(import_results):
        print("/n🎊 모든 핵심 모듈이 성공적으로 import됩니다!")
        return 0
    else:
# REMOVED:         print(f"/n⚠️ {len(import_results) - successful_imports}개 모듈이 여전히 import 실패합니다.")
        return 1

if __name__ == "__main__":
    sys.exit(main())