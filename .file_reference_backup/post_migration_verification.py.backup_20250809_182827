#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Post Migration Verification
POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import test_config.json
# BROKEN_REF: import subprocess
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
# BROKEN_REF: import signal
# BROKEN_REF: import psutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: from typing import Dict, List, Optional, Tuple
# BROKEN_REF: import logging

class PostMigrationVerification:
    """ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ê²€ì¦ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.script_dir = Path(__file__).parent.absolute()
        self.log_file = self.script_dir / "post_migration_verification.py"
        self.results_file = self.script_dir / "final_integration_final_integration_verification_results.json"
        
        # ë¡œê¹… ì„¤ì •
        self._setup_logging()
        
        # ê²€ì¦ ê²°ê³¼ ì €ì¥
        self.verification_results = []
        
        # ìƒ‰ìƒ ì •ì˜
        self.colors = {
            'RED': '\033[0;31m',
            'GREEN': '\033[0;32m',
            'YELLOW': '\033[1;33m',
            'BLUE': '\033[0;34m',
            'PURPLE': '\033[0;35m',
            'CYAN': '\033[0;36m',
            'NC': '\033[0m'
        }
        
        self.logger.info("ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ê²€ì¦ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
    
    def _setup_logging(self):
        """ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ì •"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
logging.FileHandler(self.log_file,_encoding = 'utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _print_colored(self, message: str, color: str = 'NC'):
        """ìƒ‰ìƒì´ ìˆëŠ” ë©”ì‹œì§€ ì¶œë ¥"""
        print(f"{self.colors[color]}{message}{self.colors['NC']}")
    
    def _log_result(self, test_name: str, status: str, message: str, 
execution_time:_float =  0, details: Dict = None):
        """ê²€ì¦ ê²°ê³¼ ë¡œê¹…"""
        result = {
            'test_name': test_name,
            'status': status,
            'message': message,
            'execution_time': execution_time,
            'timestamp': datetime.now().isoformat(),
            'details': details or {}
        }
        
        self.verification_results.append(result)
        
        # ë¡œê·¸ ë ˆë²¨ ê²°ì •
        level = logging.ERROR if status == 'failed' else logging.WARNING if status == 'warning' else logging.INFO
        self.logger.log(level, f"[{test_name}] {message}")
    
    def verify_file_structure(self) -> bool:
        """íŒŒì¼ êµ¬ì¡° ê²€ì¦"""
        self._print_colored("ğŸ“ íŒŒì¼ êµ¬ì¡° ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        required_files = [
            ".naming_backup/config_data_backup/watchhamster.log",
            "Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py",
            "Monitoring/WatchHamster_v3.0/core/module_registry.py",
            "Monitoring/WatchHamster_v3.0/core/notification_manager.py",
            "Monitoring/WatchHamster_v3.0/core/watchhamster_integration.py",
            "Monitoring/WatchHamster_v3.0/modules.json",
            ".naming_backup/scripts/.naming_backup/scripts/watchhamster_control_center.sh"
        ]
        
        missing_files = []
        existing_files = []
        
        for file_path in required_files:
            full_path = self.script_dir / file_path
            if full_path.exists():
                existing_files.append(file_path)
                self._print_colored(f"  âœ… {file_path}", 'GREEN')
            else:
                missing_files.append(file_path)
                self._print_colored(f"  âŒ {file_path} (ëˆ„ë½)", 'RED')
        
        execution_time = time.time() - start_time
        
        if missing_files:
            self._log_result(
                'file_structure',
                'failed',
                f'{len(missing_files)}ê°œ íŒŒì¼ ëˆ„ë½',
                execution_time,
                {'missing_files': missing_files, 'existing_files': existing_files}
            )
            return False
        else:
            self._log_result(
                'file_structure',
                'passed',
                'ëª¨ë“  í•„ìˆ˜ íŒŒì¼ ì¡´ì¬ í™•ì¸',
                execution_time,
                {'file_count': len(existing_files)}
            )
            return True
    
    def verify_v2_components_loading(self) -> bool:
        """v2 ì»´í¬ë„ŒíŠ¸ ë¡œë”© ê²€ì¦"""
        self._print_colored("ğŸ”§ v2 ì»´í¬ë„ŒíŠ¸ ë¡œë”© ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            # WatchHamster v3.0.0 ì»´í¬ë„ŒíŠ¸ ë¡œë“œ í…ŒìŠ¤íŠ¸
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/POSCO News 250808_mini')
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
    from .comprehensive_repair_backup/monitor_.naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log_v3.0.py.backup_20250809_181656 import .naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log v3.00Monitor
    wh = WatchHamster v3.00Monitor()
    
    # v2 ì»´í¬ë„ŒíŠ¸ í™•ì¸
    components = {{}}
    components['v3_0_enabled'] = getattr(wh, 'v3_0_enabled', False)
    components['process_manager'] = wh.process_manager is not None
    components['module_registry'] = wh.module_registry is not None
    components['notification_manager'] = wh.notification_manager is not None
    
    print('COMPONENTS_STATUS:', components)
    
    if components['v3_0_enabled']:
        print('V2_INITIALIZATION: SUCCESS')
    else:
        print('V2_INITIALIZATION: FALLBACK')
        
except Exception as e:
    print('V2_INITIALIZATION: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=30)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0:
                output_lines = result.stdout.strip().split('\n')
                
                # ì»´í¬ë„ŒíŠ¸ ìƒíƒœ íŒŒì‹±
                components_status = {}
                v2_status = "UNKNOWN"
                
                for line in output_lines:
                    if line.startswith('COMPONENTS_STATUS:'):
                        try:
                            components_str = line.replace('COMPONENTS_STATUS:', '').strip()
                            components_status = eval(components_str)
                        except:
                            pass
                    elif line.startswith('V2_INITIALIZATION:'):
                        v2_status = line.replace('V2_INITIALIZATION:', '').strip()
                
                if v2_status == "SUCCESS":
                    self._print_colored("  âœ… v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì„±ê³µ", 'GREEN')
                    for comp_name, comp_status in components_status.items():
                        status_icon = "âœ…" if comp_status else "âŒ"
                        self._print_colored(f"    {status_icon} {comp_name}: {comp_status}", 
                                          'GREEN' if comp_status else 'RED')
                    
                    self._log_result(
                        'v2_components_loading',
                        'passed',
                        'v2 ì»´í¬ë„ŒíŠ¸ ë¡œë”© ì„±ê³µ',
                        execution_time,
                        {'components': components_status, 'v2_status': v2_status}
                    )
                    return True
                elif v2_status == "FALLBACK":
                    self._print_colored("  âš ï¸ v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©", 'YELLOW')
                    self._log_result(
                        'v2_components_loading',
                        'warning',
                        'v2 ì»´í¬ë„ŒíŠ¸ í´ë°± ëª¨ë“œ',
                        execution_time,
                        {'components': components_status, 'v2_status': v2_status}
                    )
                    return True  # í´ë°±ë„ ì •ìƒ ë™ì‘ìœ¼ë¡œ ê°„ì£¼
                else:
                    self._print_colored("  âŒ v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì˜¤ë¥˜", 'RED')
                    self._log_result(
                        'v2_components_loading',
                        'failed',
                        'v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì˜¤ë¥˜',
                        execution_time,
                        {'error': result.stderr, 'v2_status': v2_status}
                    )
                    return False
            else:
                self._print_colored(f"  âŒ ì»´í¬ë„ŒíŠ¸ ë¡œë”© í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {result.stderr}", 'RED')
                self._log_result(
                    'v2_components_loading',
                    'failed',
                    'ì»´í¬ë„ŒíŠ¸ ë¡œë”© í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨',
                    execution_time,
                    {'error': result.stderr, 'returncode': result.returncode}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ ì»´í¬ë„ŒíŠ¸ ë¡œë”© ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'v2_components_loading',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def verify_watchhamster_functionality(self) -> bool:
        """ì›Œì¹˜í–„ìŠ¤í„° ê¸°ëŠ¥ ê²€ì¦"""
        self._print_colored("ğŸ¹ ì›Œì¹˜í–„ìŠ¤í„° ê¸°ëŠ¥ ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            watchhamster_path = self.script_dir / ".naming_backup/config_data_backup/watchhamster.log"
            
            # ì›Œì¹˜í–„ìŠ¤í„° ì„ì‹œ ì‹¤í–‰ (15ì´ˆ)
            self._print_colored("  ğŸš€ ì›Œì¹˜í–„ìŠ¤í„° ì„ì‹œ ì‹¤í–‰ ì¤‘...", 'YELLOW')
            
            process = subprocess.Popen([
                "python3", str(watchhamster_path)
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE, 
               cwd=watchhamster_path.parent)
            
            # ì´ˆê¸°í™” ëŒ€ê¸°
            time.sleep(8)
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            if process.poll() is None:
                self._print_colored("  âœ… ì›Œì¹˜í–„ìŠ¤í„° ì •ìƒ ì‹¤í–‰ ì¤‘", 'GREEN')
                
                # í•˜ìœ„ í”„ë¡œì„¸ìŠ¤ í™•ì¸
                time.sleep(5)
                child_processes = self._check_child_processes()
                
                # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
                process.terminate()
                try:
                    process.wait(timeout=10)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait()
                
                execution_time = time.time() - start_time
                
                self._log_result(
                    'watchhamster_functionality',
                    'passed',
                    'ì›Œì¹˜í–„ìŠ¤í„° ê¸°ëŠ¥ ê²€ì¦ ì„±ê³µ',
                    execution_time,
                    {'child_processes': child_processes}
                )
                return True
            else:
                # í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë¨
stdout,_stderr =  process.communicate()
                execution_time = time.time() - start_time
                
                self._print_colored(f"  âŒ WatchHamster v3.0 ì‹¤íŒ¨", 'RED')
                if stderr:
                    self._print_colored(f"    ì˜¤ë¥˜: {stderr.decode()[:200]}", 'RED')
                
                self._log_result(
                    'watchhamster_functionality',
                    'failed',
                    'WatchHamster v3.0 ì‹¤íŒ¨',
                    execution_time,
                    {'stderr': stderr.decode()[:500] if stderr else '', 
                     'stdout': stdout.decode()[:500] if stdout else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ WatchHamster v3.0 ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'watchhamster_functionality',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def _check_child_processes(self) -> Dict[str, bool]:
        """í•˜ìœ„ í”„ë¡œì„¸ìŠ¤ í™•ì¸"""
        expected_processes = [
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/posco_main_notifier.py",
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/realtime_news_monitor.py",
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/integrated_report_scheduler.py"
        ]
        
        child_processes = {}
        
        for proc_name in expected_processes:
            try:
                result = subprocess.run([
                    'pgrep', '-f', proc_name
],_capture_output = True)
                
                is_running = result.returncode == 0
                child_processes[proc_name] = is_running
                
                status_icon = "âœ…" if is_running else "âš ï¸"
                self._print_colored(f"    {status_icon} {proc_name}: {'ì‹¤í–‰ì¤‘' if is_running else 'ì¤‘ì§€ë¨'}", 
                                  'GREEN' if is_running else 'YELLOW')
                
            except Exception as e:
                child_processes[proc_name] = False
                self._print_colored(f"    âŒ {proc_name}: í™•ì¸ ì‹¤íŒ¨ ({str(e)})", 'RED')
        
        return child_processes
    
    def verify_control_center_functionality(self) -> bool:
        """ì œì–´ì„¼í„° ê¸°ëŠ¥ ê²€ì¦"""
        self._print_colored("ğŸ›ï¸ ì œì–´ì„¼í„° ê¸°ëŠ¥ ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            control_center_path = self.script_dir / ".naming_backup/scripts/.naming_backup/scripts/watchhamster_control_center.sh"
            
            if not control_center_path.exists():
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    'ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ì—†ìŒ',
                    time.time() - start_time
                )
                return False
            
            # ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ê²€ì‚¬
            result = subprocess.run([
                "bash", "-n", str(control_center_path)
],_capture_output = True, text=True)
            
            if result.returncode != 0:
                self._print_colored(f"  âŒ ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ì˜¤ë¥˜", 'RED')
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    'ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ì˜¤ë¥˜',
                    time.time() - start_time,
                    {'syntax_error': result.stderr}
                )
                return False
            
            self._print_colored("  âœ… ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ê²€ì‚¬ í†µê³¼", 'GREEN')
            
            # ì œì–´ì„¼í„° ë©”ë‰´ êµ¬ì¡° í™•ì¸
with_open(control_center_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            required_functions = [
                'start_watchhamster',
                'check_watchhamster_status',
                'stop_watchhamster',
                'manage_modules'
            ]
            
            missing_functions = []
            for func in required_functions:
                if func not in content:
                    missing_functions.append(func)
                else:
                    self._print_colored(f"    âœ… {func} í•¨ìˆ˜ ì¡´ì¬", 'GREEN')
            
            execution_time = time.time() - start_time
            
            if missing_functions:
                self._print_colored(f"  âŒ ëˆ„ë½ëœ í•¨ìˆ˜: {missing_functions}", 'RED')
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    f'í•„ìˆ˜ í•¨ìˆ˜ ëˆ„ë½: {missing_functions}',
                    execution_time,
                    {'missing_functions': missing_functions}
                )
                return False
            else:
                self._print_colored("  âœ… ëª¨ë“  í•„ìˆ˜ í•¨ìˆ˜ ì¡´ì¬ í™•ì¸", 'GREEN')
                self._log_result(
                    'control_center_functionality',
                    'passed',
                    'ì œì–´ì„¼í„° ê¸°ëŠ¥ ê²€ì¦ ì„±ê³µ',
                    execution_time,
                    {'functions_found': required_functions}
                )
                return True
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ ì œì–´ì„¼í„° ê¸°ëŠ¥ ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'control_center_functionality',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def verify_module_registry_configuration(self) -> bool:
        """ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì„¤ì • ê²€ì¦"""
        self._print_colored("ğŸ“‹ ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì„¤ì • ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            modules_json_path = self.script_dir / "Monitoring/WatchHamster_v3.0/modules.json"
            
            if not modules_json_path.exists():
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    'modules.json íŒŒì¼ ì—†ìŒ',
                    time.time() - start_time
                )
                return False
            
            # modules.json ë¡œë“œ ë° ê²€ì¦
with_open(modules_json_path,_'r',_encoding = 'utf-8') as f:
                modules_config = json.load(f)
            
            # í•„ìˆ˜ êµ¬ì¡° í™•ì¸
            if 'modules' not in modules_config:
                self._print_colored("  âŒ modules.jsonì— 'modules' ì„¹ì…˜ ì—†ìŒ", 'RED')
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    'modules ì„¹ì…˜ ëˆ„ë½',
                    time.time() - start_time
                )
                return False
            
            # í•„ìˆ˜ ëª¨ë“ˆ í™•ì¸
            required_modules = [
                'posco_main_notifier',
                'realtime_news_monitor',
                'integrated_report_scheduler'
            ]
            
            missing_modules = []
            configured_modules = []
            
            for module in required_modules:
                if module in modules_config['modules']:
                    configured_modules.append(module)
                    self._print_colored(f"    âœ… {module} ëª¨ë“ˆ ì„¤ì • ì¡´ì¬", 'GREEN')
                    
                    # ëª¨ë“ˆ ì„¤ì • ìƒì„¸ ê²€ì¦
                    module_config = modules_config['modules'][module]
                    required_fields = ['script_path', 'description', 'auto_start']
                    
                    for field in required_fields:
                        if field not in module_config:
                            self._print_colored(f"      âš ï¸ {module}.{field} í•„ë“œ ëˆ„ë½", 'YELLOW')
                        else:
                            self._print_colored(f"      âœ… {module}.{field}: {module_config[field]}", 'GREEN')
                else:
                    missing_modules.append(module)
                    self._print_colored(f"    âŒ {module} ëª¨ë“ˆ ì„¤ì • ëˆ„ë½", 'RED')
            
            execution_time = time.time() - start_time
            
            if missing_modules:
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    f'í•„ìˆ˜ ëª¨ë“ˆ ì„¤ì • ëˆ„ë½: {missing_modules}',
                    execution_time,
                    {'missing_modules': missing_modules, 'configured_modules': configured_modules}
                )
                return False
            else:
                self._print_colored("  âœ… ëª¨ë“  í•„ìˆ˜ ëª¨ë“ˆ ì„¤ì • í™•ì¸", 'GREEN')
                self._log_result(
                    'module_registry_configuration',
                    'passed',
                    'ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì„¤ì • ê²€ì¦ ì„±ê³µ',
                    execution_time,
                    {'configured_modules': configured_modules, 'total_modules': len(modules_config['modules'])}
                )
                return True
                
        except Exception:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ modules.json íŒŒì‹± ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'module_registry_configuration',
                'failed',
                f'JSON íŒŒì‹± ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'module_registry_configuration',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def verify_notification_system(self) -> bool:
        """ì•Œë¦¼ ì‹œìŠ¤í…œ ê²€ì¦"""
        self._print_colored("ğŸ“¢ ì•Œë¦¼ ì‹œìŠ¤í…œ ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            # v2 NotificationManager ë¡œë“œ í…ŒìŠ¤íŠ¸
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
# BROKEN_REF:     from Monitoring/WatchHamster_v3.0/core/notification_manager.py import NotificationManager
    
    # í…ŒìŠ¤íŠ¸ìš© NotificationManager ìƒì„±
    nm = NotificationManager('test_webhook_url', 'test_profile_image')
    
    # ê¸°ë³¸ ë©”ì„œë“œ ì¡´ì¬ í™•ì¸
    methods = ['send_notification', 'send_status_update', 'send_emergency_alert']
    for method in methods:
        if hasattr(nm, method):
            print(f'METHOD_EXISTS: {{method}}')
        else:
            print(f'METHOD_MISSING: {{method}}')
    
    print('NOTIFICATION_MANAGER: SUCCESS')
    
except Exception as e:
    print('NOTIFICATION_MANAGER: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=15)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0 and "NOTIFICATION_MANAGER: SUCCESS" in result.stdout:
                self._print_colored("  âœ… NotificationManager ë¡œë“œ ì„±ê³µ", 'GREEN')
                
                # ë©”ì„œë“œ ì¡´ì¬ í™•ì¸
                output_lines = result.stdout.strip().split('\n')
                methods_status = {}
                
                for line in output_lines:
                    if line.startswith('METHOD_EXISTS:'):
                        method = line.replace('METHOD_EXISTS:', '').strip()
                        methods_status[method] = True
                        self._print_colored(f"    âœ… {method} ë©”ì„œë“œ ì¡´ì¬", 'GREEN')
                    elif line.startswith('METHOD_MISSING:'):
                        method = line.replace('METHOD_MISSING:', '').strip()
                        methods_status[method] = False
                        self._print_colored(f"    âŒ {method} ë©”ì„œë“œ ëˆ„ë½", 'RED')
                
                self._log_result(
                    'notification_system',
                    'passed',
                    'NotificationManager ê²€ì¦ ì„±ê³µ',
                    execution_time,
                    {'methods_status': methods_status}
                )
                return True
            else:
                self._print_colored(f"  âŒ NotificationManager ë¡œë“œ ì‹¤íŒ¨", 'RED')
                if result.stderr:
                    self._print_colored(f"    ì˜¤ë¥˜: {result.stderr[:200]}", 'RED')
                
                self._log_result(
                    'notification_system',
                    'failed',
                    'NotificationManager ë¡œë“œ ì‹¤íŒ¨',
                    execution_time,
                    {'error': result.stderr[:500] if result.stderr else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ ì•Œë¦¼ ì‹œìŠ¤í…œ ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'notification_system',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def verify_process_management(self) -> bool:
        """í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê²€ì¦"""
        self._print_colored("âš™ï¸ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê²€ì¦ ì‹œì‘", 'BLUE')
        start_time = time.time()
        
        try:
            # v2 ProcessManager ë¡œë“œ í…ŒìŠ¤íŠ¸
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
# BROKEN_REF:     from Monitoring/POSCO_News_250808/core/process_manager.py import ProcessManager
    
    # í…ŒìŠ¤íŠ¸ìš© ProcessManager ìƒì„±
    pm = ProcessManager('{self.script_dir}/Monitoring/POSCO News 250808_mini')
    
    # ê¸°ë³¸ ë©”ì„œë“œ ì¡´ì¬ í™•ì¸
    methods = ['start_process', 'stop_process', 'restart_process', 'get_process_status']
    for method in methods:
        if hasattr(pm, method):
            print(f'METHOD_EXISTS: {{method}}')
        else:
            print(f'METHOD_MISSING: {{method}}')
    
    print('PROCESS_MANAGER: SUCCESS')
    
except Exception as e:
    print('PROCESS_MANAGER: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=15)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0 and "PROCESS_MANAGER: SUCCESS" in result.stdout:
                self._print_colored("  âœ… ProcessManager ë¡œë“œ ì„±ê³µ", 'GREEN')
                
                # ë©”ì„œë“œ ì¡´ì¬ í™•ì¸
                output_lines = result.stdout.strip().split('\n')
                methods_status = {}
                
                for line in output_lines:
                    if line.startswith('METHOD_EXISTS:'):
                        method = line.replace('METHOD_EXISTS:', '').strip()
                        methods_status[method] = True
                        self._print_colored(f"    âœ… {method} ë©”ì„œë“œ ì¡´ì¬", 'GREEN')
                    elif line.startswith('METHOD_MISSING:'):
                        method = line.replace('METHOD_MISSING:', '').strip()
                        methods_status[method] = False
                        self._print_colored(f"    âŒ {method} ë©”ì„œë“œ ëˆ„ë½", 'RED')
                
                self._log_result(
                    'process_management',
                    'passed',
                    'ProcessManager ê²€ì¦ ì„±ê³µ',
                    execution_time,
                    {'methods_status': methods_status}
                )
                return True
            else:
                self._print_colored(f"  âŒ ProcessManager ë¡œë“œ ì‹¤íŒ¨", 'RED')
                if result.stderr:
                    self._print_colored(f"    ì˜¤ë¥˜: {result.stderr[:200]}", 'RED')
                
                self._log_result(
                    'process_management',
                    'failed',
                    'ProcessManager ë¡œë“œ ì‹¤íŒ¨',
                    execution_time,
                    {'error': result.stderr[:500] if result.stderr else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  âŒ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
            self._log_result(
                'process_management',
                'failed',
                f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}',
                execution_time
            )
            return False
    
    def run_comprehensive_verification(self) -> bool:
        """ì¢…í•© ê²€ì¦ ì‹¤í–‰"""
        self._print_colored("ğŸš€ POSCO WatchHamster v3.0 ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ì¢…í•© ê²€ì¦ ì‹œì‘", 'CYAN')
        
        verification_tests = [
            ("íŒŒì¼ êµ¬ì¡°", self.verify_file_structure),
            ("v2 ì»´í¬ë„ŒíŠ¸ ë¡œë”©", self.verify_v2_components_loading),
            ("ì›Œì¹˜í–„ìŠ¤í„° ê¸°ëŠ¥", self.verify_watchhamster_functionality),
            ("ì œì–´ì„¼í„° ê¸°ëŠ¥", self.verify_control_center_functionality),
            ("ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì„¤ì •", self.verify_module_registry_configuration),
            ("ì•Œë¦¼ ì‹œìŠ¤í…œ", self.verify_notification_system),
            ("í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬", self.verify_process_management)
        ]
        
        all_passed = True
        passed_count = 0
        
        for test_name, test_func in verification_tests:
            self._print_colored(f"\n{'='*60}", 'CYAN')
            try:
                result = test_func()
                if result:
passed_count_+ =  1
                    self._print_colored(f"âœ… {test_name} ê²€ì¦ ì™„ë£Œ", 'GREEN')
                else:
                    all_passed = False
                    self._print_colored(f"âŒ {test_name} ê²€ì¦ ì‹¤íŒ¨", 'RED')
            except Exception as e:
                all_passed = False
                self._print_colored(f"âŒ {test_name} ê²€ì¦ ì˜¤ë¥˜: {str(e)}", 'RED')
                self.logger.error(f"{test_name} ê²€ì¦ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {str(e)}")
        
        # ê²°ê³¼ ì €ì¥
with_open(self.results_file,_'w',_encoding = 'utf-8') as f:
            json.dump(self.verification_results, f, indent=2, ensure_ascii=False)
        
        # ìµœì¢… ê²°ê³¼ ì¶œë ¥
        self._print_colored(f"\n{'='*60}", 'CYAN')
        self._print_colored("ğŸ“‹ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ê²€ì¦ ê²°ê³¼ ìš”ì•½", 'CYAN')
        self._print_colored(f"{'='*60}", 'CYAN')
        
        total_tests = len(verification_tests)
        self._print_colored(f"ì „ì²´ í…ŒìŠ¤íŠ¸: {total_tests}ê°œ", 'BLUE')
        self._print_colored(f"í†µê³¼: {passed_count}ê°œ", 'GREEN')
        self._print_colored(f"ì‹¤íŒ¨: {total_tests - passed_count}ê°œ", 'RED')
        
        if all_passed:
            self._print_colored("\nğŸ‰ ëª¨ë“  ê²€ì¦ í†µê³¼! ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", 'GREEN')
        else:
            self._print_colored(f"\nâŒ {total_tests - passed_count}ê°œ ê²€ì¦ ì‹¤íŒ¨. ë¬¸ì œë¥¼ í•´ê²°í•˜ê±°ë‚˜ ë¡¤ë°±ì„ ê³ ë ¤í•˜ì„¸ìš”.", 'RED')
        
        self._print_colored(f"\nğŸ“„ ìƒì„¸ ê²°ê³¼: {self.results_file}", 'BLUE')
        self._print_colored(f"ğŸ“„ ë¡œê·¸ íŒŒì¼: {self.log_file}", 'BLUE')
        
        return all_passed

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    verification = PostMigrationVerification()
    success = verification.run_comprehensive_verification()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()