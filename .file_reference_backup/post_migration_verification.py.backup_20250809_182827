#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Post Migration Verification
POSCO 시스템 구성요소

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import test_config.json
# BROKEN_REF: import subprocess
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
# BROKEN_REF: import signal
# BROKEN_REF: import psutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: from typing import Dict, List, Optional, Tuple
# BROKEN_REF: import logging

class PostMigrationVerification:
    """마이그레이션 후 검증 클래스"""
    
    def __init__(self):
        self.script_dir = Path(__file__).parent.absolute()
        self.log_file = self.script_dir / "post_migration_verification.py"
        self.results_file = self.script_dir / "final_integration_final_integration_verification_results.json"
        
        # 로깅 설정
        self._setup_logging()
        
        # 검증 결과 저장
        self.verification_results = []
        
        # 색상 정의
        self.colors = {
            'RED': '\033[0;31m',
            'GREEN': '\033[0;32m',
            'YELLOW': '\033[1;33m',
            'BLUE': '\033[0;34m',
            'PURPLE': '\033[0;35m',
            'CYAN': '\033[0;36m',
            'NC': '\033[0m'
        }
        
        self.logger.info("마이그레이션 후 검증 시스템 초기화 완료")
    
    def _setup_logging(self):
        """로깅 시스템 설정"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
logging.FileHandler(self.log_file,_encoding = 'utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _print_colored(self, message: str, color: str = 'NC'):
        """색상이 있는 메시지 출력"""
        print(f"{self.colors[color]}{message}{self.colors['NC']}")
    
    def _log_result(self, test_name: str, status: str, message: str, 
execution_time:_float =  0, details: Dict = None):
        """검증 결과 로깅"""
        result = {
            'test_name': test_name,
            'status': status,
            'message': message,
            'execution_time': execution_time,
            'timestamp': datetime.now().isoformat(),
            'details': details or {}
        }
        
        self.verification_results.append(result)
        
        # 로그 레벨 결정
        level = logging.ERROR if status == 'failed' else logging.WARNING if status == 'warning' else logging.INFO
        self.logger.log(level, f"[{test_name}] {message}")
    
    def verify_file_structure(self) -> bool:
        """파일 구조 검증"""
        self._print_colored("📁 파일 구조 검증 시작", 'BLUE')
        start_time = time.time()
        
        required_files = [
            ".naming_backup/config_data_backup/watchhamster.log",
            "Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py",
            "Monitoring/WatchHamster_v3.0/core/module_registry.py",
            "Monitoring/WatchHamster_v3.0/core/notification_manager.py",
            "Monitoring/WatchHamster_v3.0/core/watchhamster_integration.py",
            "Monitoring/WatchHamster_v3.0/modules.json",
            ".naming_backup/scripts/.naming_backup/scripts/watchhamster_control_center.sh"
        ]
        
        missing_files = []
        existing_files = []
        
        for file_path in required_files:
            full_path = self.script_dir / file_path
            if full_path.exists():
                existing_files.append(file_path)
                self._print_colored(f"  ✅ {file_path}", 'GREEN')
            else:
                missing_files.append(file_path)
                self._print_colored(f"  ❌ {file_path} (누락)", 'RED')
        
        execution_time = time.time() - start_time
        
        if missing_files:
            self._log_result(
                'file_structure',
                'failed',
                f'{len(missing_files)}개 파일 누락',
                execution_time,
                {'missing_files': missing_files, 'existing_files': existing_files}
            )
            return False
        else:
            self._log_result(
                'file_structure',
                'passed',
                '모든 필수 파일 존재 확인',
                execution_time,
                {'file_count': len(existing_files)}
            )
            return True
    
    def verify_v2_components_loading(self) -> bool:
        """v2 컴포넌트 로딩 검증"""
        self._print_colored("🔧 v2 컴포넌트 로딩 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            # WatchHamster v3.0.0 컴포넌트 로드 테스트
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/POSCO News 250808_mini')
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
    from .comprehensive_repair_backup/monitor_.naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log_v3.0.py.backup_20250809_181656 import .naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log v3.00Monitor
    wh = WatchHamster v3.00Monitor()
    
    # v2 컴포넌트 확인
    components = {{}}
    components['v3_0_enabled'] = getattr(wh, 'v3_0_enabled', False)
    components['process_manager'] = wh.process_manager is not None
    components['module_registry'] = wh.module_registry is not None
    components['notification_manager'] = wh.notification_manager is not None
    
    print('COMPONENTS_STATUS:', components)
    
    if components['v3_0_enabled']:
        print('V2_INITIALIZATION: SUCCESS')
    else:
        print('V2_INITIALIZATION: FALLBACK')
        
except Exception as e:
    print('V2_INITIALIZATION: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=30)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0:
                output_lines = result.stdout.strip().split('\n')
                
                # 컴포넌트 상태 파싱
                components_status = {}
                v2_status = "UNKNOWN"
                
                for line in output_lines:
                    if line.startswith('COMPONENTS_STATUS:'):
                        try:
                            components_str = line.replace('COMPONENTS_STATUS:', '').strip()
                            components_status = eval(components_str)
                        except:
                            pass
                    elif line.startswith('V2_INITIALIZATION:'):
                        v2_status = line.replace('V2_INITIALIZATION:', '').strip()
                
                if v2_status == "SUCCESS":
                    self._print_colored("  ✅ v2 컴포넌트 초기화 성공", 'GREEN')
                    for comp_name, comp_status in components_status.items():
                        status_icon = "✅" if comp_status else "❌"
                        self._print_colored(f"    {status_icon} {comp_name}: {comp_status}", 
                                          'GREEN' if comp_status else 'RED')
                    
                    self._log_result(
                        'v2_components_loading',
                        'passed',
                        'v2 컴포넌트 로딩 성공',
                        execution_time,
                        {'components': components_status, 'v2_status': v2_status}
                    )
                    return True
                elif v2_status == "FALLBACK":
                    self._print_colored("  ⚠️ v2 컴포넌트 초기화 실패, 기존 방식 사용", 'YELLOW')
                    self._log_result(
                        'v2_components_loading',
                        'warning',
                        'v2 컴포넌트 폴백 모드',
                        execution_time,
                        {'components': components_status, 'v2_status': v2_status}
                    )
                    return True  # 폴백도 정상 동작으로 간주
                else:
                    self._print_colored("  ❌ v2 컴포넌트 초기화 오류", 'RED')
                    self._log_result(
                        'v2_components_loading',
                        'failed',
                        'v2 컴포넌트 초기화 오류',
                        execution_time,
                        {'error': result.stderr, 'v2_status': v2_status}
                    )
                    return False
            else:
                self._print_colored(f"  ❌ 컴포넌트 로딩 테스트 실패: {result.stderr}", 'RED')
                self._log_result(
                    'v2_components_loading',
                    'failed',
                    '컴포넌트 로딩 테스트 실패',
                    execution_time,
                    {'error': result.stderr, 'returncode': result.returncode}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ 컴포넌트 로딩 검증 오류: {str(e)}", 'RED')
            self._log_result(
                'v2_components_loading',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def verify_watchhamster_functionality(self) -> bool:
        """워치햄스터 기능 검증"""
        self._print_colored("🐹 워치햄스터 기능 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            watchhamster_path = self.script_dir / ".naming_backup/config_data_backup/watchhamster.log"
            
            # 워치햄스터 임시 실행 (15초)
            self._print_colored("  🚀 워치햄스터 임시 실행 중...", 'YELLOW')
            
            process = subprocess.Popen([
                "python3", str(watchhamster_path)
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE, 
               cwd=watchhamster_path.parent)
            
            # 초기화 대기
            time.sleep(8)
            
            # 프로세스 상태 확인
            if process.poll() is None:
                self._print_colored("  ✅ 워치햄스터 정상 실행 중", 'GREEN')
                
                # 하위 프로세스 확인
                time.sleep(5)
                child_processes = self._check_child_processes()
                
                # 프로세스 종료
                process.terminate()
                try:
                    process.wait(timeout=10)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait()
                
                execution_time = time.time() - start_time
                
                self._log_result(
                    'watchhamster_functionality',
                    'passed',
                    '워치햄스터 기능 검증 성공',
                    execution_time,
                    {'child_processes': child_processes}
                )
                return True
            else:
                # 프로세스가 종료됨
stdout,_stderr =  process.communicate()
                execution_time = time.time() - start_time
                
                self._print_colored(f"  ❌ WatchHamster v3.0 실패", 'RED')
                if stderr:
                    self._print_colored(f"    오류: {stderr.decode()[:200]}", 'RED')
                
                self._log_result(
                    'watchhamster_functionality',
                    'failed',
                    'WatchHamster v3.0 실패',
                    execution_time,
                    {'stderr': stderr.decode()[:500] if stderr else '', 
                     'stdout': stdout.decode()[:500] if stdout else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ WatchHamster v3.0 오류: {str(e)}", 'RED')
            self._log_result(
                'watchhamster_functionality',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def _check_child_processes(self) -> Dict[str, bool]:
        """하위 프로세스 확인"""
        expected_processes = [
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/posco_main_notifier.py",
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/realtime_news_monitor.py",
            "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/integrated_report_scheduler.py"
        ]
        
        child_processes = {}
        
        for proc_name in expected_processes:
            try:
                result = subprocess.run([
                    'pgrep', '-f', proc_name
],_capture_output = True)
                
                is_running = result.returncode == 0
                child_processes[proc_name] = is_running
                
                status_icon = "✅" if is_running else "⚠️"
                self._print_colored(f"    {status_icon} {proc_name}: {'실행중' if is_running else '중지됨'}", 
                                  'GREEN' if is_running else 'YELLOW')
                
            except Exception as e:
                child_processes[proc_name] = False
                self._print_colored(f"    ❌ {proc_name}: 확인 실패 ({str(e)})", 'RED')
        
        return child_processes
    
    def verify_control_center_functionality(self) -> bool:
        """제어센터 기능 검증"""
        self._print_colored("🎛️ 제어센터 기능 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            control_center_path = self.script_dir / ".naming_backup/scripts/.naming_backup/scripts/watchhamster_control_center.sh"
            
            if not control_center_path.exists():
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    '제어센터 스크립트 파일 없음',
                    time.time() - start_time
                )
                return False
            
            # 스크립트 문법 검사
            result = subprocess.run([
                "bash", "-n", str(control_center_path)
],_capture_output = True, text=True)
            
            if result.returncode != 0:
                self._print_colored(f"  ❌ 제어센터 스크립트 문법 오류", 'RED')
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    '제어센터 스크립트 문법 오류',
                    time.time() - start_time,
                    {'syntax_error': result.stderr}
                )
                return False
            
            self._print_colored("  ✅ 제어센터 스크립트 문법 검사 통과", 'GREEN')
            
            # 제어센터 메뉴 구조 확인
with_open(control_center_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            required_functions = [
                'start_watchhamster',
                'check_watchhamster_status',
                'stop_watchhamster',
                'manage_modules'
            ]
            
            missing_functions = []
            for func in required_functions:
                if func not in content:
                    missing_functions.append(func)
                else:
                    self._print_colored(f"    ✅ {func} 함수 존재", 'GREEN')
            
            execution_time = time.time() - start_time
            
            if missing_functions:
                self._print_colored(f"  ❌ 누락된 함수: {missing_functions}", 'RED')
                self._log_result(
                    'control_center_functionality',
                    'failed',
                    f'필수 함수 누락: {missing_functions}',
                    execution_time,
                    {'missing_functions': missing_functions}
                )
                return False
            else:
                self._print_colored("  ✅ 모든 필수 함수 존재 확인", 'GREEN')
                self._log_result(
                    'control_center_functionality',
                    'passed',
                    '제어센터 기능 검증 성공',
                    execution_time,
                    {'functions_found': required_functions}
                )
                return True
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ 제어센터 기능 검증 오류: {str(e)}", 'RED')
            self._log_result(
                'control_center_functionality',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def verify_module_registry_configuration(self) -> bool:
        """모듈 레지스트리 설정 검증"""
        self._print_colored("📋 모듈 레지스트리 설정 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            modules_json_path = self.script_dir / "Monitoring/WatchHamster_v3.0/modules.json"
            
            if not modules_json_path.exists():
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    'modules.json 파일 없음',
                    time.time() - start_time
                )
                return False
            
            # modules.json 로드 및 검증
with_open(modules_json_path,_'r',_encoding = 'utf-8') as f:
                modules_config = json.load(f)
            
            # 필수 구조 확인
            if 'modules' not in modules_config:
                self._print_colored("  ❌ modules.json에 'modules' 섹션 없음", 'RED')
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    'modules 섹션 누락',
                    time.time() - start_time
                )
                return False
            
            # 필수 모듈 확인
            required_modules = [
                'posco_main_notifier',
                'realtime_news_monitor',
                'integrated_report_scheduler'
            ]
            
            missing_modules = []
            configured_modules = []
            
            for module in required_modules:
                if module in modules_config['modules']:
                    configured_modules.append(module)
                    self._print_colored(f"    ✅ {module} 모듈 설정 존재", 'GREEN')
                    
                    # 모듈 설정 상세 검증
                    module_config = modules_config['modules'][module]
                    required_fields = ['script_path', 'description', 'auto_start']
                    
                    for field in required_fields:
                        if field not in module_config:
                            self._print_colored(f"      ⚠️ {module}.{field} 필드 누락", 'YELLOW')
                        else:
                            self._print_colored(f"      ✅ {module}.{field}: {module_config[field]}", 'GREEN')
                else:
                    missing_modules.append(module)
                    self._print_colored(f"    ❌ {module} 모듈 설정 누락", 'RED')
            
            execution_time = time.time() - start_time
            
            if missing_modules:
                self._log_result(
                    'module_registry_configuration',
                    'failed',
                    f'필수 모듈 설정 누락: {missing_modules}',
                    execution_time,
                    {'missing_modules': missing_modules, 'configured_modules': configured_modules}
                )
                return False
            else:
                self._print_colored("  ✅ 모든 필수 모듈 설정 확인", 'GREEN')
                self._log_result(
                    'module_registry_configuration',
                    'passed',
                    '모듈 레지스트리 설정 검증 성공',
                    execution_time,
                    {'configured_modules': configured_modules, 'total_modules': len(modules_config['modules'])}
                )
                return True
                
        except Exception:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ modules.json 파싱 오류: {str(e)}", 'RED')
            self._log_result(
                'module_registry_configuration',
                'failed',
                f'JSON 파싱 오류: {str(e)}',
                execution_time
            )
            return False
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ 모듈 레지스트리 검증 오류: {str(e)}", 'RED')
            self._log_result(
                'module_registry_configuration',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def verify_notification_system(self) -> bool:
        """알림 시스템 검증"""
        self._print_colored("📢 알림 시스템 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            # v2 NotificationManager 로드 테스트
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
# BROKEN_REF:     from Monitoring/WatchHamster_v3.0/core/notification_manager.py import NotificationManager
    
    # 테스트용 NotificationManager 생성
    nm = NotificationManager('test_webhook_url', 'test_profile_image')
    
    # 기본 메서드 존재 확인
    methods = ['send_notification', 'send_status_update', 'send_emergency_alert']
    for method in methods:
        if hasattr(nm, method):
            print(f'METHOD_EXISTS: {{method}}')
        else:
            print(f'METHOD_MISSING: {{method}}')
    
    print('NOTIFICATION_MANAGER: SUCCESS')
    
except Exception as e:
    print('NOTIFICATION_MANAGER: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=15)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0 and "NOTIFICATION_MANAGER: SUCCESS" in result.stdout:
                self._print_colored("  ✅ NotificationManager 로드 성공", 'GREEN')
                
                # 메서드 존재 확인
                output_lines = result.stdout.strip().split('\n')
                methods_status = {}
                
                for line in output_lines:
                    if line.startswith('METHOD_EXISTS:'):
                        method = line.replace('METHOD_EXISTS:', '').strip()
                        methods_status[method] = True
                        self._print_colored(f"    ✅ {method} 메서드 존재", 'GREEN')
                    elif line.startswith('METHOD_MISSING:'):
                        method = line.replace('METHOD_MISSING:', '').strip()
                        methods_status[method] = False
                        self._print_colored(f"    ❌ {method} 메서드 누락", 'RED')
                
                self._log_result(
                    'notification_system',
                    'passed',
                    'NotificationManager 검증 성공',
                    execution_time,
                    {'methods_status': methods_status}
                )
                return True
            else:
                self._print_colored(f"  ❌ NotificationManager 로드 실패", 'RED')
                if result.stderr:
                    self._print_colored(f"    오류: {result.stderr[:200]}", 'RED')
                
                self._log_result(
                    'notification_system',
                    'failed',
                    'NotificationManager 로드 실패',
                    execution_time,
                    {'error': result.stderr[:500] if result.stderr else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ 알림 시스템 검증 오류: {str(e)}", 'RED')
            self._log_result(
                'notification_system',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def verify_process_management(self) -> bool:
        """프로세스 관리 검증"""
        self._print_colored("⚙️ 프로세스 관리 검증 시작", 'BLUE')
        start_time = time.time()
        
        try:
            # v2 ProcessManager 로드 테스트
            test_script = f"""
import system_functionality_verification.py
sys.path.insert(0, '{self.script_dir}/Monitoring/WatchHamster_v3.0')

try:
# BROKEN_REF:     from Monitoring/POSCO_News_250808/core/process_manager.py import ProcessManager
    
    # 테스트용 ProcessManager 생성
    pm = ProcessManager('{self.script_dir}/Monitoring/POSCO News 250808_mini')
    
    # 기본 메서드 존재 확인
    methods = ['start_process', 'stop_process', 'restart_process', 'get_process_status']
    for method in methods:
        if hasattr(pm, method):
            print(f'METHOD_EXISTS: {{method}}')
        else:
            print(f'METHOD_MISSING: {{method}}')
    
    print('PROCESS_MANAGER: SUCCESS')
    
except Exception as e:
    print('PROCESS_MANAGER: ERROR')
    print('ERROR_MESSAGE:', str(e))
# BROKEN_REF:     import traceback
    traceback.print_exc()
            """
            
            result = subprocess.run([
                "python3", "-c", test_script
],_capture_output = True, text=True, timeout=15)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0 and "PROCESS_MANAGER: SUCCESS" in result.stdout:
                self._print_colored("  ✅ ProcessManager 로드 성공", 'GREEN')
                
                # 메서드 존재 확인
                output_lines = result.stdout.strip().split('\n')
                methods_status = {}
                
                for line in output_lines:
                    if line.startswith('METHOD_EXISTS:'):
                        method = line.replace('METHOD_EXISTS:', '').strip()
                        methods_status[method] = True
                        self._print_colored(f"    ✅ {method} 메서드 존재", 'GREEN')
                    elif line.startswith('METHOD_MISSING:'):
                        method = line.replace('METHOD_MISSING:', '').strip()
                        methods_status[method] = False
                        self._print_colored(f"    ❌ {method} 메서드 누락", 'RED')
                
                self._log_result(
                    'process_management',
                    'passed',
                    'ProcessManager 검증 성공',
                    execution_time,
                    {'methods_status': methods_status}
                )
                return True
            else:
                self._print_colored(f"  ❌ ProcessManager 로드 실패", 'RED')
                if result.stderr:
                    self._print_colored(f"    오류: {result.stderr[:200]}", 'RED')
                
                self._log_result(
                    'process_management',
                    'failed',
                    'ProcessManager 로드 실패',
                    execution_time,
                    {'error': result.stderr[:500] if result.stderr else ''}
                )
                return False
                
        except Exception as e:
            execution_time = time.time() - start_time
            self._print_colored(f"  ❌ 프로세스 관리 검증 오류: {str(e)}", 'RED')
            self._log_result(
                'process_management',
                'failed',
                f'검증 오류: {str(e)}',
                execution_time
            )
            return False
    
    def run_comprehensive_verification(self) -> bool:
        """종합 검증 실행"""
        self._print_colored("🚀 POSCO WatchHamster v3.0 마이그레이션 후 종합 검증 시작", 'CYAN')
        
        verification_tests = [
            ("파일 구조", self.verify_file_structure),
            ("v2 컴포넌트 로딩", self.verify_v2_components_loading),
            ("워치햄스터 기능", self.verify_watchhamster_functionality),
            ("제어센터 기능", self.verify_control_center_functionality),
            ("모듈 레지스트리 설정", self.verify_module_registry_configuration),
            ("알림 시스템", self.verify_notification_system),
            ("프로세스 관리", self.verify_process_management)
        ]
        
        all_passed = True
        passed_count = 0
        
        for test_name, test_func in verification_tests:
            self._print_colored(f"\n{'='*60}", 'CYAN')
            try:
                result = test_func()
                if result:
passed_count_+ =  1
                    self._print_colored(f"✅ {test_name} 검증 완료", 'GREEN')
                else:
                    all_passed = False
                    self._print_colored(f"❌ {test_name} 검증 실패", 'RED')
            except Exception as e:
                all_passed = False
                self._print_colored(f"❌ {test_name} 검증 오류: {str(e)}", 'RED')
                self.logger.error(f"{test_name} 검증 중 예외 발생: {str(e)}")
        
        # 결과 저장
with_open(self.results_file,_'w',_encoding = 'utf-8') as f:
            json.dump(self.verification_results, f, indent=2, ensure_ascii=False)
        
        # 최종 결과 출력
        self._print_colored(f"\n{'='*60}", 'CYAN')
        self._print_colored("📋 마이그레이션 후 검증 결과 요약", 'CYAN')
        self._print_colored(f"{'='*60}", 'CYAN')
        
        total_tests = len(verification_tests)
        self._print_colored(f"전체 테스트: {total_tests}개", 'BLUE')
        self._print_colored(f"통과: {passed_count}개", 'GREEN')
        self._print_colored(f"실패: {total_tests - passed_count}개", 'RED')
        
        if all_passed:
            self._print_colored("\n🎉 모든 검증 통과! 마이그레이션이 성공적으로 완료되었습니다.", 'GREEN')
        else:
            self._print_colored(f"\n❌ {total_tests - passed_count}개 검증 실패. 문제를 해결하거나 롤백을 고려하세요.", 'RED')
        
        self._print_colored(f"\n📄 상세 결과: {self.results_file}", 'BLUE')
        self._print_colored(f"📄 로그 파일: {self.log_file}", 'BLUE')
        
        return all_passed

def main():
    """메인 함수"""
    verification = PostMigrationVerification()
    success = verification.run_comprehensive_verification()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()