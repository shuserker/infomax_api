#!/usr/bin/env python3
"""
POSCO 시스템 파일 참조 검증 및 수정 도구

실제 문제가 되는 파일 참조만을 대상으로 합니다:
- 존재하지 않는 실제 파일 경로 참조
- 깨진 Python 모듈 import (로컬 모듈만)
- 실행 불가능한 스크립트 참조
"""

import os
import re
import json
import ast
import importlib.util
from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class FileReferenceIssue:
    """파일 참조 문제 정보"""
    source_file: str
    referenced_path: str
    line_number: int
    issue_type: str  # 'missing_file', 'broken_import', 'invalid_script'
    context: str
    severity: str  # 'high', 'medium', 'low'
    suggested_fix: Optional[str] = None

class FileReferenceValidator:
    """파일 참조 검증 클래스"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.issues: List[FileReferenceIssue] = []
        self.existing_files: Set[str] = set()
        self.python_modules: Dict[str, str] = {}
        
        # 제외할 패턴들
        self.exclude_patterns = [
            r'\*\.',  # 와일드카드 패턴
            r'\{.*\}',  # 템플릿 변수
            r'http[s]?://',  # URL
            r'file://',  # 파일 URL
            r'^\$',  # 환경 변수
        ]
        
        self._build_file_index()

    def _build_file_index(self):
        """파일 인덱스 구축"""
        logger.info("파일 인덱스 구축 중...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                relative_path = str(file_path.relative_to(self.root_path))
                self.existing_files.add(relative_path)
                
                # Python 모듈 매핑
                if file_path.suffix == '.py':
                    module_name = file_path.stem
                    self.python_modules[module_name] = relative_path

    def _should_exclude(self, reference: str) -> bool:
        """참조를 제외해야 하는지 확인"""
        for pattern in self.exclude_patterns:
            if re.search(pattern, reference):
                return True
        return False

    def validate_all_references(self) -> List[FileReferenceIssue]:
        """모든 파일 참조 검증"""
        logger.info("파일 참조 검증 시작...")
        
        # Python 파일 검증
        for py_file in self.root_path.rglob("*.py"):
            if not py_file.name.startswith('.'):
                self._validate_python_file(py_file)
        
        # 스크립트 파일 검증
        for script_ext in ['*.sh', '*.bat', '*.command']:
            for script_file in self.root_path.rglob(script_ext):
                if not script_file.name.startswith('.'):
                    self._validate_script_file(script_file)
        
        # 설정 파일 검증
        for config_file in self.root_path.rglob("*.json"):
            if not config_file.name.startswith('.'):
                self._validate_config_file(config_file)
        
        logger.info(f"총 {len(self.issues)}개의 파일 참조 문제 발견")
        return self.issues

    def _validate_python_file(self, file_path: Path):
        """Python 파일 검증"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # AST 파싱으로 import 문 추출
            try:
                tree = ast.parse(content)
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            self._check_import(alias.name, file_path, node.lineno)
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            self._check_import(node.module, file_path, node.lineno)
            except SyntaxError:
                # 구문 오류가 있는 파일은 건너뛰기
                pass
            
            # 파일 경로 참조 검사
            lines = content.split('\n')
            for line_num, line in enumerate(lines, 1):
                self._check_file_references_in_line(line, file_path, line_num)
                
        except Exception as e:
            logger.error(f"Python 파일 검증 오류 {file_path}: {e}")

    def _check_import(self, module_name: str, source_file: Path, line_num: int):
        """import 문 검증"""
        if not module_name or self._should_exclude(module_name):
            return
        
        # 표준 라이브러리 체크
        try:
            spec = importlib.util.find_spec(module_name)
            if spec is not None:
                return  # 유효한 모듈
        except (ImportError, ModuleNotFoundError, ValueError):
            pass
        
        # 로컬 모듈 체크
        base_module = module_name.split('.')[0]
        if base_module in self.python_modules:
            return  # 로컬 모듈 존재
        
        # 상대 경로로 파일 존재 체크
        module_path = module_name.replace('.', '/') + '.py'
        if module_path in self.existing_files:
            return
        
        # 패키지 체크
        package_init = module_name.replace('.', '/') + 'Monitoring/POSCO_News_250808/core/__init__.py'
        if package_init in self.existing_files:
            return
        
        # 깨진 import 발견
        issue = FileReferenceIssue(
            source_file=str(source_file.relative_to(self.root_path)),
            referenced_path=module_name,
            line_number=line_num,
            issue_type='broken_import',
            context=f"import {module_name}",
            severity='high',
            suggested_fix=self._suggest_import_fix(module_name)
        )
        self.issues.append(issue)

    def _check_file_references_in_line(self, line: str, source_file: Path, line_num: int):
        """라인에서 파일 참조 검사"""
        # 파일 경로 패턴들
        patterns = [
            r'[\'"]([^\'"\s]+\.(py|sh|bat|json|md|txt|log|command|html|css|js))[\'"]',
            r'Path\([\'"]([^\'"]+)[\'"]',
            r'open\([\'"]([^\'"]+)[\'"]'
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, line)
            for match in matches:
                file_ref = match.group(1)
                if self._should_exclude(file_ref):
                    continue
                
                if not self._file_exists(file_ref, source_file):
                    issue = FileReferenceIssue(
                        source_file=str(source_file.relative_to(self.root_path)),
                        referenced_path=file_ref,
                        line_number=line_num,
                        issue_type='missing_file',
                        context=line.strip(),
                        severity='medium',
                        suggested_fix=self._suggest_file_fix(file_ref)
                    )
                    self.issues.append(issue)

    def _validate_script_file(self, file_path: Path):
        """스크립트 파일 검증"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # 스크립트 실행 패턴
                patterns = [
                    r'python3?\s+([^\s]+\.py)',
                    r'bash\s+([^\s]+\.sh)',
                    r'\.\/([^\s]+\.(sh|command|bat))'
                ]
                
                for pattern in patterns:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        script_ref = match.group(1)
                        if not self._file_exists(script_ref, file_path):
                            issue = FileReferenceIssue(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=script_ref,
                                line_number=line_num,
                                issue_type='invalid_script',
                                context=line.strip(),
                                severity='high',
                                suggested_fix=self._suggest_file_fix(script_ref)
                            )
                            self.issues.append(issue)
                            
        except Exception as e:
            logger.error(f"스크립트 파일 검증 오류 {file_path}: {e}")

    def _validate_config_file(self, file_path: Path):
        """설정 파일 검증"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # JSON 파일에서 파일 경로 찾기
            file_patterns = re.findall(r'"([^"]+\.(py|sh|bat|json|md|txt|log))"', content)
            
            for file_ref, ext in file_patterns:
                if self._should_exclude(file_ref):
                    continue
                
                if not self._file_exists(file_ref, file_path):
                    # 라인 번호 찾기
                    lines = content.split('\n')
                    line_num = 1
                    for i, line in enumerate(lines, 1):
                        if file_ref in line:
                            line_num = i
                            break
                    
                    issue = FileReferenceIssue(
                        source_file=str(file_path.relative_to(self.root_path)),
                        referenced_path=file_ref,
                        line_number=line_num,
                        issue_type='missing_file',
                        context=f"Config reference: {file_ref}",
                        severity='medium',
                        suggested_fix=self._suggest_file_fix(file_ref)
                    )
                    self.issues.append(issue)
                    
        except Exception as e:
            logger.error(f"설정 파일 검증 오류 {file_path}: {e}")

    def _file_exists(self, file_ref: str, source_file: Path) -> bool:
        """파일이 존재하는지 확인"""
        # 절대 경로
        if os.path.isabs(file_ref):
            return Path(file_ref).exists()
        
        # 상대 경로 (소스 파일 기준)
        source_dir = source_file.parent
        relative_path = source_dir / file_ref
        if relative_path.exists():
            return True
        
        # 루트 기준 경로
        root_path = self.root_path / file_ref
        if root_path.exists():
            return True
        
        # 파일 인덱스에서 확인
        return file_ref in self.existing_files

    def _suggest_import_fix(self, module_name: str) -> Optional[str]:
        """import 수정 제안"""
        base_module = module_name.split('.')[0]
        
        # 유사한 모듈명 찾기
        for existing_module in self.python_modules.keys():
            if (existing_module.lower() == base_module.lower() or
                base_module.lower() in existing_module.lower() or
                existing_module.lower() in base_module.lower()):
                return existing_module
        
        return None

    def _suggest_file_fix(self, file_ref: str) -> Optional[str]:
        """파일 경로 수정 제안"""
        filename = Path(file_ref).name
        
        # 정확한 파일명 매칭
        for existing_file in self.existing_files:
            if Path(existing_file).name == filename:
                return existing_file
        
        # 유사한 파일명 찾기
        for existing_file in self.existing_files:
            existing_name = Path(existing_file).name.lower()
            if (filename.lower() in existing_name or
                existing_name in filename.lower()):
                return existing_file
        
        return None

    def generate_report(self) -> Dict:
        """검증 보고서 생성"""
        high_severity = [i for i in self.issues if i.severity == 'high']
        medium_severity = [i for i in self.issues if i.severity == 'medium']
        low_severity = [i for i in self.issues if i.severity == 'low']
        
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_issues": len(self.issues),
                "high_severity": len(high_severity),
                "medium_severity": len(medium_severity),
                "low_severity": len(low_severity),
                "issues_by_type": {
                    "broken_import": len([i for i in self.issues if i.issue_type == 'broken_import']),
                    "missing_file": len([i for i in self.issues if i.issue_type == 'missing_file']),
                    "invalid_script": len([i for i in self.issues if i.issue_type == 'invalid_script'])
                }
            },
            "issues": [
                {
                    "source_file": issue.source_file,
                    "referenced_path": issue.referenced_path,
                    "line_number": issue.line_number,
                    "issue_type": issue.issue_type,
                    "context": issue.context,
                    "severity": issue.severity,
                    "suggested_fix": issue.suggested_fix
                }
                for issue in sorted(self.issues, key=lambda x: (x.severity, x.source_file))
            ]
        }
        
        return report

    def _get_timestamp(self) -> str:
        """타임스탬프 생성"""
        from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def save_report(self, report: Dict, filename: str = "file_reference_validation_report.json"):
        """보고서 저장"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"보고서 저장: {filename}")

def main():
    """메인 실행 함수"""
    print("🔍 POSCO 시스템 파일 참조 검증 도구")
    print("=" * 50)
    
    validator = FileReferenceValidator()
    
    # 파일 참조 검증
    print("\n1️⃣ 파일 참조 검증 중...")
    issues = validator.validate_all_references()
    
    if issues:
        print(f"   ⚠️  {len(issues)}개의 파일 참조 문제 발견")
        
        # 보고서 생성
        print("\n2️⃣ 검증 보고서 생성 중...")
        report = validator.generate_report()
        validator.save_report(report)
        print("   ✅ 보고서 생성 완료")
        
        # 결과 요약
        print(f"\n📊 검증 결과 요약:")
        print(f"   • 총 문제: {len(issues)}개")
        print(f"     - 높은 심각도: {report['summary']['high_severity']}개")
        print(f"     - 중간 심각도: {report['summary']['medium_severity']}개")
        print(f"     - 낮은 심각도: {report['summary']['low_severity']}개")
        print(f"   • 문제 유형별:")
        print(f"     - 깨진 import: {report['summary']['issues_by_type']['broken_import']}개")
        print(f"     - 누락된 파일: {report['summary']['issues_by_type']['missing_file']}개")
        print(f"     - 잘못된 스크립트: {report['summary']['issues_by_type']['invalid_script']}개")
        
        # 주요 문제들 표시
        high_issues = [i for i in issues if i.severity == 'high']
        if high_issues:
            print(f"\n🚨 주요 문제들 (상위 10개):")
            for issue in high_issues[:10]:
                print(f"   • {issue.source_file}:{issue.line_number} - {issue.referenced_path}")
                if issue.suggested_fix:
                    print(f"     제안: {issue.suggested_fix}")
    else:
        print("   ✅ 파일 참조 문제가 발견되지 않았습니다!")
    
    return len(issues) == 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)