#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ê²€ì¦ ë° ìˆ˜ì • ë„êµ¬

ì‹¤ì œ ë¬¸ì œê°€ ë˜ëŠ” íŒŒì¼ ì°¸ì¡°ë§Œì„ ëŒ€ìƒìœ¼ë¡œ í•©ë‹ˆë‹¤:
- ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì°¸ì¡°
- ê¹¨ì§„ Python ëª¨ë“ˆ import (ë¡œì»¬ ëª¨ë“ˆë§Œ)
- ì‹¤í–‰ ë¶ˆê°€ëŠ¥í•œ ìŠ¤í¬ë¦½íŠ¸ ì°¸ì¡°
"""

import os
import re
import json
import ast
import importlib.util
from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class FileReferenceIssue:
    """íŒŒì¼ ì°¸ì¡° ë¬¸ì œ ì •ë³´"""
    source_file: str
    referenced_path: str
    line_number: int
    issue_type: str  # 'missing_file', 'broken_import', 'invalid_script'
    context: str
    severity: str  # 'high', 'medium', 'low'
    suggested_fix: Optional[str] = None

class FileReferenceValidator:
    """íŒŒì¼ ì°¸ì¡° ê²€ì¦ í´ë˜ìŠ¤"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.issues: List[FileReferenceIssue] = []
        self.existing_files: Set[str] = set()
        self.python_modules: Dict[str, str] = {}
        
        # ì œì™¸í•  íŒ¨í„´ë“¤
        self.exclude_patterns = [
            r'\*\.',  # ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´
            r'\{.*\}',  # í…œí”Œë¦¿ ë³€ìˆ˜
            r'http[s]?://',  # URL
            r'file://',  # íŒŒì¼ URL
            r'^\$',  # í™˜ê²½ ë³€ìˆ˜
        ]
        
        self._build_file_index()

    def _build_file_index(self):
        """íŒŒì¼ ì¸ë±ìŠ¤ êµ¬ì¶•"""
        logger.info("íŒŒì¼ ì¸ë±ìŠ¤ êµ¬ì¶• ì¤‘...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                relative_path = str(file_path.relative_to(self.root_path))
                self.existing_files.add(relative_path)
                
                # Python ëª¨ë“ˆ ë§¤í•‘
                if file_path.suffix == '.py':
                    module_name = file_path.stem
                    self.python_modules[module_name] = relative_path

    def _should_exclude(self, reference: str) -> bool:
        """ì°¸ì¡°ë¥¼ ì œì™¸í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸"""
        for pattern in self.exclude_patterns:
            if re.search(pattern, reference):
                return True
        return False

    def validate_all_references(self) -> List[FileReferenceIssue]:
        """ëª¨ë“  íŒŒì¼ ì°¸ì¡° ê²€ì¦"""
        logger.info("íŒŒì¼ ì°¸ì¡° ê²€ì¦ ì‹œì‘...")
        
        # Python íŒŒì¼ ê²€ì¦
        for py_file in self.root_path.rglob("*.py"):
            if not py_file.name.startswith('.'):
                self._validate_python_file(py_file)
        
        # ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ê²€ì¦
        for script_ext in ['*.sh', '*.bat', '*.command']:
            for script_file in self.root_path.rglob(script_ext):
                if not script_file.name.startswith('.'):
                    self._validate_script_file(script_file)
        
        # ì„¤ì • íŒŒì¼ ê²€ì¦
        for config_file in self.root_path.rglob("*.json"):
            if not config_file.name.startswith('.'):
                self._validate_config_file(config_file)
        
        logger.info(f"ì´ {len(self.issues)}ê°œì˜ íŒŒì¼ ì°¸ì¡° ë¬¸ì œ ë°œê²¬")
        return self.issues

    def _validate_python_file(self, file_path: Path):
        """Python íŒŒì¼ ê²€ì¦"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # AST íŒŒì‹±ìœ¼ë¡œ import ë¬¸ ì¶”ì¶œ
            try:
                tree = ast.parse(content)
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            self._check_import(alias.name, file_path, node.lineno)
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            self._check_import(node.module, file_path, node.lineno)
            except SyntaxError:
                # êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ìˆëŠ” íŒŒì¼ì€ ê±´ë„ˆë›°ê¸°
                pass
            
            # íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ê²€ì‚¬
            lines = content.split('\n')
            for line_num, line in enumerate(lines, 1):
                self._check_file_references_in_line(line, file_path, line_num)
                
        except Exception as e:
            logger.error(f"Python íŒŒì¼ ê²€ì¦ ì˜¤ë¥˜ {file_path}: {e}")

    def _check_import(self, module_name: str, source_file: Path, line_num: int):
        """import ë¬¸ ê²€ì¦"""
        if not module_name or self._should_exclude(module_name):
            return
        
        # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì²´í¬
        try:
            spec = importlib.util.find_spec(module_name)
            if spec is not None:
                return  # ìœ íš¨í•œ ëª¨ë“ˆ
        except (ImportError, ModuleNotFoundError, ValueError):
            pass
        
        # ë¡œì»¬ ëª¨ë“ˆ ì²´í¬
        base_module = module_name.split('.')[0]
        if base_module in self.python_modules:
            return  # ë¡œì»¬ ëª¨ë“ˆ ì¡´ì¬
        
        # ìƒëŒ€ ê²½ë¡œë¡œ íŒŒì¼ ì¡´ì¬ ì²´í¬
        module_path = module_name.replace('.', '/') + '.py'
        if module_path in self.existing_files:
            return
        
        # íŒ¨í‚¤ì§€ ì²´í¬
        package_init = module_name.replace('.', '/') + 'Monitoring/POSCO_News_250808/core/__init__.py'
        if package_init in self.existing_files:
            return
        
        # ê¹¨ì§„ import ë°œê²¬
        issue = FileReferenceIssue(
            source_file=str(source_file.relative_to(self.root_path)),
            referenced_path=module_name,
            line_number=line_num,
            issue_type='broken_import',
            context=f"import {module_name}",
            severity='high',
            suggested_fix=self._suggest_import_fix(module_name)
        )
        self.issues.append(issue)

    def _check_file_references_in_line(self, line: str, source_file: Path, line_num: int):
        """ë¼ì¸ì—ì„œ íŒŒì¼ ì°¸ì¡° ê²€ì‚¬"""
        # íŒŒì¼ ê²½ë¡œ íŒ¨í„´ë“¤
        patterns = [
            r'[\'"]([^\'"\s]+\.(py|sh|bat|json|md|txt|log|command|html|css|js))[\'"]',
            r'Path\([\'"]([^\'"]+)[\'"]',
            r'open\([\'"]([^\'"]+)[\'"]'
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, line)
            for match in matches:
                file_ref = match.group(1)
                if self._should_exclude(file_ref):
                    continue
                
                if not self._file_exists(file_ref, source_file):
                    issue = FileReferenceIssue(
                        source_file=str(source_file.relative_to(self.root_path)),
                        referenced_path=file_ref,
                        line_number=line_num,
                        issue_type='missing_file',
                        context=line.strip(),
                        severity='medium',
                        suggested_fix=self._suggest_file_fix(file_ref)
                    )
                    self.issues.append(issue)

    def _validate_script_file(self, file_path: Path):
        """ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ê²€ì¦"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ íŒ¨í„´
                patterns = [
                    r'python3?\s+([^\s]+\.py)',
                    r'bash\s+([^\s]+\.sh)',
                    r'\.\/([^\s]+\.(sh|command|bat))'
                ]
                
                for pattern in patterns:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        script_ref = match.group(1)
                        if not self._file_exists(script_ref, file_path):
                            issue = FileReferenceIssue(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=script_ref,
                                line_number=line_num,
                                issue_type='invalid_script',
                                context=line.strip(),
                                severity='high',
                                suggested_fix=self._suggest_file_fix(script_ref)
                            )
                            self.issues.append(issue)
                            
        except Exception as e:
            logger.error(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ê²€ì¦ ì˜¤ë¥˜ {file_path}: {e}")

    def _validate_config_file(self, file_path: Path):
        """ì„¤ì • íŒŒì¼ ê²€ì¦"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # JSON íŒŒì¼ì—ì„œ íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
            file_patterns = re.findall(r'"([^"]+\.(py|sh|bat|json|md|txt|log))"', content)
            
            for file_ref, ext in file_patterns:
                if self._should_exclude(file_ref):
                    continue
                
                if not self._file_exists(file_ref, file_path):
                    # ë¼ì¸ ë²ˆí˜¸ ì°¾ê¸°
                    lines = content.split('\n')
                    line_num = 1
                    for i, line in enumerate(lines, 1):
                        if file_ref in line:
                            line_num = i
                            break
                    
                    issue = FileReferenceIssue(
                        source_file=str(file_path.relative_to(self.root_path)),
                        referenced_path=file_ref,
                        line_number=line_num,
                        issue_type='missing_file',
                        context=f"Config reference: {file_ref}",
                        severity='medium',
                        suggested_fix=self._suggest_file_fix(file_ref)
                    )
                    self.issues.append(issue)
                    
        except Exception as e:
            logger.error(f"ì„¤ì • íŒŒì¼ ê²€ì¦ ì˜¤ë¥˜ {file_path}: {e}")

    def _file_exists(self, file_ref: str, source_file: Path) -> bool:
        """íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
        # ì ˆëŒ€ ê²½ë¡œ
        if os.path.isabs(file_ref):
            return Path(file_ref).exists()
        
        # ìƒëŒ€ ê²½ë¡œ (ì†ŒìŠ¤ íŒŒì¼ ê¸°ì¤€)
        source_dir = source_file.parent
        relative_path = source_dir / file_ref
        if relative_path.exists():
            return True
        
        # ë£¨íŠ¸ ê¸°ì¤€ ê²½ë¡œ
        root_path = self.root_path / file_ref
        if root_path.exists():
            return True
        
        # íŒŒì¼ ì¸ë±ìŠ¤ì—ì„œ í™•ì¸
        return file_ref in self.existing_files

    def _suggest_import_fix(self, module_name: str) -> Optional[str]:
        """import ìˆ˜ì • ì œì•ˆ"""
        base_module = module_name.split('.')[0]
        
        # ìœ ì‚¬í•œ ëª¨ë“ˆëª… ì°¾ê¸°
        for existing_module in self.python_modules.keys():
            if (existing_module.lower() == base_module.lower() or
                base_module.lower() in existing_module.lower() or
                existing_module.lower() in base_module.lower()):
                return existing_module
        
        return None

    def _suggest_file_fix(self, file_ref: str) -> Optional[str]:
        """íŒŒì¼ ê²½ë¡œ ìˆ˜ì • ì œì•ˆ"""
        filename = Path(file_ref).name
        
        # ì •í™•í•œ íŒŒì¼ëª… ë§¤ì¹­
        for existing_file in self.existing_files:
            if Path(existing_file).name == filename:
                return existing_file
        
        # ìœ ì‚¬í•œ íŒŒì¼ëª… ì°¾ê¸°
        for existing_file in self.existing_files:
            existing_name = Path(existing_file).name.lower()
            if (filename.lower() in existing_name or
                existing_name in filename.lower()):
                return existing_file
        
        return None

    def generate_report(self) -> Dict:
        """ê²€ì¦ ë³´ê³ ì„œ ìƒì„±"""
        high_severity = [i for i in self.issues if i.severity == 'high']
        medium_severity = [i for i in self.issues if i.severity == 'medium']
        low_severity = [i for i in self.issues if i.severity == 'low']
        
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_issues": len(self.issues),
                "high_severity": len(high_severity),
                "medium_severity": len(medium_severity),
                "low_severity": len(low_severity),
                "issues_by_type": {
                    "broken_import": len([i for i in self.issues if i.issue_type == 'broken_import']),
                    "missing_file": len([i for i in self.issues if i.issue_type == 'missing_file']),
                    "invalid_script": len([i for i in self.issues if i.issue_type == 'invalid_script'])
                }
            },
            "issues": [
                {
                    "source_file": issue.source_file,
                    "referenced_path": issue.referenced_path,
                    "line_number": issue.line_number,
                    "issue_type": issue.issue_type,
                    "context": issue.context,
                    "severity": issue.severity,
                    "suggested_fix": issue.suggested_fix
                }
                for issue in sorted(self.issues, key=lambda x: (x.severity, x.source_file))
            ]
        }
        
        return report

    def _get_timestamp(self) -> str:
        """íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±"""
        from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def save_report(self, report: Dict, filename: str = "file_reference_validation_report.json"):
        """ë³´ê³ ì„œ ì €ì¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"ë³´ê³ ì„œ ì €ì¥: {filename}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ” POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ê²€ì¦ ë„êµ¬")
    print("=" * 50)
    
    validator = FileReferenceValidator()
    
    # íŒŒì¼ ì°¸ì¡° ê²€ì¦
    print("\n1ï¸âƒ£ íŒŒì¼ ì°¸ì¡° ê²€ì¦ ì¤‘...")
    issues = validator.validate_all_references()
    
    if issues:
        print(f"   âš ï¸  {len(issues)}ê°œì˜ íŒŒì¼ ì°¸ì¡° ë¬¸ì œ ë°œê²¬")
        
        # ë³´ê³ ì„œ ìƒì„±
        print("\n2ï¸âƒ£ ê²€ì¦ ë³´ê³ ì„œ ìƒì„± ì¤‘...")
        report = validator.generate_report()
        validator.save_report(report)
        print("   âœ… ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ")
        
        # ê²°ê³¼ ìš”ì•½
        print(f"\nğŸ“Š ê²€ì¦ ê²°ê³¼ ìš”ì•½:")
        print(f"   â€¢ ì´ ë¬¸ì œ: {len(issues)}ê°œ")
        print(f"     - ë†’ì€ ì‹¬ê°ë„: {report['summary']['high_severity']}ê°œ")
        print(f"     - ì¤‘ê°„ ì‹¬ê°ë„: {report['summary']['medium_severity']}ê°œ")
        print(f"     - ë‚®ì€ ì‹¬ê°ë„: {report['summary']['low_severity']}ê°œ")
        print(f"   â€¢ ë¬¸ì œ ìœ í˜•ë³„:")
        print(f"     - ê¹¨ì§„ import: {report['summary']['issues_by_type']['broken_import']}ê°œ")
        print(f"     - ëˆ„ë½ëœ íŒŒì¼: {report['summary']['issues_by_type']['missing_file']}ê°œ")
        print(f"     - ì˜ëª»ëœ ìŠ¤í¬ë¦½íŠ¸: {report['summary']['issues_by_type']['invalid_script']}ê°œ")
        
        # ì£¼ìš” ë¬¸ì œë“¤ í‘œì‹œ
        high_issues = [i for i in issues if i.severity == 'high']
        if high_issues:
            print(f"\nğŸš¨ ì£¼ìš” ë¬¸ì œë“¤ (ìƒìœ„ 10ê°œ):")
            for issue in high_issues[:10]:
                print(f"   â€¢ {issue.source_file}:{issue.line_number} - {issue.referenced_path}")
                if issue.suggested_fix:
                    print(f"     ì œì•ˆ: {issue.suggested_fix}")
    else:
        print("   âœ… íŒŒì¼ ì°¸ì¡° ë¬¸ì œê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")
    
    return len(issues) == 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)