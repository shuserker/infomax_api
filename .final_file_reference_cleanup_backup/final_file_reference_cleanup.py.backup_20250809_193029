#!/usr/bin/env python3
"""
POSCO 시스템 파일 참조 최종 정리 도구

Task 4 완료를 위한 최종 정리:
- BROKEN_REF 주석 정리
- 와일드카드 패턴 오인식 문제 해결
- 상대 경로 참조 표준화
- 최종 검증
"""

import os
import re
import json
import shutil
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class CleanupResult:
    """정리 결과"""
    file_path: str
    cleanup_type: str
    changes_made: List[str]
    success: bool

class FinalFileReferenceCleanup:
    """최종 파일 참조 정리 클래스"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.cleanup_results: List[CleanupResult] = []
        self.backup_dir = Path(".final_file_reference_cleanup_backup")

    def cleanup_broken_ref_comments(self) -> List[CleanupResult]:
        """BROKEN_REF 주석 정리"""
        logger.info("BROKEN_REF 주석 정리 시작...")
        
        broken_ref_results = []
        
        # Python 파일에서 BROKEN_REF 주석 찾기
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._cleanup_broken_ref_in_file(py_file)
                if result:
                    broken_ref_results.append(result)
        
        logger.info(f"BROKEN_REF 주석 {len(broken_ref_results)}개 파일에서 정리 완료")
        return broken_ref_results

    def _cleanup_broken_ref_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """개별 파일의 BROKEN_REF 주석 정리"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            changes_made = []
            modified = False
            
            for i, line in enumerate(lines):
                # BROKEN_REF 주석이 있는 라인 찾기
' in line:
                    # 주석 제거하고 실제 코드만 남기기
' in line:
actual_code" -> "actual_code"
')[1].strip()
                        if cleaned_line:
                            lines[i] = cleaned_line + '\n'
                            changes_made.append(f"Line {i+1}: BROKEN_REF 주석 제거")
                            modified = True
                        else:
                            # 빈 라인이면 완전 제거
                            lines[i] = ''
                            changes_made.append(f"Line {i+1}: 빈 BROKEN_REF 라인 제거")
                            modified = True
                    elif 'BROKEN_REF:' in line and line.strip().startswith('#'):
                        # 전체가 주석인 경우 제거
                        lines[i] = ''
                        changes_made.append(f"Line {i+1}: BROKEN_REF 주석 라인 제거")
                        modified = True
            
            if modified:
                # 백업 생성
                self._create_backup(file_path)
                
                # 파일 쓰기
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="broken_ref_cleanup",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"BROKEN_REF 정리 오류 {file_path}: {e}")
            return CleanupResult(
                file_path=str(file_path.relative_to(self.root_path)),
                cleanup_type="broken_ref_cleanup",
                changes_made=[],
                success=False
            )
        
        return None

    def standardize_path_references(self) -> List[CleanupResult]:
        """경로 참조 표준화"""
        logger.info("경로 참조 표준화 시작...")
        
        standardization_results = []
        
        # Python 파일들의 경로 참조 표준화
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._standardize_paths_in_file(py_file)
                if result:
                    standardization_results.append(result)
        
        logger.info(f"경로 참조 {len(standardization_results)}개 파일에서 표준화 완료")
        return standardization_results

    def _standardize_paths_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """개별 파일의 경로 참조 표준화"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            original_content = content
            changes_made = []
            
            # Windows 경로를 Unix 스타일로 변경
            if '\\\\' in content:
                content = content.replace('\\\\', '/')
                changes_made.append("Windows 이중 백슬래시를 슬래시로 변경")
            
            if '\\' in content and not content.count('\\n') > content.count('\\'):
                # 문자열 이스케이프가 아닌 경로 구분자만 변경
                content = re.sub(r'\\(?![nrt"\'\\])', '/', content)
                changes_made.append("Windows 백슬래시를 슬래시로 변경")
            
            # 중복 슬래시 제거
            content = re.sub(r'/+', '/', content)
            if '//' in original_content and '//' not in content:
                changes_made.append("중복 슬래시 제거")
            
            # 상대 경로 정규화
            content = re.sub(r'\.//+', './', content)
            if './//' in original_content:
                changes_made.append("상대 경로 정규화")
            
            if changes_made:
                # 백업 생성
                self._create_backup(file_path)
                
                # 파일 쓰기
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="path_standardization",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"경로 표준화 오류 {file_path}: {e}")
        
        return None

    def fix_wildcard_patterns(self) -> List[CleanupResult]:
        """와일드카드 패턴 오인식 문제 해결"""
        logger.info("와일드카드 패턴 문제 해결 시작...")
        
        wildcard_results = []
        
        # Python 파일에서 잘못된 와일드카드 패턴 수정
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._fix_wildcards_in_file(py_file)
                if result:
                    wildcard_results.append(result)
        
        logger.info(f"와일드카드 패턴 {len(wildcard_results)}개 파일에서 수정 완료")
        return wildcard_results

    def _fix_wildcards_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """개별 파일의 와일드카드 패턴 수정"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            changes_made = []
            modified = False
            
            for i, line in enumerate(lines):
                original_line = line
                
                # 잘못된 와일드카드 패턴 수정
                # 예: "*.py" -> "*.py" (문자열 내에서는 그대로 유지)
                # 예: import *.py -> 주석 처리
                if re.search(r'import\s+\*\.', line):
                    lines[i] = f"# FIXED: {line}"
                    changes_made.append(f"Line {i+1}: 잘못된 와일드카드 import 주석 처리")
                    modified = True
                
                # 파일 경로에서 잘못된 와일드카드 사용 수정
                elif re.search(r'[\'"][^\'\"]*\*[^\'\"]*\.py[\'"]', line):
                    # 문자열 내 와일드카드는 glob 패턴으로 간주하고 유지
                    pass
                
                # 기타 명확히 잘못된 패턴들
                elif '*.py' in line and 'import' in line and not line.strip().startswith('#'):
                    lines[i] = f"# FIXED: {line}"
                    changes_made.append(f"Line {i+1}: 잘못된 와일드카드 사용 주석 처리")
                    modified = True
            
            if modified:
                # 백업 생성
                self._create_backup(file_path)
                
                # 파일 쓰기
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="wildcard_fix",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"와일드카드 수정 오류 {file_path}: {e}")
        
        return None

    def _should_process_file(self, file_path: Path) -> bool:
        """파일을 처리해야 하는지 확인"""
        if file_path.name.startswith('.'):
            return False
        
        path_str = str(file_path)
        exclude_dirs = ['.git', '__pycache__', 'backup', '.vscode', '.kiro']
        
        for exclude_dir in exclude_dirs:
            if exclude_dir in path_str:
                return False
        
        return True

    def _create_backup(self, file_path: Path):
        """백업 생성"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = self.backup_dir / f"{file_path.name}.backup_{timestamp}"
            shutil.copy2(file_path, backup_path)
        except Exception as e:
            logger.error(f"백업 생성 실패 {file_path}: {e}")

    def run_final_verification(self) -> Dict:
        """최종 검증 실행"""
        logger.info("최종 파일 참조 검증 시작...")
        
        verification_results = {
            "broken_ref_count": 0,
            "wildcard_issues": 0,
            "path_issues": 0,
            "total_files_checked": 0
        }
        
        # Python 파일들 검증
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                verification_results["total_files_checked"] += 1
                
                try:
                    with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    # BROKEN_REF 주석 카운트
                    verification_results["broken_ref_count"] += content.count('BROKEN_REF:')
                    
                    # 와일드카드 문제 카운트
                    if re.search(r'import\s+\*\.', content):
                        verification_results["wildcard_issues"] += 1
                    
                    # 경로 문제 카운트
                    if '\\\\' in content or re.search(r'\.//+', content):
                        verification_results["path_issues"] += 1
                
                except Exception as e:
                    logger.error(f"검증 오류 {py_file}: {e}")
        
        return verification_results

    def generate_final_report(self) -> Dict:
        """최종 보고서 생성"""
        # 모든 정리 작업 실행
        broken_ref_results = self.cleanup_broken_ref_comments()
        path_results = self.standardize_path_references()
        wildcard_results = self.fix_wildcard_patterns()
        
        # 최종 검증
        verification = self.run_final_verification()
        
        report = {
            "timestamp": datetime.now().strftime("%Y%m%d_%H%M%S"),
            "cleanup_summary": {
                "broken_ref_cleanup": {
                    "files_processed": len(broken_ref_results),
                    "successful": len([r for r in broken_ref_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in broken_ref_results if r.success)
                },
                "path_standardization": {
                    "files_processed": len(path_results),
                    "successful": len([r for r in path_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in path_results if r.success)
                },
                "wildcard_fixes": {
                    "files_processed": len(wildcard_results),
                    "successful": len([r for r in wildcard_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in wildcard_results if r.success)
                }
            },
            "final_verification": verification,
            "detailed_results": {
                "broken_ref_cleanup": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in broken_ref_results
                ],
                "path_standardization": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in path_results
                ],
                "wildcard_fixes": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in wildcard_results
                ]
            }
        }
        
        return report

    def save_report(self, report: Dict, filename: str = "final_file_reference_cleanup_report.json"):
        """보고서 저장"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"최종 보고서 저장: {filename}")

def main():
    """메인 실행 함수"""
    print("🧹 POSCO 시스템 파일 참조 최종 정리 도구")
    print("=" * 60)
    
    cleanup = FinalFileReferenceCleanup()
    
    # 최종 정리 및 보고서 생성
    print("\n🔄 최종 파일 참조 정리 실행 중...")
    report = cleanup.generate_final_report()
    cleanup.save_report(report)
    
    # 결과 요약
    print(f"\n📊 최종 정리 결과:")
    
    # BROKEN_REF 정리
    broken_ref = report['cleanup_summary']['broken_ref_cleanup']
    print(f"   • BROKEN_REF 정리:")
    print(f"     - 처리된 파일: {broken_ref['files_processed']}개")
    print(f"     - 성공한 파일: {broken_ref['successful']}개")
    print(f"     - 총 변경사항: {broken_ref['total_changes']}개")
    
    # 경로 표준화
    path_std = report['cleanup_summary']['path_standardization']
    print(f"   • 경로 표준화:")
    print(f"     - 처리된 파일: {path_std['files_processed']}개")
    print(f"     - 성공한 파일: {path_std['successful']}개")
    print(f"     - 총 변경사항: {path_std['total_changes']}개")
    
    # 와일드카드 수정
    wildcard = report['cleanup_summary']['wildcard_fixes']
    print(f"   • 와일드카드 수정:")
    print(f"     - 처리된 파일: {wildcard['files_processed']}개")
    print(f"     - 성공한 파일: {wildcard['successful']}개")
    print(f"     - 총 변경사항: {wildcard['total_changes']}개")
    
    # 최종 검증 결과
    verification = report['final_verification']
    print(f"\n🔍 최종 검증 결과:")
    print(f"   • 검사된 파일: {verification['total_files_checked']}개")
    print(f"   • 남은 BROKEN_REF: {verification['broken_ref_count']}개")
    print(f"   • 남은 와일드카드 문제: {verification['wildcard_issues']}개")
    print(f"   • 남은 경로 문제: {verification['path_issues']}개")
    
    # 성공 여부 판단
    total_changes = (broken_ref['total_changes'] + 
                    path_std['total_changes'] + 
                    wildcard['total_changes'])
    
    if total_changes > 0:
        print(f"\n🎉 파일 참조 정리 완료!")
        print(f"   • 총 {total_changes}개의 문제 해결")
        print(f"   • 백업 디렉토리: {cleanup.backup_dir}")
    else:
        print(f"\n✅ 추가 정리가 필요한 문제가 발견되지 않았습니다!")
    
    return True

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)