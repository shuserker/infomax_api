#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ìµœì¢… ì •ë¦¬ ë„êµ¬

Task 4 ì™„ë£Œë¥¼ ìœ„í•œ ìµœì¢… ì •ë¦¬:
- BROKEN_REF ì£¼ì„ ì •ë¦¬
- ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì˜¤ì¸ì‹ ë¬¸ì œ í•´ê²°
- ìƒëŒ€ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”
- ìµœì¢… ê²€ì¦
"""

import os
import re
import json
import shutil
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class CleanupResult:
    """ì •ë¦¬ ê²°ê³¼"""
    file_path: str
    cleanup_type: str
    changes_made: List[str]
    success: bool

class FinalFileReferenceCleanup:
    """ìµœì¢… íŒŒì¼ ì°¸ì¡° ì •ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.cleanup_results: List[CleanupResult] = []
        self.backup_dir = Path(".final_file_reference_cleanup_backup")

    def cleanup_broken_ref_comments(self) -> List[CleanupResult]:
        """BROKEN_REF ì£¼ì„ ì •ë¦¬"""
        logger.info("BROKEN_REF ì£¼ì„ ì •ë¦¬ ì‹œì‘...")
        
        broken_ref_results = []
        
        # Python íŒŒì¼ì—ì„œ BROKEN_REF ì£¼ì„ ì°¾ê¸°
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._cleanup_broken_ref_in_file(py_file)
                if result:
                    broken_ref_results.append(result)
        
        logger.info(f"BROKEN_REF ì£¼ì„ {len(broken_ref_results)}ê°œ íŒŒì¼ì—ì„œ ì •ë¦¬ ì™„ë£Œ")
        return broken_ref_results

    def _cleanup_broken_ref_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """ê°œë³„ íŒŒì¼ì˜ BROKEN_REF ì£¼ì„ ì •ë¦¬"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            changes_made = []
            modified = False
            
            for i, line in enumerate(lines):
                # BROKEN_REF ì£¼ì„ì´ ìˆëŠ” ë¼ì¸ ì°¾ê¸°
' in line:
                    # ì£¼ì„ ì œê±°í•˜ê³  ì‹¤ì œ ì½”ë“œë§Œ ë‚¨ê¸°ê¸°
' in line:
actual_code" -> "actual_code"
')[1].strip()
                        if cleaned_line:
                            lines[i] = cleaned_line + '\n'
                            changes_made.append(f"Line {i+1}: BROKEN_REF ì£¼ì„ ì œê±°")
                            modified = True
                        else:
                            # ë¹ˆ ë¼ì¸ì´ë©´ ì™„ì „ ì œê±°
                            lines[i] = ''
                            changes_made.append(f"Line {i+1}: ë¹ˆ BROKEN_REF ë¼ì¸ ì œê±°")
                            modified = True
                    elif 'BROKEN_REF:' in line and line.strip().startswith('#'):
                        # ì „ì²´ê°€ ì£¼ì„ì¸ ê²½ìš° ì œê±°
                        lines[i] = ''
                        changes_made.append(f"Line {i+1}: BROKEN_REF ì£¼ì„ ë¼ì¸ ì œê±°")
                        modified = True
            
            if modified:
                # ë°±ì—… ìƒì„±
                self._create_backup(file_path)
                
                # íŒŒì¼ ì“°ê¸°
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="broken_ref_cleanup",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"BROKEN_REF ì •ë¦¬ ì˜¤ë¥˜ {file_path}: {e}")
            return CleanupResult(
                file_path=str(file_path.relative_to(self.root_path)),
                cleanup_type="broken_ref_cleanup",
                changes_made=[],
                success=False
            )
        
        return None

    def standardize_path_references(self) -> List[CleanupResult]:
        """ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”"""
        logger.info("ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™” ì‹œì‘...")
        
        standardization_results = []
        
        # Python íŒŒì¼ë“¤ì˜ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._standardize_paths_in_file(py_file)
                if result:
                    standardization_results.append(result)
        
        logger.info(f"ê²½ë¡œ ì°¸ì¡° {len(standardization_results)}ê°œ íŒŒì¼ì—ì„œ í‘œì¤€í™” ì™„ë£Œ")
        return standardization_results

    def _standardize_paths_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """ê°œë³„ íŒŒì¼ì˜ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            original_content = content
            changes_made = []
            
            # Windows ê²½ë¡œë¥¼ Unix ìŠ¤íƒ€ì¼ë¡œ ë³€ê²½
            if '\\\\' in content:
                content = content.replace('\\\\', '/')
                changes_made.append("Windows ì´ì¤‘ ë°±ìŠ¬ë˜ì‹œë¥¼ ìŠ¬ë˜ì‹œë¡œ ë³€ê²½")
            
            if '\\' in content and not content.count('\\n') > content.count('\\'):
                # ë¬¸ìì—´ ì´ìŠ¤ì¼€ì´í”„ê°€ ì•„ë‹Œ ê²½ë¡œ êµ¬ë¶„ìë§Œ ë³€ê²½
                content = re.sub(r'\\(?![nrt"\'\\])', '/', content)
                changes_made.append("Windows ë°±ìŠ¬ë˜ì‹œë¥¼ ìŠ¬ë˜ì‹œë¡œ ë³€ê²½")
            
            # ì¤‘ë³µ ìŠ¬ë˜ì‹œ ì œê±°
            content = re.sub(r'/+', '/', content)
            if '//' in original_content and '//' not in content:
                changes_made.append("ì¤‘ë³µ ìŠ¬ë˜ì‹œ ì œê±°")
            
            # ìƒëŒ€ ê²½ë¡œ ì •ê·œí™”
            content = re.sub(r'\.//+', './', content)
            if './//' in original_content:
                changes_made.append("ìƒëŒ€ ê²½ë¡œ ì •ê·œí™”")
            
            if changes_made:
                # ë°±ì—… ìƒì„±
                self._create_backup(file_path)
                
                # íŒŒì¼ ì“°ê¸°
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="path_standardization",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"ê²½ë¡œ í‘œì¤€í™” ì˜¤ë¥˜ {file_path}: {e}")
        
        return None

    def fix_wildcard_patterns(self) -> List[CleanupResult]:
        """ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì˜¤ì¸ì‹ ë¬¸ì œ í•´ê²°"""
        logger.info("ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ë¬¸ì œ í•´ê²° ì‹œì‘...")
        
        wildcard_results = []
        
        # Python íŒŒì¼ì—ì„œ ì˜ëª»ëœ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ìˆ˜ì •
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                result = self._fix_wildcards_in_file(py_file)
                if result:
                    wildcard_results.append(result)
        
        logger.info(f"ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ {len(wildcard_results)}ê°œ íŒŒì¼ì—ì„œ ìˆ˜ì • ì™„ë£Œ")
        return wildcard_results

    def _fix_wildcards_in_file(self, file_path: Path) -> Optional[CleanupResult]:
        """ê°œë³„ íŒŒì¼ì˜ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ìˆ˜ì •"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            changes_made = []
            modified = False
            
            for i, line in enumerate(lines):
                original_line = line
                
                # ì˜ëª»ëœ ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ìˆ˜ì •
                # ì˜ˆ: "*.py" -> "*.py" (ë¬¸ìì—´ ë‚´ì—ì„œëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€)
                # ì˜ˆ: import *.py -> ì£¼ì„ ì²˜ë¦¬
                if re.search(r'import\s+\*\.', line):
                    lines[i] = f"# FIXED: {line}"
                    changes_made.append(f"Line {i+1}: ì˜ëª»ëœ ì™€ì¼ë“œì¹´ë“œ import ì£¼ì„ ì²˜ë¦¬")
                    modified = True
                
                # íŒŒì¼ ê²½ë¡œì—ì„œ ì˜ëª»ëœ ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš© ìˆ˜ì •
                elif re.search(r'[\'"][^\'\"]*\*[^\'\"]*\.py[\'"]', line):
                    # ë¬¸ìì—´ ë‚´ ì™€ì¼ë“œì¹´ë“œëŠ” glob íŒ¨í„´ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ìœ ì§€
                    pass
                
                # ê¸°íƒ€ ëª…í™•íˆ ì˜ëª»ëœ íŒ¨í„´ë“¤
                elif '*.py' in line and 'import' in line and not line.strip().startswith('#'):
                    lines[i] = f"# FIXED: {line}"
                    changes_made.append(f"Line {i+1}: ì˜ëª»ëœ ì™€ì¼ë“œì¹´ë“œ ì‚¬ìš© ì£¼ì„ ì²˜ë¦¬")
                    modified = True
            
            if modified:
                # ë°±ì—… ìƒì„±
                self._create_backup(file_path)
                
                # íŒŒì¼ ì“°ê¸°
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                
                return CleanupResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    cleanup_type="wildcard_fix",
                    changes_made=changes_made,
                    success=True
                )
        
        except Exception as e:
            logger.error(f"ì™€ì¼ë“œì¹´ë“œ ìˆ˜ì • ì˜¤ë¥˜ {file_path}: {e}")
        
        return None

    def _should_process_file(self, file_path: Path) -> bool:
        """íŒŒì¼ì„ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸"""
        if file_path.name.startswith('.'):
            return False
        
        path_str = str(file_path)
        exclude_dirs = ['.git', '__pycache__', 'backup', '.vscode', '.kiro']
        
        for exclude_dir in exclude_dirs:
            if exclude_dir in path_str:
                return False
        
        return True

    def _create_backup(self, file_path: Path):
        """ë°±ì—… ìƒì„±"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = self.backup_dir / f"{file_path.name}.backup_{timestamp}"
            shutil.copy2(file_path, backup_path)
        except Exception as e:
            logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨ {file_path}: {e}")

    def run_final_verification(self) -> Dict:
        """ìµœì¢… ê²€ì¦ ì‹¤í–‰"""
        logger.info("ìµœì¢… íŒŒì¼ ì°¸ì¡° ê²€ì¦ ì‹œì‘...")
        
        verification_results = {
            "broken_ref_count": 0,
            "wildcard_issues": 0,
            "path_issues": 0,
            "total_files_checked": 0
        }
        
        # Python íŒŒì¼ë“¤ ê²€ì¦
        for py_file in self.root_path.rglob("*.py"):
            if self._should_process_file(py_file):
                verification_results["total_files_checked"] += 1
                
                try:
                    with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    # BROKEN_REF ì£¼ì„ ì¹´ìš´íŠ¸
                    verification_results["broken_ref_count"] += content.count('BROKEN_REF:')
                    
                    # ì™€ì¼ë“œì¹´ë“œ ë¬¸ì œ ì¹´ìš´íŠ¸
                    if re.search(r'import\s+\*\.', content):
                        verification_results["wildcard_issues"] += 1
                    
                    # ê²½ë¡œ ë¬¸ì œ ì¹´ìš´íŠ¸
                    if '\\\\' in content or re.search(r'\.//+', content):
                        verification_results["path_issues"] += 1
                
                except Exception as e:
                    logger.error(f"ê²€ì¦ ì˜¤ë¥˜ {py_file}: {e}")
        
        return verification_results

    def generate_final_report(self) -> Dict:
        """ìµœì¢… ë³´ê³ ì„œ ìƒì„±"""
        # ëª¨ë“  ì •ë¦¬ ì‘ì—… ì‹¤í–‰
        broken_ref_results = self.cleanup_broken_ref_comments()
        path_results = self.standardize_path_references()
        wildcard_results = self.fix_wildcard_patterns()
        
        # ìµœì¢… ê²€ì¦
        verification = self.run_final_verification()
        
        report = {
            "timestamp": datetime.now().strftime("%Y%m%d_%H%M%S"),
            "cleanup_summary": {
                "broken_ref_cleanup": {
                    "files_processed": len(broken_ref_results),
                    "successful": len([r for r in broken_ref_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in broken_ref_results if r.success)
                },
                "path_standardization": {
                    "files_processed": len(path_results),
                    "successful": len([r for r in path_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in path_results if r.success)
                },
                "wildcard_fixes": {
                    "files_processed": len(wildcard_results),
                    "successful": len([r for r in wildcard_results if r.success]),
                    "total_changes": sum(len(r.changes_made) for r in wildcard_results if r.success)
                }
            },
            "final_verification": verification,
            "detailed_results": {
                "broken_ref_cleanup": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in broken_ref_results
                ],
                "path_standardization": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in path_results
                ],
                "wildcard_fixes": [
                    {
                        "file_path": r.file_path,
                        "success": r.success,
                        "changes_made": r.changes_made
                    }
                    for r in wildcard_results
                ]
            }
        }
        
        return report

    def save_report(self, report: Dict, filename: str = "final_file_reference_cleanup_report.json"):
        """ë³´ê³ ì„œ ì €ì¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"ìµœì¢… ë³´ê³ ì„œ ì €ì¥: {filename}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ§¹ POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ìµœì¢… ì •ë¦¬ ë„êµ¬")
    print("=" * 60)
    
    cleanup = FinalFileReferenceCleanup()
    
    # ìµœì¢… ì •ë¦¬ ë° ë³´ê³ ì„œ ìƒì„±
    print("\nğŸ”„ ìµœì¢… íŒŒì¼ ì°¸ì¡° ì •ë¦¬ ì‹¤í–‰ ì¤‘...")
    report = cleanup.generate_final_report()
    cleanup.save_report(report)
    
    # ê²°ê³¼ ìš”ì•½
    print(f"\nğŸ“Š ìµœì¢… ì •ë¦¬ ê²°ê³¼:")
    
    # BROKEN_REF ì •ë¦¬
    broken_ref = report['cleanup_summary']['broken_ref_cleanup']
    print(f"   â€¢ BROKEN_REF ì •ë¦¬:")
    print(f"     - ì²˜ë¦¬ëœ íŒŒì¼: {broken_ref['files_processed']}ê°œ")
    print(f"     - ì„±ê³µí•œ íŒŒì¼: {broken_ref['successful']}ê°œ")
    print(f"     - ì´ ë³€ê²½ì‚¬í•­: {broken_ref['total_changes']}ê°œ")
    
    # ê²½ë¡œ í‘œì¤€í™”
    path_std = report['cleanup_summary']['path_standardization']
    print(f"   â€¢ ê²½ë¡œ í‘œì¤€í™”:")
    print(f"     - ì²˜ë¦¬ëœ íŒŒì¼: {path_std['files_processed']}ê°œ")
    print(f"     - ì„±ê³µí•œ íŒŒì¼: {path_std['successful']}ê°œ")
    print(f"     - ì´ ë³€ê²½ì‚¬í•­: {path_std['total_changes']}ê°œ")
    
    # ì™€ì¼ë“œì¹´ë“œ ìˆ˜ì •
    wildcard = report['cleanup_summary']['wildcard_fixes']
    print(f"   â€¢ ì™€ì¼ë“œì¹´ë“œ ìˆ˜ì •:")
    print(f"     - ì²˜ë¦¬ëœ íŒŒì¼: {wildcard['files_processed']}ê°œ")
    print(f"     - ì„±ê³µí•œ íŒŒì¼: {wildcard['successful']}ê°œ")
    print(f"     - ì´ ë³€ê²½ì‚¬í•­: {wildcard['total_changes']}ê°œ")
    
    # ìµœì¢… ê²€ì¦ ê²°ê³¼
    verification = report['final_verification']
    print(f"\nğŸ” ìµœì¢… ê²€ì¦ ê²°ê³¼:")
    print(f"   â€¢ ê²€ì‚¬ëœ íŒŒì¼: {verification['total_files_checked']}ê°œ")
    print(f"   â€¢ ë‚¨ì€ BROKEN_REF: {verification['broken_ref_count']}ê°œ")
    print(f"   â€¢ ë‚¨ì€ ì™€ì¼ë“œì¹´ë“œ ë¬¸ì œ: {verification['wildcard_issues']}ê°œ")
    print(f"   â€¢ ë‚¨ì€ ê²½ë¡œ ë¬¸ì œ: {verification['path_issues']}ê°œ")
    
    # ì„±ê³µ ì—¬ë¶€ íŒë‹¨
    total_changes = (broken_ref['total_changes'] + 
                    path_std['total_changes'] + 
                    wildcard['total_changes'])
    
    if total_changes > 0:
        print(f"\nğŸ‰ íŒŒì¼ ì°¸ì¡° ì •ë¦¬ ì™„ë£Œ!")
        print(f"   â€¢ ì´ {total_changes}ê°œì˜ ë¬¸ì œ í•´ê²°")
        print(f"   â€¢ ë°±ì—… ë””ë ‰í† ë¦¬: {cleanup.backup_dir}")
    else:
        print(f"\nâœ… ì¶”ê°€ ì •ë¦¬ê°€ í•„ìš”í•œ ë¬¸ì œê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")
    
    return True

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)