#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ìµœì¢… ê²€ì¦ ë„êµ¬

Task 4 ì™„ë£Œ ê²€ì¦:
- 83ê°œ ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìˆ˜ì • í™•ì¸
- ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ì •ë¦¬ í™•ì¸
- ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì˜¤ì¸ì‹ ë¬¸ì œ í•´ê²° í™•ì¸
- ìƒëŒ€ ê²½ë¡œ ì°¸ì¡° ì •í™•ì„± ê²€ì¦ ë° í‘œì¤€í™” í™•ì¸
"""

import os
import re
import json
from pathlib import Path
from typing import Dict, List, Set
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class FileReferenceIntegrityVerifier:
    """íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ìµœì¢… ê²€ì¦ í´ë˜ìŠ¤"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.verification_results = {
            "broken_references_fixed": 0,
            "path_standardization_applied": 0,
            "wildcard_issues_resolved": 0,
            "relative_path_accuracy": 0,
            "total_files_processed": 0,
            "integrity_score": 0.0
        }

    def verify_task_completion(self) -> Dict:
        """Task 4 ì™„ë£Œ ê²€ì¦"""
        logger.info("íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± Task 4 ì™„ë£Œ ê²€ì¦ ì‹œì‘...")
        
        # 1. ë°±ì—… íŒŒì¼ ì¡´ì¬ í™•ì¸ (ìˆ˜ì • ì‘ì—…ì´ ìˆ˜í–‰ë˜ì—ˆëŠ”ì§€)
        backup_dirs = [
            ".file_reference_backup",
            ".refined_file_reference_backup", 
            ".critical_file_reference_backup"
        ]
        
        backup_files_count = 0
        for backup_dir in backup_dirs:
            backup_path = Path(backup_dir)
            if backup_path.exists():
                backup_files = list(backup_path.glob("*.backup_*"))
                backup_files_count += len(backup_files)
                logger.info(f"ë°±ì—… ë””ë ‰í† ë¦¬ {backup_dir}: {len(backup_files)}ê°œ íŒŒì¼")
        
        self.verification_results["total_files_processed"] = backup_files_count
        
        # 2. ìˆ˜ì • ë³´ê³ ì„œ í™•ì¸
        report_files = [
            "file_reference_repair_report.json",
            "refined_file_reference_repair_report.json",
            "critical_file_reference_fix_report.json"
        ]
        
        total_fixes = 0
        for report_file in report_files:
            if Path(report_file).exists():
                try:
                    with open(report_file, 'r', encoding='utf-8') as f:
                        report = json.load(f)
                    
                    if 'summary' in report:
                        if 'successful_repairs' in report['summary']:
                            total_fixes += report['summary']['successful_repairs']
                        elif 'fixed_issues' in report['summary']:
                            total_fixes += report['summary']['fixed_issues']
                    
                    logger.info(f"ë³´ê³ ì„œ {report_file} í™•ì¸ ì™„ë£Œ")
                except Exception as e:
                    logger.error(f"ë³´ê³ ì„œ ì½ê¸° ì˜¤ë¥˜ {report_file}: {e}")
        
        self.verification_results["broken_references_fixed"] = total_fixes
        
        # 3. í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ ê²€ì¦
        current_issues = self._scan_current_issues()
        
        # 4. ê²½ë¡œ í‘œì¤€í™” ê²€ì¦
        standardization_score = self._verify_path_standardization()
        self.verification_results["path_standardization_applied"] = standardization_score
        
        # 5. ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ë¬¸ì œ ê²€ì¦
        wildcard_score = self._verify_wildcard_handling()
        self.verification_results["wildcard_issues_resolved"] = wildcard_score
        
        # 6. ìƒëŒ€ ê²½ë¡œ ì •í™•ì„± ê²€ì¦
        relative_path_score = self._verify_relative_path_accuracy()
        self.verification_results["relative_path_accuracy"] = relative_path_score
        
        # 7. ì „ì²´ ë¬´ê²°ì„± ì ìˆ˜ ê³„ì‚°
        integrity_score = self._calculate_integrity_score()
        self.verification_results["integrity_score"] = integrity_score
        
        logger.info("íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ê²€ì¦ ì™„ë£Œ")
        return self.verification_results

    def _scan_current_issues(self) -> int:
        """í˜„ì¬ ë‚¨ì•„ìˆëŠ” íŒŒì¼ ì°¸ì¡° ë¬¸ì œ ìŠ¤ìº”"""
        logger.info("í˜„ì¬ íŒŒì¼ ì°¸ì¡° ìƒíƒœ ìŠ¤ìº” ì¤‘...")
        
        issues_count = 0
        
        # Python íŒŒì¼ì˜ import ë¬¸ì œ í™•ì¸
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # BROKEN_REF ì£¼ì„ì´ ìˆëŠ” ë¼ì¸ ìˆ˜ í™•ì¸
")
                issues_count += broken_ref_lines
                
            except Exception:
                continue
        
        logger.info(f"í˜„ì¬ ë‚¨ì•„ìˆëŠ” ë¬¸ì œ: {issues_count}ê°œ")
        return issues_count

    def _verify_path_standardization(self) -> int:
        """ê²½ë¡œ í‘œì¤€í™” ê²€ì¦"""
        logger.info("ê²½ë¡œ í‘œì¤€í™” ê²€ì¦ ì¤‘...")
        
        standardized_files = 0
        total_files = 0
        
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            
            total_files += 1
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Windows ìŠ¤íƒ€ì¼ ê²½ë¡œê°€ ìˆëŠ”ì§€ í™•ì¸
                windows_paths = re.findall(r'[\'"][^\'\"]*\\+[^\'\"]*[\'"]', content)
                if not windows_paths:
                    standardized_files += 1
                
            except Exception:
                continue
        
        standardization_rate = (standardized_files / total_files * 100) if total_files > 0 else 100
        logger.info(f"ê²½ë¡œ í‘œì¤€í™”ìœ¨: {standardization_rate:.1f}% ({standardized_files}/{total_files})")
        
        return int(standardization_rate)

    def _verify_wildcard_handling(self) -> int:
        """ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì²˜ë¦¬ ê²€ì¦"""
        logger.info("ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì²˜ë¦¬ ê²€ì¦ ì¤‘...")
        
        # ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì´ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
        # (ì‹¤ì œ glob íŒ¨í„´ì€ ìœ ì§€ë˜ê³ , ì˜ëª»ëœ íŒ¨í„´ë§Œ ìˆ˜ì •ë˜ì—ˆëŠ”ì§€)
        
        correct_patterns = 0
        total_patterns = 0
        
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # glob íŒ¨í„´ ì°¾ê¸°
                glob_patterns = re.findall(r'\.rglob\([\'"]([^\'"]*)[\'"]', content)
                for pattern in glob_patterns:
                    total_patterns += 1
                    # ìœ íš¨í•œ glob íŒ¨í„´ì¸ì§€ í™•ì¸
                    if '*' in pattern and not pattern.startswith('*'):
                        correct_patterns += 1
                    elif '*' not in pattern:
                        correct_patterns += 1
                
            except Exception:
                continue
        
        wildcard_score = (correct_patterns / total_patterns * 100) if total_patterns > 0 else 100
        logger.info(f"ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì •í™•ë„: {wildcard_score:.1f}% ({correct_patterns}/{total_patterns})")
        
        return int(wildcard_score)

    def _verify_relative_path_accuracy(self) -> int:
        """ìƒëŒ€ ê²½ë¡œ ì •í™•ì„± ê²€ì¦"""
        logger.info("ìƒëŒ€ ê²½ë¡œ ì •í™•ì„± ê²€ì¦ ì¤‘...")
        
        accurate_paths = 0
        total_paths = 0
        
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ì°¾ê¸°
                file_refs = re.findall(r'[\'"]([^\'\"]+\.(py|json|sh|bat|md|txt))[\'"]', content)
                
                for file_ref, ext in file_refs:
                    total_paths += 1
                    
                    # ìƒëŒ€ ê²½ë¡œê°€ ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                    if self._path_exists(file_ref, py_file):
                        accurate_paths += 1
                
            except Exception:
                continue
        
        accuracy_rate = (accurate_paths / total_paths * 100) if total_paths > 0 else 100
        logger.info(f"ìƒëŒ€ ê²½ë¡œ ì •í™•ë„: {accuracy_rate:.1f}% ({accurate_paths}/{total_paths})")
        
        return int(accuracy_rate)

    def _path_exists(self, file_ref: str, source_file: Path) -> bool:
        """ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
        # ì ˆëŒ€ ê²½ë¡œ
        if os.path.isabs(file_ref):
            return Path(file_ref).exists()
        
        # ìƒëŒ€ ê²½ë¡œ (ì†ŒìŠ¤ íŒŒì¼ ê¸°ì¤€)
        source_dir = source_file.parent
        relative_path = source_dir / file_ref
        if relative_path.exists():
            return True
        
        # ë£¨íŠ¸ ê¸°ì¤€ ê²½ë¡œ
        root_path = self.root_path / file_ref
        return root_path.exists()

    def _calculate_integrity_score(self) -> float:
        """ì „ì²´ ë¬´ê²°ì„± ì ìˆ˜ ê³„ì‚°"""
        # ê°€ì¤‘ì¹˜ ì ìš©í•œ ì ìˆ˜ ê³„ì‚°
        weights = {
            "path_standardization": 0.25,
            "wildcard_handling": 0.25,
            "relative_path_accuracy": 0.30,
            "fixes_applied": 0.20
        }
        
        # ìˆ˜ì • ì‘ì—… ì ìˆ˜ (ë°±ì—… íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ë¡œ íŒë‹¨)
        fixes_score = min(100, self.verification_results["total_files_processed"] * 2)
        
        total_score = (
            self.verification_results["path_standardization_applied"] * weights["path_standardization"] +
            self.verification_results["wildcard_issues_resolved"] * weights["wildcard_handling"] +
            self.verification_results["relative_path_accuracy"] * weights["relative_path_accuracy"] +
            fixes_score * weights["fixes_applied"]
        )
        
        return round(total_score, 2)

    def generate_verification_report(self) -> Dict:
        """ê²€ì¦ ë³´ê³ ì„œ ìƒì„±"""
        from datetime import datetime
        
        report = {
            "timestamp": datetime.now().strftime("%Y%m%d_%H%M%S"),
            "task": "Task 4: íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ì™„ì „ ë³µêµ¬",
            "verification_results": self.verification_results,
            "task_completion_status": {
                "broken_references_fixed": self.verification_results["broken_references_fixed"] > 0,
                "path_standardization_applied": self.verification_results["path_standardization_applied"] >= 90,
                "wildcard_issues_resolved": self.verification_results["wildcard_issues_resolved"] >= 90,
                "relative_path_accuracy_verified": self.verification_results["relative_path_accuracy"] >= 95,
                "overall_integrity_achieved": self.verification_results["integrity_score"] >= 95
            },
            "recommendations": self._generate_recommendations()
        }
        
        return report

    def _generate_recommendations(self) -> List[str]:
        """ê°œì„  ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        recommendations = []
        
        if self.verification_results["path_standardization_applied"] < 90:
            recommendations.append("ê²½ë¡œ í‘œì¤€í™”ë¥¼ ë” ì ìš©í•˜ì—¬ Windows/Unix í˜¸í™˜ì„±ì„ ê°œì„ í•˜ì„¸ìš”.")
        
        if self.verification_results["wildcard_issues_resolved"] < 90:
            recommendations.append("ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì²˜ë¦¬ë¥¼ ê°œì„ í•˜ì—¬ íŒŒì¼ ê²€ìƒ‰ ì •í™•ë„ë¥¼ ë†’ì´ì„¸ìš”.")
        
        if self.verification_results["relative_path_accuracy"] < 95:
            recommendations.append("ìƒëŒ€ ê²½ë¡œ ì°¸ì¡°ì˜ ì •í™•ì„±ì„ ê°œì„ í•˜ì—¬ íŒŒì¼ ì°¸ì¡° ì˜¤ë¥˜ë¥¼ ì¤„ì´ì„¸ìš”.")
        
        if self.verification_results["integrity_score"] >= 95:
            recommendations.append("íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„±ì´ ìš°ìˆ˜í•œ ìˆ˜ì¤€ì…ë‹ˆë‹¤. í˜„ì¬ ìƒíƒœë¥¼ ìœ ì§€í•˜ì„¸ìš”.")
        
        return recommendations

    def save_verification_report(self, report: Dict, filename: str = "task4_file_reference_integrity_verification.json"):
        """ê²€ì¦ ë³´ê³ ì„œ ì €ì¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"ê²€ì¦ ë³´ê³ ì„œ ì €ì¥: {filename}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("âœ… POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± Task 4 ì™„ë£Œ ê²€ì¦")
    print("=" * 60)
    
    verifier = FileReferenceIntegrityVerifier()
    
    # Task 4 ì™„ë£Œ ê²€ì¦
    print("\nğŸ” Task 4 ì™„ë£Œ ìƒíƒœ ê²€ì¦ ì¤‘...")
    results = verifier.verify_task_completion()
    
    # ê²€ì¦ ë³´ê³ ì„œ ìƒì„±
    print("\nğŸ“‹ ê²€ì¦ ë³´ê³ ì„œ ìƒì„± ì¤‘...")
    report = verifier.generate_verification_report()
    verifier.save_verification_report(report)
    
    # ê²°ê³¼ ì¶œë ¥
    print(f"\nğŸ“Š Task 4 ì™„ë£Œ ê²€ì¦ ê²°ê³¼:")
    print(f"   â€¢ ìˆ˜ì •ëœ íŒŒì¼ ì°¸ì¡°: {results['broken_references_fixed']}ê°œ")
    print(f"   â€¢ ì²˜ë¦¬ëœ íŒŒì¼ ìˆ˜: {results['total_files_processed']}ê°œ")
    print(f"   â€¢ ê²½ë¡œ í‘œì¤€í™”ìœ¨: {results['path_standardization_applied']}%")
    print(f"   â€¢ ì™€ì¼ë“œì¹´ë“œ ì²˜ë¦¬ìœ¨: {results['wildcard_issues_resolved']}%")
    print(f"   â€¢ ìƒëŒ€ ê²½ë¡œ ì •í™•ë„: {results['relative_path_accuracy']}%")
    print(f"   â€¢ ì „ì²´ ë¬´ê²°ì„± ì ìˆ˜: {results['integrity_score']}%")
    
    # ì™„ë£Œ ìƒíƒœ í™•ì¸
    completion_status = report["task_completion_status"]
    all_completed = all(completion_status.values())
    
    print(f"\nğŸ¯ Task 4 ì™„ë£Œ ìƒíƒœ:")
    for task, completed in completion_status.items():
        status = "âœ…" if completed else "âŒ"
        print(f"   {status} {task}: {'ì™„ë£Œ' if completed else 'ë¯¸ì™„ë£Œ'}")
    
    if all_completed:
        print(f"\nğŸ‰ Task 4: íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ì™„ì „ ë³µêµ¬ - ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œ!")
        print(f"   ì „ì²´ ë¬´ê²°ì„± ì ìˆ˜: {results['integrity_score']}% (ëª©í‘œ: 95% ì´ìƒ)")
    else:
        print(f"\nâš ï¸  Task 4 ì¼ë¶€ í•­ëª©ì´ ë¯¸ì™„ë£Œ ìƒíƒœì…ë‹ˆë‹¤.")
        print("ê¶Œì¥ì‚¬í•­:")
        for rec in report["recommendations"]:
            print(f"   â€¢ {rec}")
    
    return all_completed

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)