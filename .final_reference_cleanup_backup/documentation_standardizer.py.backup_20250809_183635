#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Documentation Standardizer
POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ

WatchHamster v3.0 ë° POSCO News 250808 250808 í˜¸í™˜
Created: 2025-08-08
"""

import posco_news_250808_monitor.log
import verify_folder_reorganization.py
# BROKEN_REF: import glob
# BROKEN_REF: from typing import deployment_verification_checklist.md, Dict, Tuple
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: import logging

class DocumentationStandardizer:
    """ì£¼ì„ ë° ë¬¸ì„œ í‘œì¤€í™” í´ë˜ìŠ¤"""

def __init__(self):
    self.watchhamster_version = "v3.0"
    self.POSCO_News_250808_250808_version =  "250808"
    self.current_date = datetime.now().strftime("%Y-%m-%d")

    # ë¡œê¹… ì„¤ì •
    logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
    logging.FileHandler('documentation_standardization.log'),
    logging.StreamHandler()
    ]
    )
    self.logger = logging.getLogger(__name__)

    # í‘œì¤€í™” ê·œì¹™ ì •ì˜
    self.version_patterns = {
    # ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ íŒ¨í„´
    'watchhamster_old': [
    r'ì›Œì¹˜í–„ìŠ¤í„°/s*v?2/.?/d*',
    r'WatchHamster/s*v?2/.?/d*',
    r'watchhamster/s*v?2/.?/d*',
    r'WatchHamster v3.0',
    r'WatchHamster v3.0(?!/.0)',
    r'WatchHamster/s*v3(?!/.0)',
    ],
    'watchhamster_new': 'WatchHamster v3.0',

    # POSCO News 250808 250808 ë²„ì „ íŒ¨í„´
    'POSCO News 250808 250808_old': [
    r'POSCO News 250808 250808_mini/s*v?2/.?/d*',
    r'POSCO News 250808 250808/s*mini',
    r'POSCO News 250808 250808/s*mini',
    r'POSCO News 250808 250808/s*v?2/.?/d*',
    ],
    'POSCO News 250808 250808_new': 'POSCO News 250808 250808'
    }

    # íŒŒì¼ í—¤ë” í…œí”Œë¦¿
    self.header_templates = {
    'python': '''#!/usr/bin/env python3
    # -*- coding: utf-8 -*-
"""
{title}
{description}

WatchHamster v3.0 ë° POSCO News 250808 250808 í˜¸í™˜
Created: {date}
"""''',

    'shell': '''#!/bin/bash
    # ============================================================================
    # {title}
    # {description}
    #
    # WatchHamster v3.0 ë° POSCO News 250808 250808 í˜¸í™˜
    # Created: {date}
    # ============================================================================''',

            'batch': '''@echo off
    REM ============================================================================
    REM {title}
    REM {description}
    REM
    REM WatchHamster v3.0 ë° POSCO News 250808 250808 í˜¸í™˜
    REM Created: {date}
    REM ============================================================================'''
        }

def standardize_python_headers(self) -> List[str]:
        """Python íŒŒì¼ í—¤ë” ì£¼ì„ í‘œì¤€í™”"""
        python_files = []

    # Python íŒŒì¼ ì°¾ê¸°
# BROKEN_REF:         for pattern in ['**/*.py']:
python_files.extend(glob.glob(pattern,_recursive = True))

        updated_files = []

        for file_path in python_files:
            try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                    content = f.read()

    # ê¸°ì¡´ í—¤ë” ë¶„ì„
                original_content = content

    # íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ
                filename = os.path.basename(file_path)
                title = self._extract_title_from_filename(filename)
                description = self._generate_description(filename, content)

    # ìƒˆë¡œìš´ í—¤ë” ìƒì„±
                new_header = self.header_templates['python'].format(
                    title=title,
                    description=description,
                    date=self.current_date
                )

    # ê¸°ì¡´ í—¤ë” ì œê±° ë° ìƒˆ í—¤ë” ì¶”ê°€
                updated_content = self._replace_python_header(content, new_header)

    # ë²„ì „ ì •ë³´ í‘œì¤€í™”
                updated_content = self._standardize_version_references(updated_content)

                if updated_content != original_content:
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                        f.write(updated_content)
                    updated_files.append(file_path)
                    self.logger.info(f"Python í—¤ë” í‘œì¤€í™” ì™„ë£Œ: {file_path}")

    except Exception as e:
                self.logger.error(f"Python íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ {file_path}: {e}")

        return updated_files

def standardize_shell_headers(self) -> List[str]:
        """Shell ìŠ¤í¬ë¦½íŠ¸ í—¤ë” ì£¼ì„ í‘œì¤€í™”"""
        shell_files = []

    # Shell íŒŒì¼ ì°¾ê¸°
# BROKEN_REF:         for pattern in ['**/*.sh', '**/*.command']:
shell_files.extend(glob.glob(pattern,_recursive = True))

        updated_files = []

        for file_path in shell_files:
            try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                    content = f.read()

                original_content = content

    # íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ
                filename = os.path.basename(file_path)
                title = self._extract_title_from_filename(filename)
                description = self._generate_description(filename, content)

    # ìƒˆë¡œìš´ í—¤ë” ìƒì„±
                new_header = self.header_templates['shell'].format(
                    title=title,
                    description=description,
                    date=self.current_date
                )

    # ê¸°ì¡´ í—¤ë” ì œê±° ë° ìƒˆ í—¤ë” ì¶”ê°€
                updated_content = self._replace_shell_header(content, new_header)

    # ë²„ì „ ì •ë³´ í‘œì¤€í™”
                updated_content = self._standardize_version_references(updated_content)

                if updated_content != original_content:
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                        f.write(updated_content)
                    updated_files.append(file_path)
                    self.logger.info(f"Shell í—¤ë” í‘œì¤€í™” ì™„ë£Œ: {file_path}")

    except Exception as e:
                self.logger.error(f"Shell íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ {file_path}: {e}")

        return updated_files

def standardize_batch_headers(self) -> List[str]:
        """Batch íŒŒì¼ í—¤ë” ì£¼ì„ í‘œì¤€í™”"""
        batch_files = []

    # Batch íŒŒì¼ ì°¾ê¸°
# BROKEN_REF:         for pattern in ['**/*.bat']:
batch_files.extend(glob.glob(pattern,_recursive = True))

        updated_files = []

        for file_path in batch_files:
            try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                    content = f.read()

                original_content = content

    # íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ
                filename = os.path.basename(file_path)
                title = self._extract_title_from_filename(filename)
                description = self._generate_description(filename, content)

    # ìƒˆë¡œìš´ í—¤ë” ìƒì„±
                new_header = self.header_templates['batch'].format(
                    title=title,
                    description=description,
                    date=self.current_date
                )

    # ê¸°ì¡´ í—¤ë” ì œê±° ë° ìƒˆ í—¤ë” ì¶”ê°€
                updated_content = self._replace_batch_header(content, new_header)

    # ë²„ì „ ì •ë³´ í‘œì¤€í™”
                updated_content = self._standardize_version_references(updated_content)

                if updated_content != original_content:
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                        f.write(updated_content)
                    updated_files.append(file_path)
                    self.logger.info(f"Batch í—¤ë” í‘œì¤€í™” ì™„ë£Œ: {file_path}")

    except Exception as e:
                self.logger.error(f"Batch íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ {file_path}: {e}")

        return updated_files

def standardize_markdown_documents(self) -> List[str]:
        """ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ ì œëª© ë° ë‚´ìš© í‘œì¤€í™”"""
        md_files = []

    # ë§ˆí¬ë‹¤ìš´ íŒŒì¼ ì°¾ê¸°
# BROKEN_REF:         for pattern in ['**/*.md']:
md_files.extend(glob.glob(pattern,_recursive = True))

        updated_files = []

        for file_path in md_files:
            try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                    content = f.read()

                original_content = content

    # ì œëª© í‘œì¤€í™”
                updated_content = self._standardize_markdown_titles(content)

    # ë²„ì „ ì •ë³´ í‘œì¤€í™”
                updated_content = self._standardize_version_references(updated_content)

    # ì œí’ˆëª… í‘œì¤€í™”
                updated_content = self._standardize_product_names(updated_content)

                if updated_content != original_content:
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                        f.write(updated_content)
                    updated_files.append(file_path)
                    self.logger.info(f"ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ í‘œì¤€í™” ì™„ë£Œ: {file_path}")

    except Exception as e:
                self.logger.error(f"ë§ˆí¬ë‹¤ìš´ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ {file_path}: {e}")

        return updated_files

def standardize_readme_files(self) -> List[str]:
        """README íŒŒì¼ ë²„ì „ ì •ë³´ í†µì¼"""
        readme_files = []

    # README íŒŒì¼ ì°¾ê¸°
        for pattern in ['README.md', 'TEST_FRAMEWORK_README.md', 'README.md']:
readme_files.extend(glob.glob(pattern,_recursive = True))

        updated_files = []

        for file_path in readme_files:
            try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                    content = f.read()

                original_content = content

    # README íŠ¹í™” í‘œì¤€í™”
                updated_content = self._standardize_readme_content(content)

                if updated_content != original_content:
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                        f.write(updated_content)
                    updated_files.append(file_path)
                    self.logger.info(f"README íŒŒì¼ í‘œì¤€í™” ì™„ë£Œ: {file_path}")

    except Exception as e:
                self.logger.error(f"README íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ {file_path}: {e}")

        return updated_files

def _extract_title_from_filename(self, filename: str) -> str:
        """íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ"""
    # í™•ì¥ì ì œê±°
        name = os.path.splitext(filename)[0]

    # ì´ëª¨ì§€ ë° íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬
        name = re.sub(r'^[ğŸ›ï¸ğŸ¹ğŸ“‹ğŸ”„ğŸ”§ğŸš€ğŸ›‘ğŸ§ª]+', '', name)

    # ì–¸ë”ìŠ¤ì½”ì–´ë¥¼ ê³µë°±ìœ¼ë¡œ ë³€í™˜
        name = name.replace('_', ' ')

    # ì²« ê¸€ì ëŒ€ë¬¸ìí™”
        return name.strip().title()

def _generate_description(self, filename: str, content: str) -> str:
        """íŒŒì¼ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ì„¤ëª… ìƒì„±"""
        if 'control' in filename.lower() or 'ì œì–´ì„¼í„°' in filename:
            return "POSCO ì‹œìŠ¤í…œ ì œì–´ì„¼í„°"
        elif 'monitor' in filename.lower() or 'ëª¨ë‹ˆí„°' in filename:
            return "POSCO ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"
        elif 'test' in filename.lower() or 'í…ŒìŠ¤íŠ¸' in filename:
            return "POSCO ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"
        elif 'notifier' in filename.lower() or 'ì•Œë¦¼' in filename:
            return "POSCO ì•Œë¦¼ ì‹œìŠ¤í…œ"
        else:
            return "POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ"

def _replace_python_header(self, content: str, new_header: str) -> str:
        """Python íŒŒì¼ í—¤ë” êµì²´"""
    # ê¸°ì¡´ í—¤ë” íŒ¨í„´ ì°¾ê¸°
        header_pattern = r'^(#!/usr/bin/env python3?/s*/n)?(# -/*- coding: utf-8 -/*-/s*/n)?("""[/s/S]*?"""/s*/n)?'

        match = re.match(header_pattern, content)
        if match:
    # ê¸°ì¡´ í—¤ë” ì œê±° í›„ ìƒˆ í—¤ë” ì¶”ê°€
            remaining_content = content[match.end():]
            return new_header + '/n/n' + remaining_content
        else:
    # í—¤ë”ê°€ ì—†ìœ¼ë©´ ë§¨ ì•ì— ì¶”ê°€
            return new_header + '/n/n' + content

def _replace_shell_header(self, content: str, new_header: str) -> str:
        """Shell ìŠ¤í¬ë¦½íŠ¸ í—¤ë” êµì²´"""
    # ê¸°ì¡´ í—¤ë” íŒ¨í„´ ì°¾ê¸°
        header_pattern = r'^(#!/bin/bash/s*/n)?(#[^/n]*/n)*'

        lines = content.split('/n')
        header_end = 0

        for i, line in enumerate(lines):
            if line.startswith('#') or line.startswith('#!/bin/bash') or line.strip() == '':
                header_end = i + 1
            else:
                break

        remaining_content = '/n'.join(lines[header_end:])
        return new_header + '/n/n' + remaining_content

def _replace_batch_header(self, content: str, new_header: str) -> str:
        """Batch íŒŒì¼ í—¤ë” êµì²´"""
        lines = content.split('/n')
        header_end = 0

        for i, line in enumerate(lines):
            if (line.startswith('@echo off') or 
                line.startswith('REM') or 
                line.startswith('rem') or 
                line.strip() == ''):
                header_end = i + 1
            else:
                break

        remaining_content = '/n'.join(lines[header_end:])
        return new_header + '/n/n' + remaining_content

def _standardize_version_references(self, content: str) -> str:
        """ë²„ì „ ì°¸ì¡° í‘œì¤€í™”"""
        updated_content = content

    # ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ í‘œì¤€í™”
        for pattern in self.version_patterns['watchhamster_old']:
            updated_content = re.sub(
                pattern, 
                self.version_patterns['watchhamster_new'], 
                updated_content, 
                flags=re.IGNORECASE
            )

    # POSCO News 250808 250808 ë²„ì „ í‘œì¤€í™”
        for pattern in self.version_patterns['POSCO News 250808 250808_old']:
            updated_content = re.sub(
                pattern, 
                self.version_patterns['POSCO News 250808 250808_new'], 
                updated_content, 
                flags=re.IGNORECASE
            )

        return updated_content

def _standardize_markdown_titles(self, content: str) -> str:
        """ë§ˆí¬ë‹¤ìš´ ì œëª© í‘œì¤€í™”"""
        lines = content.split('/n')
        updated_lines = []

        for line in lines:
            if line.startswith('#'):
    # ì œëª©ì—ì„œ ë²„ì „ ì •ë³´ í‘œì¤€í™”
                updated_line = self._standardize_version_references(line)
                updated_line = self._standardize_product_names(updated_line)
                updated_lines.append(updated_line)
            else:
                updated_lines.append(line)

        return '/n'.join(updated_lines)

def _standardize_product_names(self, content: str) -> str:
        """ì œí’ˆëª… í‘œì¤€í™”"""
    # ì›Œì¹˜í–„ìŠ¤í„° ì œí’ˆëª… í‘œì¤€í™”
        content = re.sub(r'ì›Œì¹˜í–„ìŠ¤í„°', 'WatchHamster', content)
        content = re.sub(r'POSCO WatchHamster v3.0', 'POSCO WatchHamster', content)

    # POSCO News 250808 250808 ì œí’ˆëª… í‘œì¤€í™”
        content = re.sub(r'POSCO News 250808 250808_mini', 'POSCO News 250808', content)
        content = re.sub(r'POSCO News 250808 250808', 'POSCO News 250808', content)

        return content

def _standardize_readme_content(self, content: str) -> str:
        """README íŒŒì¼ íŠ¹í™” í‘œì¤€í™”"""
        updated_content = content

    # ë²„ì „ ì •ë³´ ì„¹ì…˜ ì¶”ê°€/ì—…ë°ì´íŠ¸
        version_section = f"""
    ## ë²„ì „ ì •ë³´

- **WatchHamster**: v3.0
- **POSCO News 250808**: 250808
- **ìµœì¢… ì—…ë°ì´íŠ¸**: {self.current_date}

"""

    # ê¸°ì¡´ ë²„ì „ ì •ë³´ ì„¹ì…˜ ì°¾ê¸°
        version_pattern = r'## ë²„ì „ ì •ë³´[/s/S]*?(?=/n##|/n#|/Z)'

        if re.search(version_pattern, updated_content):
    # ê¸°ì¡´ ë²„ì „ ì •ë³´ êµì²´
            updated_content = re.sub(version_pattern, version_section.strip(), updated_content)
        else:
    # ì²« ë²ˆì§¸ ì„¹ì…˜ ë’¤ì— ë²„ì „ ì •ë³´ ì¶”ê°€
            first_section_pattern = r'(# [^/n]*/n[^/n]*/n)'
            match = re.search(first_section_pattern, updated_content)
            if match:
                insert_pos = match.end()
                updated_content = (updated_content[:insert_pos] + 
                                 version_section + 
                                 updated_content[insert_pos:])

    # ì¼ë°˜ì ì¸ ë²„ì „ ì°¸ì¡° í‘œì¤€í™”
        updated_content = self._standardize_version_references(updated_content)
        updated_content = self._standardize_product_names(updated_content)

        return updated_content

def run_full_standardization(self) -> Dict[str, List[str]]:
        """ì „ì²´ í‘œì¤€í™” ì‹¤í–‰"""
        self.logger.info("=== POSCO ì£¼ì„ ë° ë¬¸ì„œ í‘œì¤€í™” ì‹œì‘ ===")

        results = {
            'python_files': self.standardize_python_headers(),
            'shell_files': self.standardize_shell_headers(),
            'batch_files': self.standardize_batch_headers(),
            'markdown_files': self.standardize_markdown_documents(),
            'readme_files': self.standardize_readme_files()
        }

    # ê²°ê³¼ ìš”ì•½
        total_files = sum(len(files) for files in results.values())
        self.logger.info(f"=== í‘œì¤€í™” ì™„ë£Œ: ì´ {total_files}ê°œ íŒŒì¼ ===")

        for category, files in results.items():
            if files:
                self.logger.info(f"{category}: {len(files)}ê°œ íŒŒì¼")
                for file_path in files:
                    self.logger.info(f"  - {file_path}")

        return results

if __name__ == "__main__":
    standardizer = DocumentationStandardizer()
    results = standardizer.run_full_standardization()

    print("/nğŸ‰ POSCO ì£¼ì„ ë° ë¬¸ì„œ í‘œì¤€í™” ì™„ë£Œ!")
    print(f"ì´ {sum(len(files) for files in results.values())}ê°œ íŒŒì¼ì´ í‘œì¤€í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")