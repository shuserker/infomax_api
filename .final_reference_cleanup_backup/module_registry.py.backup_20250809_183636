#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module Registry
POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import test_config.json
import posco_news_250808_monitor.log
# BROKEN_REF: import logging
# BROKEN_REF: from typing import Dict, List, Optional, Any
# BROKEN_REF: from dataclasses import dataclass, asdict
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: from enum import Enum

class ModuleStatus(Enum):
    """ëª¨ë“ˆ ìƒíƒœ ì—´ê±°í˜•"""
    REGISTERED = "registered"
    ACTIVE = "active"
    INACTIVE = "inactive"
    DISABLED = "disabled"
    ERROR = "error"

@dataclass
class ModuleConfig:
    """ëª¨ë“ˆ ì„¤ì • ë°ì´í„° í´ë˜ìŠ¤"""
    name: str
    script_path: str
    description: str
auto_start:_bool =  True
restart_on_failure:_bool =  True
max_restart_attempts:_int =  3
health_check_interval:_int =  300
dependencies:_List[str] =  None
environment_vars:_Dict[str,_str] =  None
working_directory:_Optional[str] =  None
timeout:_int =  30
priority:_int =  0  # ì‹œì‘ ìš°ì„ ìˆœìœ„ (ë‚®ì„ìˆ˜ë¡ ë¨¼ì € ì‹œì‘)
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []
        if self.environment_vars is None:
            self.environment_vars = {}

class ModuleRegistry:
    """
    ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ í´ë˜ìŠ¤
    
    JSON ê¸°ë°˜ ëª¨ë“ˆ ì„¤ì • ê´€ë¦¬ ë° ë™ì  ëª¨ë“ˆ ë“±ë¡/í•´ì œ ê¸°ëŠ¥ ì œê³µ
    """
    
    def __init__(self, config_file: str = ".naming_backup/config_data_backup/Monitoring/Posco_News_mini/modules.json"):
        """
        ModuleRegistry ì´ˆê¸°í™”
        
        Args:
            config_file (str): ì„¤ì • íŒŒì¼ ê²½ë¡œ
        """
        self.config_file = config_file
        self.logger = logging.getLogger(__name__)
        
        # ëª¨ë“ˆ ê´€ë¦¬
self.modules:_Dict[str,_ModuleConfig] =  {}
self.module_status:_Dict[str,_ModuleStatus] =  {}
        
        # ì„¤ì • ë¡œë“œ
        self.load_config()
        
        self.logger.info(f"ğŸ”§ ModuleRegistry ì´ˆê¸°í™” ì™„ë£Œ ({len(self.modules)}ê°œ ëª¨ë“ˆ)")
    
    def load_config(self) -> bool:
        """
        ì„¤ì • íŒŒì¼ ë¡œë“œ
        
        Returns:
            bool: ë¡œë“œ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if not os.path.exists(self.config_file):
                self.logger.info(f"ğŸ“‹ ì„¤ì • íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì„¤ì •ì„ ìƒì„±í•©ë‹ˆë‹¤: {self.config_file}")
                self._create_default_config()
                return True
            
with_open(self.config_file,_'r',_encoding = 'utf-8') as f:
                config_data = json.load(f)
            
            # ëª¨ë“ˆ ì„¤ì • íŒŒì‹±
            modules_data = config_data.get('modules', {})
            
            for name, module_data in modules_data.items():
                try:
                    module_config = ModuleConfig(
                        name=name,
                        script_path=module_data['script_path'],
                        description=module_data.get('description', ''),
                        auto_start=module_data.get('auto_start', True),
                        restart_on_failure=module_data.get('restart_on_failure', True),
                        max_restart_attempts=module_data.get('max_restart_attempts', 3),
                        health_check_interval=module_data.get('health_check_interval', 300),
                        dependencies=module_data.get('dependencies', []),
                        environment_vars=module_data.get('environment_vars', {}),
                        working_directory=module_data.get('working_directory'),
                        timeout=module_data.get('timeout', 30),
                        priority=module_data.get('priority', 0)
                    )
                    
                    self.modules[name] = module_config
                    self.module_status[name] = ModuleStatus.REGISTERED
                    
                except Exception as e:
                    self.logger.error(f"âŒ ëª¨ë“ˆ ì„¤ì • íŒŒì‹± ì‹¤íŒ¨ ({name}): {e}")
                    continue
            
            self.logger.info(f"âœ… ì„¤ì • íŒŒì¼ ë¡œë“œ ì™„ë£Œ: {len(self.modules)}ê°œ ëª¨ë“ˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ ì„¤ì • íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return False
    
    def save_config(self) -> bool:
        """
        ì„¤ì • íŒŒì¼ ì €ì¥
        
        Returns:
            bool: ì €ì¥ ì„±ê³µ ì—¬ë¶€
        """
        try:
            config_data = {
                'metadata': {
                    'version': '1.0',
                    'last_updated': datetime.now().isoformat(),
                    'description': 'POSCO WatchHamster Module Registry Configuration'
                },
                'modules': {}
            }
            
            # ëª¨ë“ˆ ì„¤ì •ì„ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
            for name, module_config in self.modules.items():
                config_data['modules'][name] = {
                    'script_path': module_config.script_path,
                    'description': module_config.description,
                    'auto_start': module_config.auto_start,
                    'restart_on_failure': module_config.restart_on_failure,
                    'max_restart_attempts': module_config.max_restart_attempts,
                    'health_check_interval': module_config.health_check_interval,
                    'dependencies': module_config.dependencies,
                    'environment_vars': module_config.environment_vars,
                    'working_directory': module_config.working_directory,
                    'timeout': module_config.timeout,
                    'priority': module_config.priority
                }
            
            # íŒŒì¼ ì €ì¥
with_open(self.config_file,_'w',_encoding = 'utf-8') as f:
json.dump(config_data,_f,_indent = 2, ensure_ascii=False)
            
            self.logger.info(f"âœ… ì„¤ì • íŒŒì¼ ì €ì¥ ì™„ë£Œ: {self.config_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ ì„¤ì • íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _create_default_config(self):
        """ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„±"""
        try:
            # ê¸°ë³¸ ëª¨ë“ˆ ì„¤ì •
            default_modules = {
                'posco_main_notifier': ModuleConfig(
                    name='posco_main_notifier',
                    script_path='Monitoring/POSCO_News_250808/posco_main_notifier.py',
                    description='POSCO News 250808 ì•Œë¦¼ ì‹œìŠ¤í…œ',
                    auto_start=True,
                    restart_on_failure=True,
                    max_restart_attempts=3,
                    health_check_interval=300,
                    dependencies=[],
                    priority=1
                ),
                'realtime_news_monitor': ModuleConfig(
                    name='realtime_news_monitor',
                    script_path='Monitoring/POSCO_News_250808/realtime_news_monitor.py',
                    description='ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ',
                    auto_start=True,
                    restart_on_failure=True,
                    max_restart_attempts=3,
                    health_check_interval=300,
                    dependencies=['posco_main_notifier'],
                    priority=2
                ),
                'integrated_report_scheduler': ModuleConfig(
                    name='integrated_report_scheduler',
                    script_path='Monitoring/POSCO_News_250808/integrated_report_scheduler.py',
                    description='í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬',
                    auto_start=True,
                    restart_on_failure=True,
                    max_restart_attempts=3,
                    health_check_interval=300,
                    dependencies=['posco_main_notifier'],
                    priority=3
                ),
                'historical_data_collector': ModuleConfig(
                    name='historical_data_collector',
                    script_path='Monitoring/POSCO_News_250808/historical_data_collector.py',
                    description='íˆìŠ¤í† ë¦¬ ë°ì´í„° ìˆ˜ì§‘ê¸°',
                    auto_start=False,  # ì„ íƒì  ì‹œì‘
                    restart_on_failure=True,
                    max_restart_attempts=2,
                    health_check_interval=600,  # 10ë¶„
                    dependencies=[],
                    priority=4
                )
            }
            
            # ëª¨ë“ˆ ë“±ë¡
            for name, config in default_modules.items():
                self.modules[name] = config
                self.module_status[name] = ModuleStatus.REGISTERED
            
            # ì„¤ì • íŒŒì¼ ì €ì¥
            self.save_config()
            
            self.logger.info("âœ… ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„± ì™„ë£Œ")
            
        except Exception as e:
            self.logger.error(f"âŒ ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„± ì‹¤íŒ¨: {e}")
    
    def register_module(self, name: str, config: ModuleConfig) -> bool:
        """
        ëª¨ë“ˆ ë“±ë¡
        
        Args:
            name (str): ëª¨ë“ˆ ì´ë¦„
            config (ModuleConfig): ëª¨ë“ˆ ì„¤ì •
            
        Returns:
            bool: ë“±ë¡ ì„±ê³µ ì—¬ë¶€
        """
        try:
            # ìœ íš¨ì„± ê²€ì‚¬
            validation_errors = self.validate_module_config(config)
            if validation_errors:
                self.logger.error(f"âŒ ëª¨ë“ˆ ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ ({name}): {validation_errors}")
                return False
            
            # ì˜ì¡´ì„± ê²€ì‚¬
            if not self._check_dependencies(config.dependencies):
                self.logger.error(f"âŒ ëª¨ë“ˆ ì˜ì¡´ì„± ê²€ì‚¬ ì‹¤íŒ¨ ({name})")
                return False
            
            # ëª¨ë“ˆ ë“±ë¡
            self.modules[name] = config
            self.module_status[name] = ModuleStatus.REGISTERED
            
            # ì„¤ì • ì €ì¥
            self.save_config()
            
            self.logger.info(f"âœ… ëª¨ë“ˆ ë“±ë¡ ì™„ë£Œ: {name}")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ ëª¨ë“ˆ ë“±ë¡ ì‹¤íŒ¨ ({name}): {e}")
            return False
    
    def unregister_module(self, name: str) -> bool:
        """
        ëª¨ë“ˆ ë“±ë¡ í•´ì œ
        
        Args:
            name (str): ëª¨ë“ˆ ì´ë¦„
            
        Returns:
            bool: í•´ì œ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if name not in self.modules:
                self.logger.warning(f"âš ï¸ ë“±ë¡ë˜ì§€ ì•Šì€ ëª¨ë“ˆ: {name}")
                return False
            
            # ì˜ì¡´ì„± í™•ì¸ (ë‹¤ë¥¸ ëª¨ë“ˆì´ ì´ ëª¨ë“ˆì— ì˜ì¡´í•˜ëŠ”ì§€)
            dependent_modules = self._find_dependent_modules(name)
            if dependent_modules:
                self.logger.error(f"âŒ ëª¨ë“ˆ í•´ì œ ë¶ˆê°€ ({name}): ì˜ì¡´ ëª¨ë“ˆ ì¡´ì¬ - {dependent_modules}")
                return False
            
            # ëª¨ë“ˆ ì œê±°
            del self.modules[name]
            if name in self.module_status:
                del self.module_status[name]
            
            # ì„¤ì • ì €ì¥
            self.save_config()
            
            self.logger.info(f"âœ… ëª¨ë“ˆ ë“±ë¡ í•´ì œ ì™„ë£Œ: {name}")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ ëª¨ë“ˆ ë“±ë¡ í•´ì œ ì‹¤íŒ¨ ({name}): {e}")
            return False
    
    def get_module_config(self, name: str) -> Optional[ModuleConfig]:
        """
        ëª¨ë“ˆ ì„¤ì • ì¡°íšŒ
        
        Args:
            name (str): ëª¨ë“ˆ ì´ë¦„
            
        Returns:
            Optional[ModuleConfig]: ëª¨ë“ˆ ì„¤ì •
        """
        return self.modules.get(name)
    
    def list_modules(self) -> Dict[str, Dict[str, Any]]:
        """
        ëª¨ë“  ëª¨ë“ˆ ëª©ë¡ ì¡°íšŒ
        
        Returns:
            Dict[str, Dict[str, Any]]: ëª¨ë“ˆ ëª©ë¡ ë° ìƒíƒœ
        """
        result = {}
        
        for name, config in self.modules.items():
            result[name] = {
                'config': asdict(config),
                'status': self.module_status.get(name, ModuleStatus.REGISTERED).value
            }
        
        return result
    
    def get_startup_order(self) -> List[str]:
        """
        ì‹œì‘ ìˆœì„œì— ë”°ë¥¸ ëª¨ë“ˆ ëª©ë¡ ë°˜í™˜
        
        Returns:
            List[str]: ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ëœ ëª¨ë“ˆ ì´ë¦„ ëª©ë¡
        """
        # auto_startê°€ Trueì¸ ëª¨ë“ˆë§Œ í•„í„°ë§í•˜ê³  ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬
        auto_start_modules = [
            (name, config) for name, config in self.modules.items()
            if config.auto_start
        ]
        
        # ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬ (ë‚®ì€ ìˆ«ìê°€ ë¨¼ì €)
        auto_start_modules.sort(key=lambda x: x[1].priority)
        
        return [name for name, _ in auto_start_modules]
    
    def get_modules_by_dependency_order(self) -> List[str]:
        """
        ì˜ì¡´ì„± ìˆœì„œì— ë”°ë¥¸ ëª¨ë“ˆ ëª©ë¡ ë°˜í™˜ (í† í´ë¡œì§€ ì •ë ¬)
        
        Returns:
            List[str]: ì˜ì¡´ì„± ìˆœì„œë¡œ ì •ë ¬ëœ ëª¨ë“ˆ ì´ë¦„ ëª©ë¡
        """
        try:
            # í† í´ë¡œì§€ ì •ë ¬ì„ ìœ„í•œ ê·¸ë˜í”„ êµ¬ì„±
            in_degree = {name: 0 for name in self.modules.keys()}
            graph = {name: [] for name in self.modules.keys()}
            
            # ì˜ì¡´ì„± ê·¸ë˜í”„ êµ¬ì„±
            for name, config in self.modules.items():
                for dep in config.dependencies:
                    if dep in self.modules:
                        graph[dep].append(name)
in_degree[name]_+ =  1
            
            # í† í´ë¡œì§€ ì •ë ¬
            queue = [name for name, degree in in_degree.items() if degree == 0]
            result = []
            
            while queue:
                current = queue.pop(0)
                result.append(current)
                
                for neighbor in graph[current]:
in_degree[neighbor]_- =  1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)
            
            # ìˆœí™˜ ì˜ì¡´ì„± ê²€ì‚¬
            if len(result) != len(self.modules):
                self.logger.error("âŒ ìˆœí™˜ ì˜ì¡´ì„± ê°ì§€ë¨")
                return list(self.modules.keys())  # ê¸°ë³¸ ìˆœì„œ ë°˜í™˜
            
            return result
            
        except Exception as e:
            self.logger.error(f"âŒ ì˜ì¡´ì„± ì •ë ¬ ì‹¤íŒ¨: {e}")
            return list(self.modules.keys())  # ê¸°ë³¸ ìˆœì„œ ë°˜í™˜
    
    def validate_module_config(self, config: ModuleConfig) -> List[str]:
        """
        ëª¨ë“ˆ ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬
        
        Args:
            config (ModuleConfig): ëª¨ë“ˆ ì„¤ì •
            
        Returns:
            List[str]: ì˜¤ë¥˜ ë©”ì‹œì§€ ëª©ë¡
        """
        errors = []
        
        # í•„ìˆ˜ í•„ë“œ ê²€ì‚¬
        if not config.name:
            errors.append("ëª¨ë“ˆ ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
        
        if not config.script_path:
            errors.append("ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
        
        # ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ì¡´ì¬ í™•ì¸
        if config.script_path and not os.path.exists(config.script_path):
            # ìƒëŒ€ ê²½ë¡œë¡œë„ í™•ì¸
            if not os.path.exists(os.path.join(os.path.dirname(self.config_file), config.script_path)):
                errors.append(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {config.script_path}")
        
        # ì„¤ì •ê°’ ë²”ìœ„ ê²€ì‚¬
        if config.max_restart_attempts < 0:
            errors.append("ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        if config.health_check_interval < 60:
            errors.append("í—¬ìŠ¤ì²´í¬ ê°„ê²©ì€ ìµœì†Œ 60ì´ˆ ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        if config.timeout < 5:
            errors.append("íƒ€ì„ì•„ì›ƒì€ ìµœì†Œ 5ì´ˆ ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        return errors
    
    def _check_dependencies(self, dependencies: List[str]) -> bool:
        """
        ì˜ì¡´ì„± ê²€ì‚¬
        
        Args:
            dependencies (List[str]): ì˜ì¡´ì„± ëª©ë¡
            
        Returns:
            bool: ì˜ì¡´ì„±ì´ ëª¨ë‘ ë§Œì¡±ë˜ë©´ True
        """
        for dep in dependencies:
            if dep not in self.modules:
                self.logger.error(f"âŒ ì˜ì¡´ì„± ëª¨ë“ˆì´ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: {dep}")
                return False
        
        return True
    
    def _find_dependent_modules(self, module_name: str) -> List[str]:
        """
        íŠ¹ì • ëª¨ë“ˆì— ì˜ì¡´í•˜ëŠ” ëª¨ë“ˆë“¤ ì°¾ê¸°
        
        Args:
            module_name (str): ëª¨ë“ˆ ì´ë¦„
            
        Returns:
            List[str]: ì˜ì¡´í•˜ëŠ” ëª¨ë“ˆ ëª©ë¡
        """
        dependent_modules = []
        
        for name, config in self.modules.items():
            if module_name in config.dependencies:
                dependent_modules.append(name)
        
        return dependent_modules
    
    def update_module_status(self, name: str, status: ModuleStatus):
        """
        ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
        
        Args:
            name (str): ëª¨ë“ˆ ì´ë¦„
            status (ModuleStatus): ìƒˆë¡œìš´ ìƒíƒœ
        """
        if name in self.modules:
            self.module_status[name] = status
            self.logger.debug(f"ğŸ“Š ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸: {name} -> {status.value}")
    
    def get_module_status(self, name: str) -> Optional[ModuleStatus]:
        """
        ëª¨ë“ˆ ìƒíƒœ ì¡°íšŒ
        
        Args:
            name (str): ëª¨ë“ˆ ì´ë¦„
            
        Returns:
            Optional[ModuleStatus]: ëª¨ë“ˆ ìƒíƒœ
        """
        return self.module_status.get(name)
    
    def reload_config(self) -> bool:
        """
        ì„¤ì • íŒŒì¼ ë‹¤ì‹œ ë¡œë“œ
        
        Returns:
            bool: ë¡œë“œ ì„±ê³µ ì—¬ë¶€
        """
        try:
            # ê¸°ì¡´ ì„¤ì • ë°±ì—…
            old_modules = self.modules.copy()
            old_status = self.module_status.copy()
            
            # ì„¤ì • ì´ˆê¸°í™”
            self.modules.clear()
            self.module_status.clear()
            
            # ìƒˆ ì„¤ì • ë¡œë“œ
            if self.load_config():
                self.logger.info("âœ… ì„¤ì • íŒŒì¼ ë‹¤ì‹œ ë¡œë“œ ì™„ë£Œ")
                return True
            else:
                # ë¡œë“œ ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ì„¤ì • ë³µì›
                self.modules = old_modules
                self.module_status = old_status
                self.logger.error("âŒ ì„¤ì • íŒŒì¼ ë‹¤ì‹œ ë¡œë“œ ì‹¤íŒ¨, ê¸°ì¡´ ì„¤ì • ë³µì›")
                return False
                
        except Exception as e:
            self.logger.error(f"âŒ ì„¤ì • íŒŒì¼ ë‹¤ì‹œ ë¡œë“œ ì˜¤ë¥˜: {e}")
            return False
    
    def export_config(self, export_path: str) -> bool:
        """
        ì„¤ì •ì„ ë‹¤ë¥¸ íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°
        
        Args:
            export_path (str): ë‚´ë³´ë‚¼ íŒŒì¼ ê²½ë¡œ
            
        Returns:
            bool: ë‚´ë³´ë‚´ê¸° ì„±ê³µ ì—¬ë¶€
        """
        try:
            # í˜„ì¬ ì„¤ì • íŒŒì¼ì„ ì§€ì •ëœ ê²½ë¡œë¡œ ë³µì‚¬
# BROKEN_REF:             import shutil
            shutil.copy2(self.config_file, export_path)
            
            self.logger.info(f"âœ… ì„¤ì • ë‚´ë³´ë‚´ê¸° ì™„ë£Œ: {export_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ ì„¤ì • ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: {e}")
            return False