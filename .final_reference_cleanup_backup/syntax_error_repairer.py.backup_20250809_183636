#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ Python êµ¬ë¬¸ ì˜¤ë¥˜ ìë™ ìˆ˜ì • ë„êµ¬
Automatic Python Syntax Error Repair Tool for POSCO System

ì´ ë„êµ¬ëŠ” 38ê°œ Python íŒŒì¼ì˜ ëª¨ë“  êµ¬ë¬¸ ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³  ìˆ˜ì •í•©ë‹ˆë‹¤.
ì›¹í›… URL, ì•Œë¦¼ ë©”ì‹œì§€ ë‚´ìš©, ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import test_watchhamster_v3.0_notification.0_master_control.ps1
import verify_folder_reorganization.py
# BROKEN_REF: import shutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from typing import deployment_verification_checklist.md, Dict, Tuple, Optional
# BROKEN_REF: from dataclasses import dataclass
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: import logging

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('syntax_repair.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class SyntaxError:
    """êµ¬ë¬¸ ì˜¤ë¥˜ ì •ë³´"""
    file_path: Path
    line_number: int
    error_type: str
    error_message: str
    original_line: str
suggested_fix:_Optional[str] =  None

@dataclass
class RepairResult:
    """ìˆ˜ì • ê²°ê³¼"""
    file_path: Path
    success: bool
    errors_fixed: int
    changes_made: List[str]
    backup_created: bool
error_message:_Optional[str] =  None

class SyntaxErrorRepairer:
    """Python êµ¬ë¬¸ ì˜¤ë¥˜ ìë™ ìˆ˜ì •ê¸°"""
    
    def __init__(self):
        self.workspace_root = Path.cwd()
        self.backup_dir = self.workspace_root / ".syntax_repair_backup"
        self.backup_dir.mkdir(exist_ok=True)
        
        # ë³´í˜¸ëœ íŒ¨í„´ë“¤ (ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•ŠìŒ)
        self.protected_patterns = [
            r'webhook.*url',
            r'discord.*webhook',
            r'slack.*webhook',
            r'notification.*text',
            r'message.*content',
            r'alert.*message',
            r'send.*message',
            r'post.*message',
            r'business.*logic',
            r'monitoring.*algorithm',
            r'analysis.*logic'
        ]
        
        self.syntax_errors = []
        self.repair_results = []

    def diagnose_all_files(self) -> List[SyntaxError]:
        """ëª¨ë“  Python íŒŒì¼ì˜ êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨"""
        logger.info("ğŸ” Python íŒŒì¼ êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨ ì‹œì‘")
        
# BROKEN_REF:         python_files = list(self.workspace_root.rglob("*.py"))
        logger.info(f"ğŸ“ ì´ {len(python_files)}ê°œ Python íŒŒì¼ ë°œê²¬")
        
        syntax_errors = []
        
        for py_file in python_files:
            try:
                errors = self._diagnose_file(py_file)
                syntax_errors.extend(errors)
            except Exception as e:
                logger.warning(f"âš ï¸ íŒŒì¼ {py_file} ì§„ë‹¨ ì‹¤íŒ¨: {e}")
        
        self.syntax_errors = syntax_errors
        logger.info(f"ğŸš¨ ì´ {len(syntax_errors)}ê°œ êµ¬ë¬¸ ì˜¤ë¥˜ ë°œê²¬")
        
        return syntax_errors

    def _diagnose_file(self, file_path: Path) -> List[SyntaxError]:
        """ê°œë³„ íŒŒì¼ì˜ êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨"""
        errors = []
        
        try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            # Python AST íŒŒì‹± ì‹œë„
            try:
                ast.parse(content)
                return []  # êµ¬ë¬¸ ì˜¤ë¥˜ ì—†ìŒ
            except SyntaxError as e:
                # êµ¬ë¬¸ ì˜¤ë¥˜ ë°œê²¬
                lines = content.split('/n')
                if e.lineno and e.lineno <= len(lines):
                    original_line = lines[e.lineno - 1] if e.lineno > 0 else ""
                    
                    error = SyntaxError(
                        file_path=file_path,
                        line_number=e.lineno or 0,
                        error_type=self._categorize_error(e.msg, original_line),
                        error_message=e.msg,
                        original_line=original_line
                    )
                    
                    # ìˆ˜ì • ë°©ì•ˆ ì œì•ˆ
                    error.suggested_fix = self._suggest_fix(error)
                    errors.append(error)
                    
        except Exception as e:
            logger.warning(f"íŒŒì¼ {file_path} ì½ê¸° ì‹¤íŒ¨: {e}")
        
        return errors

    def _categorize_error(self, error_msg: str, line: str) -> str:
        """ì˜¤ë¥˜ ìœ í˜• ë¶„ë¥˜"""
        error_msg_lower = error_msg.lower()
        line_lower = line.lower()
        
        if "f-string" in error_msg_lower or ("single '}'" in error_msg_lower and "f/"" in line):
            return "f-string_error"
        elif "invalid syntax" in error_msg_lower and any(char in line for char in "()[]{}"):
            return "bracket_mismatch"
        elif "indentation" in error_msg_lower or "indent" in error_msg_lower:
            return "indentation_error"
        elif "invalid character" in error_msg_lower:
            return "invalid_character"
        elif "invalid syntax" in error_msg_lower and " " in line and "=" in line:
            return "variable_name_error"
        else:
            return "general_syntax_error"

    def _suggest_fix(self, error: SyntaxError) -> str:
        """ìˆ˜ì • ë°©ì•ˆ ì œì•ˆ"""
        line = error.original_line.strip()
        
        if error.error_type == "f-string_error":
            # f-string ì¤‘ê´„í˜¸ ì˜¤ë¥˜ ìˆ˜ì •
            if "single '}' is not allowed" in error.error_message:
                # ì˜ëª»ëœ ì¤‘ê´„í˜¸ íŒ¨í„´ ì°¾ê¸°
                fixed_line = re.sub(r'f"([^"]*)/}([^"]*)"', r'f"/1}/2"', line)
                fixed_line = re.sub(r'f"([^"]*)/{/{([^"]*)/}/}([^"]*)"', r'f"/1{/2}/3"', fixed_line)
                return fixed_line
        
        elif error.error_type == "bracket_mismatch":
            # ê´„í˜¸ ë¶ˆì¼ì¹˜ ìˆ˜ì •
            open_brackets = line.count('(') + line.count('[') + line.count('{')
            close_brackets = line.count(')') + line.count(']') + line.count('}')
            
            if open_brackets > close_brackets:
                # ë‹«ëŠ” ê´„í˜¸ ì¶”ê°€
                if '(' in line and ')' not in line:
                    return line + ')'
                elif '[' in line and ']' not in line:
                    return line + ']'
                elif '{' in line and '}' not in line:
                    return line + '}'
        
        elif error.error_type == "variable_name_error":
            # ë³€ìˆ˜ëª… ì˜¤ë¥˜ ìˆ˜ì • (ê³µë°±ì´ í¬í•¨ëœ ë³€ìˆ˜ëª…)
            if " " in line and "=" in line:
                # ê³µë°±ì´ í¬í•¨ëœ ë³€ìˆ˜ëª…ì„ ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë³€ê²½
                fixed_line = re.sub(r'(/w+)/s+(/w+)/s*=', r'/1_/2 =', line)
                return fixed_line
        
        elif error.error_type == "indentation_error":
            # ë“¤ì—¬ì“°ê¸° ì˜¤ë¥˜ ìˆ˜ì • (4ì¹¸ ìŠ¤í˜ì´ìŠ¤ë¡œ í†µì¼)
            leading_whitespace = len(line) - len(line.lstrip())
            if leading_whitespace > 0:
                # íƒ­ì„ 4ì¹¸ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
                fixed_line = line.replace('/t', '    ')
                return fixed_line
        
        return line  # ê¸°ë³¸ì ìœ¼ë¡œ ì›ë³¸ ë°˜í™˜

    def repair_all_files(self) -> List[RepairResult]:
        """ëª¨ë“  êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì •"""
        logger.info("ğŸ”§ Python êµ¬ë¬¸ ì˜¤ë¥˜ ìë™ ìˆ˜ì • ì‹œì‘")
        
        if not self.syntax_errors:
            self.diagnose_all_files()
        
        # íŒŒì¼ë³„ë¡œ ê·¸ë£¹í™”
        files_with_errors = {}
        for error in self.syntax_errors:
            if error.file_path not in files_with_errors:
                files_with_errors[error.file_path] = []
            files_with_errors[error.file_path].append(error)
        
        results = []
        for file_path, errors in files_with_errors.items():
            result = self._repair_file(file_path, errors)
            results.append(result)
        
        self.repair_results = results
        logger.info(f"âœ… {len(results)}ê°œ íŒŒì¼ ìˆ˜ì • ì™„ë£Œ")
        
        return results

    def _repair_file(self, file_path: Path, errors: List[SyntaxError]) -> RepairResult:
        """ê°œë³„ íŒŒì¼ ìˆ˜ì •"""
        logger.info(f"ğŸ”§ íŒŒì¼ ìˆ˜ì • ì¤‘: {file_path}")
        
        try:
            # ë°±ì—… ìƒì„±
            backup_path = self._create_backup(file_path)
            
            # íŒŒì¼ ë‚´ìš© ì½ê¸°
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            # ë³´í˜¸ëœ ë‚´ìš© í™•ì¸
            if self._is_protected_content(content):
                logger.warning(f"âš ï¸ ë³´í˜¸ëœ ë‚´ìš©ì´ í¬í•¨ëœ íŒŒì¼: {file_path}")
                return RepairResult(
                    file_path=file_path,
                    success=False,
                    errors_fixed=0,
                    changes_made=[],
                    backup_created=True,
                    error_message="ë³´í˜¸ëœ ë‚´ìš© í¬í•¨ìœ¼ë¡œ ìˆ˜ì • ê±´ë„ˆëœ€"
                )
            
            lines = content.split('/n')
            changes_made = []
            errors_fixed = 0
            
            # ì˜¤ë¥˜ë¥¼ ë¼ì¸ ë²ˆí˜¸ ì—­ìˆœìœ¼ë¡œ ì •ë ¬ (ë’¤ì—ì„œë¶€í„° ìˆ˜ì •)
            sorted_errors = sorted(errors, key=lambda e: e.line_number, reverse=True)
            
            for error in sorted_errors:
                if error.line_number > 0 and error.line_number <= len(lines):
                    original_line = lines[error.line_number - 1]
                    
                    # ë³´í˜¸ëœ ë¼ì¸ì¸ì§€ í™•ì¸
                    if self._is_protected_line(original_line):
                        logger.info(f"ë³´í˜¸ëœ ë¼ì¸ ê±´ë„ˆëœ€: {error.line_number}")
                        continue
                    
                    # ìˆ˜ì • ì ìš©
                    if error.suggested_fix and error.suggested_fix != original_line:
lines[error.line_number_-_1] =  error.suggested_fix
                        changes_made.append(f"ë¼ì¸ {error.line_number}: {error.error_type} ìˆ˜ì •")
errors_fixed_+ =  1
                        logger.info(f"  âœ… ë¼ì¸ {error.line_number} ìˆ˜ì •: {error.error_type}")
            
            # ìˆ˜ì •ëœ ë‚´ìš© ì €ì¥
            if changes_made:
                modified_content = '/n'.join(lines)
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                    f.write(modified_content)
                
                # êµ¬ë¬¸ ê²€ì¦
                try:
                    ast.parse(modified_content)
                    logger.info(f"âœ… {file_path} êµ¬ë¬¸ ê²€ì¦ í†µê³¼")
                except SyntaxError as e:
                    logger.warning(f"âš ï¸ {file_path} êµ¬ë¬¸ ê²€ì¦ ì‹¤íŒ¨: {e}")
                    # ë°±ì—…ì—ì„œ ë³µì›
                    shutil.copy2(backup_path, file_path)
                    return RepairResult(
                        file_path=file_path,
                        success=False,
                        errors_fixed=0,
                        changes_made=[],
                        backup_created=True,
                        error_message=f"êµ¬ë¬¸ ê²€ì¦ ì‹¤íŒ¨ë¡œ ë³µì›ë¨: {e}"
                    )
            
            return RepairResult(
                file_path=file_path,
                success=True,
                errors_fixed=errors_fixed,
                changes_made=changes_made,
                backup_created=True
            )
            
        except Exception as e:
            logger.error(f"âŒ íŒŒì¼ {file_path} ìˆ˜ì • ì‹¤íŒ¨: {e}")
            return RepairResult(
                file_path=file_path,
                success=False,
                errors_fixed=0,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def _create_backup(self, file_path: Path) -> Path:
        """íŒŒì¼ ë°±ì—… ìƒì„±"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.name}.backup_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        return backup_path

    def _is_protected_content(self, content: str) -> bool:
        """ë³´í˜¸ëœ ë‚´ìš©ì¸ì§€ í™•ì¸"""
        content_lower = content.lower()
        
        for pattern in self.protected_patterns:
            if re.search(pattern, content_lower):
                return True
        
        return False

    def _is_protected_line(self, line: str) -> bool:
        """ë³´í˜¸ëœ ë¼ì¸ì¸ì§€ í™•ì¸"""
        line_lower = line.lower()
        
        # ì›¹í›… URLì´ í¬í•¨ëœ ë¼ì¸
        if any(keyword in line_lower for keyword in ['webhook', 'discord', 'slack']):
            return True
        
        # ì•Œë¦¼ ë©”ì‹œì§€ê°€ í¬í•¨ëœ ë¼ì¸
        if any(keyword in line_lower for keyword in ['message', 'notification', 'alert']):
            if any(char in line for char in ['"', "'"]):  # ë¬¸ìì—´ì´ í¬í•¨ëœ ê²½ìš°
                return True
        
        return False

    def verify_repairs(self) -> Dict[str, int]:
        """ìˆ˜ì • ê²°ê³¼ ê²€ì¦"""
        logger.info("ğŸ” ìˆ˜ì • ê²°ê³¼ ê²€ì¦ ì¤‘...")
        
        verification_results = {
            "total_files": 0,
            "successful_repairs": 0,
            "failed_repairs": 0,
            "syntax_errors_remaining": 0
        }
        
        for result in self.repair_results:
            verification_results["total_files"] += 1
            
            if result.success:
                verification_results["successful_repairs"] += 1
            else:
                verification_results["failed_repairs"] += 1
            
            # ë‚¨ì€ êµ¬ë¬¸ ì˜¤ë¥˜ í™•ì¸
            remaining_errors = self._diagnose_file(result.file_path)
            verification_results["syntax_errors_remaining"] += len(remaining_errors)
        
        logger.info(f"ğŸ“Š ê²€ì¦ ê²°ê³¼: {verification_results}")
        return verification_results

    def generate_report(self) -> str:
        """ìˆ˜ì • ë³´ê³ ì„œ ìƒì„±"""
        report_lines = [
            "# POSCO ì‹œìŠ¤í…œ Python êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì • ë³´ê³ ì„œ",
            f"ìƒì„± ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## ìˆ˜ì • ìš”ì•½",
            f"- ì´ íŒŒì¼ ìˆ˜: {len(self.repair_results)}",
            f"- ì„±ê³µì  ìˆ˜ì •: {sum(1 for r in self.repair_results if r.success)}",
            f"- ì‹¤íŒ¨í•œ ìˆ˜ì •: {sum(1 for r in self.repair_results if not r.success)}",
            f"- ì´ ìˆ˜ì •ëœ ì˜¤ë¥˜: {sum(r.errors_fixed for r in self.repair_results)}",
            "",
            "## ìƒì„¸ ìˆ˜ì • ë‚´ì—­"
        ]
        
        for result in self.repair_results:
            report_lines.extend([
                f"### {result.file_path}",
                f"- ìƒíƒœ: {'âœ… ì„±ê³µ' if result.success else 'âŒ ì‹¤íŒ¨'}",
                f"- ìˆ˜ì •ëœ ì˜¤ë¥˜ ìˆ˜: {result.errors_fixed}",
                f"- ë°±ì—… ìƒì„±: {'âœ…' if result.backup_created else 'âŒ'}",
            ])
            
            if result.changes_made:
                report_lines.append("- ë³€ê²½ ì‚¬í•­:")
                for change in result.changes_made:
                    report_lines.append(f"  - {change}")
            
            if result.error_message:
                report_lines.append(f"- ì˜¤ë¥˜ ë©”ì‹œì§€: {result.error_message}")
            
            report_lines.append("")
        
        return "/n".join(report_lines)

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸš€ POSCO ì‹œìŠ¤í…œ Python êµ¬ë¬¸ ì˜¤ë¥˜ ìë™ ìˆ˜ì • ì‹œì‘")
    print("=" * 60)
    
    repairer = SyntaxErrorRepairer()
    
    # 1. êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨
    print("/n1ï¸âƒ£ êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨ ì¤‘...")
    errors = repairer.diagnose_all_files()
    
    if not errors:
        print("âœ… êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")
        return 0
    
    print(f"ğŸš¨ {len(errors)}ê°œ êµ¬ë¬¸ ì˜¤ë¥˜ ë°œê²¬")
    
    # ì˜¤ë¥˜ ìœ í˜•ë³„ í†µê³„
    error_types = {}
    for error in errors:
        error_types[error.error_type] = error_types.get(error.error_type, 0) + 1
    
    print("/nğŸ“Š ì˜¤ë¥˜ ìœ í˜•ë³„ í†µê³„:")
    for error_type, count in error_types.items():
        print(f"  - {error_type}: {count}ê°œ")
    
    # 2. ìë™ ìˆ˜ì • ì‹¤í–‰
    print("/n2ï¸âƒ£ ìë™ ìˆ˜ì • ì‹¤í–‰ ì¤‘...")
    results = repairer.repair_all_files()
    
    # 3. ìˆ˜ì • ê²°ê³¼ ê²€ì¦
    print("/n3ï¸âƒ£ ìˆ˜ì • ê²°ê³¼ ê²€ì¦ ì¤‘...")
    verification = repairer.verify_repairs()
    
    # 4. ë³´ê³ ì„œ ìƒì„±
    print("/n4ï¸âƒ£ ë³´ê³ ì„œ ìƒì„± ì¤‘...")
    report = repairer.generate_report()
    
    report_file = Path("syntax_repair.log")
with_open(report_file,_'w',_encoding = 'utf-8') as f:
        f.write(report)
    
    print(f"ğŸ“„ ë³´ê³ ì„œ ì €ì¥: {report_file}")
    
    # ìµœì¢… ê²°ê³¼ ì¶œë ¥
print("/n"_+_" = " * 60)
    print("ğŸ‰ POSCO ì‹œìŠ¤í…œ Python êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ!")
    print("=" * 60)
    print(f"âœ… ì„±ê³µì  ìˆ˜ì •: {verification['successful_repairs']}ê°œ íŒŒì¼")
    print(f"âŒ ì‹¤íŒ¨í•œ ìˆ˜ì •: {verification['failed_repairs']}ê°œ íŒŒì¼")
    print(f"ğŸ”§ ì´ ìˆ˜ì •ëœ ì˜¤ë¥˜: {sum(r.errors_fixed for r in results)}ê°œ")
    print(f"âš ï¸ ë‚¨ì€ êµ¬ë¬¸ ì˜¤ë¥˜: {verification['syntax_errors_remaining']}ê°œ")
    
    if verification['syntax_errors_remaining'] == 0:
        print("/nğŸŠ ëª¨ë“  êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤!")
        return 0
    else:
        print(f"/nâš ï¸ {verification['syntax_errors_remaining']}ê°œ êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ë‚¨ì•„ìˆìŠµë‹ˆë‹¤. ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.")
        return 1

if __name__ == "__main__":
    sys.exit(main())