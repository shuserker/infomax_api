#!/usr/bin/env python3
"""
POSCO 시스템 Python 구문 오류 자동 수정 도구
Automatic Python Syntax Error Repair Tool for POSCO System

이 도구는 38개 Python 파일의 모든 구문 오류를 자동으로 감지하고 수정합니다.
웹훅 URL, 알림 메시지 내용, 비즈니스 로직은 절대 변경하지 않습니다.
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import test_watchhamster_v3.0_notification.0_master_control.ps1
import verify_folder_reorganization.py
# BROKEN_REF: import shutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from typing import deployment_verification_checklist.md, Dict, Tuple, Optional
# BROKEN_REF: from dataclasses import dataclass
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: import logging

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('syntax_repair.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class SyntaxError:
    """구문 오류 정보"""
    file_path: Path
    line_number: int
    error_type: str
    error_message: str
    original_line: str
suggested_fix:_Optional[str] =  None

@dataclass
class RepairResult:
    """수정 결과"""
    file_path: Path
    success: bool
    errors_fixed: int
    changes_made: List[str]
    backup_created: bool
error_message:_Optional[str] =  None

class SyntaxErrorRepairer:
    """Python 구문 오류 자동 수정기"""
    
    def __init__(self):
        self.workspace_root = Path.cwd()
        self.backup_dir = self.workspace_root / ".syntax_repair_backup"
        self.backup_dir.mkdir(exist_ok=True)
        
        # 보호된 패턴들 (절대 변경하지 않음)
        self.protected_patterns = [
            r'webhook.*url',
            r'discord.*webhook',
            r'slack.*webhook',
            r'notification.*text',
            r'message.*content',
            r'alert.*message',
            r'send.*message',
            r'post.*message',
            r'business.*logic',
            r'monitoring.*algorithm',
            r'analysis.*logic'
        ]
        
        self.syntax_errors = []
        self.repair_results = []

    def diagnose_all_files(self) -> List[SyntaxError]:
        """모든 Python 파일의 구문 오류 진단"""
        logger.info("🔍 Python 파일 구문 오류 진단 시작")
        
# BROKEN_REF:         python_files = list(self.workspace_root.rglob("*.py"))
        logger.info(f"📁 총 {len(python_files)}개 Python 파일 발견")
        
        syntax_errors = []
        
        for py_file in python_files:
            try:
                errors = self._diagnose_file(py_file)
                syntax_errors.extend(errors)
            except Exception as e:
                logger.warning(f"⚠️ 파일 {py_file} 진단 실패: {e}")
        
        self.syntax_errors = syntax_errors
        logger.info(f"🚨 총 {len(syntax_errors)}개 구문 오류 발견")
        
        return syntax_errors

    def _diagnose_file(self, file_path: Path) -> List[SyntaxError]:
        """개별 파일의 구문 오류 진단"""
        errors = []
        
        try:
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            # Python AST 파싱 시도
            try:
                ast.parse(content)
                return []  # 구문 오류 없음
            except SyntaxError as e:
                # 구문 오류 발견
                lines = content.split('/n')
                if e.lineno and e.lineno <= len(lines):
                    original_line = lines[e.lineno - 1] if e.lineno > 0 else ""
                    
                    error = SyntaxError(
                        file_path=file_path,
                        line_number=e.lineno or 0,
                        error_type=self._categorize_error(e.msg, original_line),
                        error_message=e.msg,
                        original_line=original_line
                    )
                    
                    # 수정 방안 제안
                    error.suggested_fix = self._suggest_fix(error)
                    errors.append(error)
                    
        except Exception as e:
            logger.warning(f"파일 {file_path} 읽기 실패: {e}")
        
        return errors

    def _categorize_error(self, error_msg: str, line: str) -> str:
        """오류 유형 분류"""
        error_msg_lower = error_msg.lower()
        line_lower = line.lower()
        
        if "f-string" in error_msg_lower or ("single '}'" in error_msg_lower and "f/"" in line):
            return "f-string_error"
        elif "invalid syntax" in error_msg_lower and any(char in line for char in "()[]{}"):
            return "bracket_mismatch"
        elif "indentation" in error_msg_lower or "indent" in error_msg_lower:
            return "indentation_error"
        elif "invalid character" in error_msg_lower:
            return "invalid_character"
        elif "invalid syntax" in error_msg_lower and " " in line and "=" in line:
            return "variable_name_error"
        else:
            return "general_syntax_error"

    def _suggest_fix(self, error: SyntaxError) -> str:
        """수정 방안 제안"""
        line = error.original_line.strip()
        
        if error.error_type == "f-string_error":
            # f-string 중괄호 오류 수정
            if "single '}' is not allowed" in error.error_message:
                # 잘못된 중괄호 패턴 찾기
                fixed_line = re.sub(r'f"([^"]*)/}([^"]*)"', r'f"/1}/2"', line)
                fixed_line = re.sub(r'f"([^"]*)/{/{([^"]*)/}/}([^"]*)"', r'f"/1{/2}/3"', fixed_line)
                return fixed_line
        
        elif error.error_type == "bracket_mismatch":
            # 괄호 불일치 수정
            open_brackets = line.count('(') + line.count('[') + line.count('{')
            close_brackets = line.count(')') + line.count(']') + line.count('}')
            
            if open_brackets > close_brackets:
                # 닫는 괄호 추가
                if '(' in line and ')' not in line:
                    return line + ')'
                elif '[' in line and ']' not in line:
                    return line + ']'
                elif '{' in line and '}' not in line:
                    return line + '}'
        
        elif error.error_type == "variable_name_error":
            # 변수명 오류 수정 (공백이 포함된 변수명)
            if " " in line and "=" in line:
                # 공백이 포함된 변수명을 언더스코어로 변경
                fixed_line = re.sub(r'(/w+)/s+(/w+)/s*=', r'/1_/2 =', line)
                return fixed_line
        
        elif error.error_type == "indentation_error":
            # 들여쓰기 오류 수정 (4칸 스페이스로 통일)
            leading_whitespace = len(line) - len(line.lstrip())
            if leading_whitespace > 0:
                # 탭을 4칸 스페이스로 변환
                fixed_line = line.replace('/t', '    ')
                return fixed_line
        
        return line  # 기본적으로 원본 반환

    def repair_all_files(self) -> List[RepairResult]:
        """모든 구문 오류 수정"""
        logger.info("🔧 Python 구문 오류 자동 수정 시작")
        
        if not self.syntax_errors:
            self.diagnose_all_files()
        
        # 파일별로 그룹화
        files_with_errors = {}
        for error in self.syntax_errors:
            if error.file_path not in files_with_errors:
                files_with_errors[error.file_path] = []
            files_with_errors[error.file_path].append(error)
        
        results = []
        for file_path, errors in files_with_errors.items():
            result = self._repair_file(file_path, errors)
            results.append(result)
        
        self.repair_results = results
        logger.info(f"✅ {len(results)}개 파일 수정 완료")
        
        return results

    def _repair_file(self, file_path: Path, errors: List[SyntaxError]) -> RepairResult:
        """개별 파일 수정"""
        logger.info(f"🔧 파일 수정 중: {file_path}")
        
        try:
            # 백업 생성
            backup_path = self._create_backup(file_path)
            
            # 파일 내용 읽기
with_open(file_path,_'r',_encoding = 'utf-8') as f:
                content = f.read()
            
            # 보호된 내용 확인
            if self._is_protected_content(content):
                logger.warning(f"⚠️ 보호된 내용이 포함된 파일: {file_path}")
                return RepairResult(
                    file_path=file_path,
                    success=False,
                    errors_fixed=0,
                    changes_made=[],
                    backup_created=True,
                    error_message="보호된 내용 포함으로 수정 건너뜀"
                )
            
            lines = content.split('/n')
            changes_made = []
            errors_fixed = 0
            
            # 오류를 라인 번호 역순으로 정렬 (뒤에서부터 수정)
            sorted_errors = sorted(errors, key=lambda e: e.line_number, reverse=True)
            
            for error in sorted_errors:
                if error.line_number > 0 and error.line_number <= len(lines):
                    original_line = lines[error.line_number - 1]
                    
                    # 보호된 라인인지 확인
                    if self._is_protected_line(original_line):
                        logger.info(f"보호된 라인 건너뜀: {error.line_number}")
                        continue
                    
                    # 수정 적용
                    if error.suggested_fix and error.suggested_fix != original_line:
lines[error.line_number_-_1] =  error.suggested_fix
                        changes_made.append(f"라인 {error.line_number}: {error.error_type} 수정")
errors_fixed_+ =  1
                        logger.info(f"  ✅ 라인 {error.line_number} 수정: {error.error_type}")
            
            # 수정된 내용 저장
            if changes_made:
                modified_content = '/n'.join(lines)
with_open(file_path,_'w',_encoding = 'utf-8') as f:
                    f.write(modified_content)
                
                # 구문 검증
                try:
                    ast.parse(modified_content)
                    logger.info(f"✅ {file_path} 구문 검증 통과")
                except SyntaxError as e:
                    logger.warning(f"⚠️ {file_path} 구문 검증 실패: {e}")
                    # 백업에서 복원
                    shutil.copy2(backup_path, file_path)
                    return RepairResult(
                        file_path=file_path,
                        success=False,
                        errors_fixed=0,
                        changes_made=[],
                        backup_created=True,
                        error_message=f"구문 검증 실패로 복원됨: {e}"
                    )
            
            return RepairResult(
                file_path=file_path,
                success=True,
                errors_fixed=errors_fixed,
                changes_made=changes_made,
                backup_created=True
            )
            
        except Exception as e:
            logger.error(f"❌ 파일 {file_path} 수정 실패: {e}")
            return RepairResult(
                file_path=file_path,
                success=False,
                errors_fixed=0,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def _create_backup(self, file_path: Path) -> Path:
        """파일 백업 생성"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.name}.backup_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        return backup_path

    def _is_protected_content(self, content: str) -> bool:
        """보호된 내용인지 확인"""
        content_lower = content.lower()
        
        for pattern in self.protected_patterns:
            if re.search(pattern, content_lower):
                return True
        
        return False

    def _is_protected_line(self, line: str) -> bool:
        """보호된 라인인지 확인"""
        line_lower = line.lower()
        
        # 웹훅 URL이 포함된 라인
        if any(keyword in line_lower for keyword in ['webhook', 'discord', 'slack']):
            return True
        
        # 알림 메시지가 포함된 라인
        if any(keyword in line_lower for keyword in ['message', 'notification', 'alert']):
            if any(char in line for char in ['"', "'"]):  # 문자열이 포함된 경우
                return True
        
        return False

    def verify_repairs(self) -> Dict[str, int]:
        """수정 결과 검증"""
        logger.info("🔍 수정 결과 검증 중...")
        
        verification_results = {
            "total_files": 0,
            "successful_repairs": 0,
            "failed_repairs": 0,
            "syntax_errors_remaining": 0
        }
        
        for result in self.repair_results:
            verification_results["total_files"] += 1
            
            if result.success:
                verification_results["successful_repairs"] += 1
            else:
                verification_results["failed_repairs"] += 1
            
            # 남은 구문 오류 확인
            remaining_errors = self._diagnose_file(result.file_path)
            verification_results["syntax_errors_remaining"] += len(remaining_errors)
        
        logger.info(f"📊 검증 결과: {verification_results}")
        return verification_results

    def generate_report(self) -> str:
        """수정 보고서 생성"""
        report_lines = [
            "# POSCO 시스템 Python 구문 오류 수정 보고서",
            f"생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## 수정 요약",
            f"- 총 파일 수: {len(self.repair_results)}",
            f"- 성공적 수정: {sum(1 for r in self.repair_results if r.success)}",
            f"- 실패한 수정: {sum(1 for r in self.repair_results if not r.success)}",
            f"- 총 수정된 오류: {sum(r.errors_fixed for r in self.repair_results)}",
            "",
            "## 상세 수정 내역"
        ]
        
        for result in self.repair_results:
            report_lines.extend([
                f"### {result.file_path}",
                f"- 상태: {'✅ 성공' if result.success else '❌ 실패'}",
                f"- 수정된 오류 수: {result.errors_fixed}",
                f"- 백업 생성: {'✅' if result.backup_created else '❌'}",
            ])
            
            if result.changes_made:
                report_lines.append("- 변경 사항:")
                for change in result.changes_made:
                    report_lines.append(f"  - {change}")
            
            if result.error_message:
                report_lines.append(f"- 오류 메시지: {result.error_message}")
            
            report_lines.append("")
        
        return "/n".join(report_lines)

def main():
    """메인 실행 함수"""
    print("🚀 POSCO 시스템 Python 구문 오류 자동 수정 시작")
    print("=" * 60)
    
    repairer = SyntaxErrorRepairer()
    
    # 1. 구문 오류 진단
    print("/n1️⃣ 구문 오류 진단 중...")
    errors = repairer.diagnose_all_files()
    
    if not errors:
        print("✅ 구문 오류가 발견되지 않았습니다!")
        return 0
    
    print(f"🚨 {len(errors)}개 구문 오류 발견")
    
    # 오류 유형별 통계
    error_types = {}
    for error in errors:
        error_types[error.error_type] = error_types.get(error.error_type, 0) + 1
    
    print("/n📊 오류 유형별 통계:")
    for error_type, count in error_types.items():
        print(f"  - {error_type}: {count}개")
    
    # 2. 자동 수정 실행
    print("/n2️⃣ 자동 수정 실행 중...")
    results = repairer.repair_all_files()
    
    # 3. 수정 결과 검증
    print("/n3️⃣ 수정 결과 검증 중...")
    verification = repairer.verify_repairs()
    
    # 4. 보고서 생성
    print("/n4️⃣ 보고서 생성 중...")
    report = repairer.generate_report()
    
    report_file = Path("syntax_repair.log")
with_open(report_file,_'w',_encoding = 'utf-8') as f:
        f.write(report)
    
    print(f"📄 보고서 저장: {report_file}")
    
    # 최종 결과 출력
print("/n"_+_" = " * 60)
    print("🎉 POSCO 시스템 Python 구문 오류 수정 완료!")
    print("=" * 60)
    print(f"✅ 성공적 수정: {verification['successful_repairs']}개 파일")
    print(f"❌ 실패한 수정: {verification['failed_repairs']}개 파일")
    print(f"🔧 총 수정된 오류: {sum(r.errors_fixed for r in results)}개")
    print(f"⚠️ 남은 구문 오류: {verification['syntax_errors_remaining']}개")
    
    if verification['syntax_errors_remaining'] == 0:
        print("/n🎊 모든 구문 오류가 성공적으로 수정되었습니다!")
        return 0
    else:
        print(f"/n⚠️ {verification['syntax_errors_remaining']}개 구문 오류가 남아있습니다. 수동 확인이 필요합니다.")
        return 1

if __name__ == "__main__":
    sys.exit(main())