#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test Process Lifecycle
POSCO ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
# BROKEN_REF: import subprocess
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
# BROKEN_REF: import signal
# BROKEN_REF: import psutil
import test_config.json
# BROKEN_REF: from datetime import datetime
# BROKEN_REF: import tempfile
# BROKEN_REF: import shutil

class WatchHamster v3.00ProcessLifecycleTester:
    """í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤í„°"""
    
    def __init__(self):
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        self.test_results = []
        
    def cleanup(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        # ëª¨ë“  í…ŒìŠ¤íŠ¸ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=5)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        # ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_test_script(self, script_name, behavior='normal'):
        """í…ŒìŠ¤íŠ¸ìš© ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        script_path = os.path.join(self.test_dir, script_name)
        
        if behavior == 'normal':
            content = '''#!/usr/bin/env python3
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
import system_functionality_verification.py
# BROKEN_REF: import signal
import test_config.json
# BROKEN_REF: from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] Process {script_name} terminated gracefully")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] Test process {script_name} started (PID: {os.getpid()})")

try:
    counter = 0
    while True:
        time.sleep(2)
counter_+ =  1
        print(f"[{datetime.now()}] {script_name} running... (count: {counter})")
        
        # ìƒíƒœ íŒŒì¼ ìƒì„±
        status = {
            "pid": os.getpid(),
            "status": "running",
            "counter": counter,
            "timestamp": datetime.now().isoformat()
        }
        with open(f"{script_name}.status", "w") as f:
            json.dump(status, f)
            
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif behavior == 'crash':
            content = '''#!/usr/bin/env python3
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
import system_functionality_verification.py
import posco_news_250808_monitor.log
# BROKEN_REF: from datetime import datetime

print(f"[{datetime.now()}] Crash test process {script_name} started (PID: {os.getpid()})")

# 5ì´ˆ í›„ í¬ë˜ì‹œ
time.sleep(5)
print(f"[{datetime.now()}] {script_name} simulating crash...")
sys.exit(1)  # ë¹„ì •ìƒ ì¢…ë£Œ
'''.replace('script_name', f'"{script_name}"')
        
        elif behavior == 'hang':
            content = '''#!/usr/bin/env python3
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
import system_functionality_verification.py
import posco_news_250808_monitor.log
# BROKEN_REF: from datetime import datetime

print(f"[{datetime.now()}] Hang test process {script_name} started (PID: {os.getpid()})")

# 3ì´ˆ í›„ ë¬´í•œ ëŒ€ê¸° (ì‘ë‹µ ì—†ìŒ)
time.sleep(3)
print(f"[{datetime.now()}] {script_name} entering hang state...")
while True:
    time.sleep(60)  # ë¬´í•œ ëŒ€ê¸°
'''.replace('script_name', f'"{script_name}"')
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_normal_lifecycle(self):
        """ì •ìƒ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ì •ìƒ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        
        try:
            # í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
# BROKEN_REF:             script_path = self.create_test_script('system_functionality_verification.py', 'normal')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, script_path
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE, 
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # ì‹œì‘ í™•ì¸
            time.sleep(3)
            if process.poll() is not None:
                raise Exception("í”„ë¡œì„¸ìŠ¤ê°€ ì˜ˆìƒì¹˜ ëª»í•˜ê²Œ ì¢…ë£Œë¨")
            
            pid = process.pid
            if not psutil.pid_exists(pid):
                raise Exception("í”„ë¡œì„¸ìŠ¤ PIDê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ")
            
            print(f"âœ… í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì„±ê³µ (PID: {pid})")
            
            # ìƒíƒœ íŒŒì¼ í™•ì¸
            status_file = os.path.join(self.test_dir, 'normal_test.py.status')
            time.sleep(3)
            
            if os.path.exists(status_file):
                with open(status_file, 'r') as f:
                    status = json.load(f)
print(f"âœ…_ìƒíƒœ_íŒŒì¼_ìƒì„±_í™•ì¸:_counter = {status.get('counter', 0)}")
            
            # ì •ìƒ ì¢…ë£Œ
            process.terminate()
            exit_code = process.wait(timeout=10)
            
            if exit_code == 0:
                print("âœ… í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ ì™„ë£Œ")
                self.test_results.append(("normal_lifecycle", True, "ì •ìƒ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ì„±ê³µ"))
            else:
                raise Exception(f"ë¹„ì •ìƒ ì¢…ë£Œ ì½”ë“œ: {exit_code}")
                
        except Exception as e:
            print(f"âŒ ì •ìƒ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
            self.test_results.append(("normal_lifecycle", False, str(e)))
    
    def test_crash_recovery(self):
        """í¬ë˜ì‹œ ë³µêµ¬ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª í¬ë˜ì‹œ ë³µêµ¬ í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        
        try:
            # í¬ë˜ì‹œ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
# BROKEN_REF:             script_path = self.create_test_script('.comprehensive_repair_backup/historical_data_collector.py.backup_20250809_181656', 'crash')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, script_path
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # í¬ë˜ì‹œ ëŒ€ê¸°
            exit_code = process.wait(timeout=15)
            
            if exit_code != 0:
                print(f"âœ… í”„ë¡œì„¸ìŠ¤ í¬ë˜ì‹œ ê°ì§€ (exit_code: {exit_code})")
                
                # ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜ (ì¬ì‹œì‘)
                print("ğŸ”„ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹œë®¬ë ˆì´ì…˜...")
                
                # ì •ìƒ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì¬ì‹œì‘
# BROKEN_REF:                 normal_script = self.create_test_script('deploy_latest_report.py', 'normal')
                recovered_process = subprocess.Popen([
                    sys.executable, normal_script
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                self.test_processes.append(recovered_process)
                
                # ë³µêµ¬ í™•ì¸
                time.sleep(3)
                if recovered_process.poll() is None:
                    print("âœ… í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì„±ê³µ")
                    self.test_results.append(("crash_recovery", True, "í¬ë˜ì‹œ ë³µêµ¬ í…ŒìŠ¤íŠ¸ ì„±ê³µ"))
                    
                    # ë³µêµ¬ëœ í”„ë¡œì„¸ìŠ¤ ì •ë¦¬
                    recovered_process.terminate()
                    recovered_process.wait(timeout=5)
                else:
                    raise Exception("ë³µêµ¬ëœ í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            else:
                raise Exception("í”„ë¡œì„¸ìŠ¤ê°€ í¬ë˜ì‹œí•˜ì§€ ì•ŠìŒ")
                
        except Exception as e:
            print(f"âŒ í¬ë˜ì‹œ ë³µêµ¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
            self.test_results.append(("crash_recovery", False, str(e)))
    
    def test_multiple_process_management(self):
        """ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        
        try:
            process_count = 3
            processes = []
            
            # ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            for i in range(process_count):
# BROKEN_REF:                 script_path = self.create_test_script(f'multi_test_{i}.py', 'normal')
                process = subprocess.Popen([
                    sys.executable, script_path
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                processes.append(process)
                self.test_processes.append(process)
                time.sleep(1)  # ì‹œì‘ ê°„ê²©
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ í™•ì¸
            time.sleep(3)
            running_count = 0
            for i, process in enumerate(processes):
                if process.poll() is None:
running_count_+ =  1
                    print(f"âœ… í”„ë¡œì„¸ìŠ¤ {i} ì‹¤í–‰ ì¤‘ (PID: {process.pid})")
                else:
                    print(f"âŒ í”„ë¡œì„¸ìŠ¤ {i} ì¢…ë£Œë¨")
            
            if running_count == process_count:
                print(f"âœ… ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì„±ê³µ ({running_count}/{process_count})")
                
                # ìˆœì°¨ì  ì¢…ë£Œ í…ŒìŠ¤íŠ¸
                for i, process in enumerate(processes):
                    if process.poll() is None:
                        process.terminate()
                        exit_code = process.wait(timeout=5)
                        print(f"âœ… í”„ë¡œì„¸ìŠ¤ {i} ì •ìƒ ì¢…ë£Œ (exit_code: {exit_code})")
                
                self.test_results.append(("multiple_process", True, f"ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ì„±ê³µ ({process_count}ê°œ)"))
            else:
                raise Exception(f"ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨ ({running_count}/{process_count})")
                
        except Exception as e:
            print(f"âŒ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
            self.test_results.append(("multiple_process", False, str(e)))
    
    def test_resource_monitoring(self):
        """ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        
        try:
            # í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
# BROKEN_REF:             script_path = self.create_test_script('posco_continuous_monitor.py', 'normal')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, script_path
],_stdout = subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
            time.sleep(3)
            
            if psutil.pid_exists(process.pid):
                ps_process = psutil.Process(process.pid)
                
                # CPU ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì¸¡ì •
                cpu_percent = ps_process.cpu_percent(interval=1)
                memory_info = ps_process.memory_info()
                memory_mb = memory_info.rss / 1024 / 1024
                
                print(f"âœ… ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ê²°ê³¼:")
                print(f"   â€¢ CPU ì‚¬ìš©ë¥ : {cpu_percent:.2f}%")
                print(f"   â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {memory_mb:.2f} MB")
                print(f"   â€¢ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ: {ps_process.status()}")
                
                # ì •ë¦¬
                process.terminate()
                process.wait(timeout=5)
                
                self.test_results.append(("resource_monitoring", True, f"ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì„±ê³µ (CPU: {cpu_percent:.2f}%, MEM: {memory_mb:.2f}MB)"))
            else:
                raise Exception("í”„ë¡œì„¸ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ")
                
        except Exception as e:
            print(f"âŒ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
            self.test_results.append(("resource_monitoring", False, str(e)))
    
    def run_all_tests(self):
        """ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        print("ğŸš€ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œì‘")
        print("=" * 60)
        
        try:
            # ê°œë³„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
            self.test_normal_lifecycle()
            print()
            
            self.test_crash_recovery()
            print()
            
            self.test_multiple_process_management()
            print()
            
            self.test_resource_monitoring()
            print()
            
            # ê²°ê³¼ ìš”ì•½
            print("=" * 60)
            print("ğŸ“Š í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
            print("=" * 60)
            
            total_tests = len(self.test_results)
            passed_tests = sum(1 for _, success, _ in self.test_results if success)
            failed_tests = total_tests - passed_tests
            
            for test_name, success, message in self.test_results:
                status = "âœ… ì„±ê³µ" if success else "âŒ ì‹¤íŒ¨"
                print(f"{status} {test_name}: {message}")
            
            print(f"/nğŸ“ˆ ì´ {total_tests}ê°œ í…ŒìŠ¤íŠ¸ ì¤‘ {passed_tests}ê°œ ì„±ê³µ, {failed_tests}ê°œ ì‹¤íŒ¨")
            
            if failed_tests == 0:
                print("ğŸ‰ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!")
                return True
            else:
                print("âš ï¸ ì¼ë¶€ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
                return False
                
        finally:
            self.cleanup()


def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    tester = ProcessLifecycleTester()
    
    try:
        success = tester.run_all_tests()
        return 0 if success else 1
    except KeyboardInterrupt:
        print("/nâš ï¸ í…ŒìŠ¤íŠ¸ê°€ ì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
        return 1
    except Exception as e:
        print(f"âŒ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return 1
    finally:
        tester.cleanup()


if __name__ == '__main__':
    sys.exit(main())