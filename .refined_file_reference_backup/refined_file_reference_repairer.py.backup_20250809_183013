#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³µêµ¬ ë„êµ¬ (ê°œì„ ëœ ë²„ì „)

ì´ ë„êµ¬ëŠ” ì‹¤ì œ íŒŒì¼ ì°¸ì¡° ë¬¸ì œë§Œì„ ëŒ€ìƒìœ¼ë¡œ í•©ë‹ˆë‹¤:
- ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ìˆ˜ì •
- ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì˜¤ì¸ì‹ ë¬¸ì œ í•´ê²°
- ìƒëŒ€ ê²½ë¡œ ì°¸ì¡° ì •í™•ì„± ê²€ì¦ ë° í‘œì¤€í™”
- Python í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì œì™¸
"""

import os
import re
import json
import shutil
from pathlib import Path
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
import logging

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class BrokenReference:
    """ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ì •ë³´"""
    source_file: str
    referenced_path: str
    line_number: int
    reference_type: str
    context: str
    suggested_fix: Optional[str] = None

@dataclass
class RepairResult:
    """ìˆ˜ë¦¬ ê²°ê³¼ ì •ë³´"""
    file_path: str
    repair_type: str
    success: bool
    changes_made: List[str]
    backup_created: bool
    error_message: Optional[str] = None

class RefinedFileReferenceRepairer:
    """ê°œì„ ëœ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³µêµ¬ í´ëž˜ìŠ¤"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.broken_references: List[BrokenReference] = []
        self.repair_results: List[RepairResult] = []
        self.file_mapping: Dict[str, List[str]] = {}
        self.backup_dir = Path(".refined_file_reference_backup")
        
        # Python í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì œì™¸í•  ëª¨ë“ˆë“¤)
        self.standard_library = {
            'os', 'sys', 'json', 'time', 'datetime', 'pathlib', 'logging', 'unittest',
            'subprocess', 'shutil', 'glob', 'collections', 'itertools', 'functools',
            'typing', 'dataclasses', 'abc', 'contextlib', 'warnings', 'traceback',
            'inspect', 'importlib', 'pkgutil', 'threading', 'multiprocessing',
            'queue', 'socket', 'urllib', 'http', 'email', 'html', 'xml', 'csv',
            'sqlite3', 'hashlib', 'hmac', 'secrets', 'uuid', 'random', 'math',
            'statistics', 'decimal', 'fractions', 'cmath', 'operator', 'copy',
            'pickle', 'copyreg', 'shelve', 'marshal', 'dbm', 'zlib', 'gzip',
            'bz2', 'lzma', 'zipfile', 'tarfile', 'configparser', 'netrc',
            'xdrlib', 'plistlib', 'calendar', 'locale', 'gettext', 'argparse',
            'optparse', 'getopt', 'tempfile', 'glob', 'fnmatch', 'linecache',
            'shlex', 'string', 'textwrap', 'unicodedata', 'stringprep',
            'readline', 'rlcompleter', 'struct', 'codecs', 'encodings',
            'io', 'mmap', 'select', 'selectors', 'asyncio', 'asynchat',
            'asyncore', 'signal', 'msilib', 'msvcrt', 'winreg', 'winsound'
        }
        
        # ì‹¤ì œ íŒŒì¼ ì°¸ì¡° íŒ¨í„´ë§Œ í¬í•¨
        self.file_reference_patterns = {
            'python_file': [
                r'from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import',
                r'import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)',
            ],
            'file_path': [
                r'[\'"]([^\'"\s]+\.(py|sh|bat|json|md|txt|log|command|html|css|js))[\'"]',
                r'Path\([\'"]([^\'"]+)[\'"]',
                r'open\([\'"]([^\'"]+)[\'"]',
                r'with\s+open\([\'"]([^\'"]+)[\'"]'
            ],
            'script_execution': [
                r'python3?\s+([^\s]+\.py)',
                r'bash\s+([^\s]+\.sh)',
                r'\.\/([^\s]+\.(sh|command|bat))',
                r'exec\s+([^\s]+\.(sh|command|bat))'
            ]
        }

    def create_backup(self, file_path: Path) -> bool:
        """íŒŒì¼ ë°±ì—… ìƒì„±"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            backup_path = self.backup_dir / f"{file_path.name}.backup_{self._get_timestamp()}"
            shutil.copy2(file_path, backup_path)
            return True
        except Exception as e:
            logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨ {file_path}: {e}")
            return False

    def _get_timestamp(self) -> str:
        """íƒ€ìž„ìŠ¤íƒ¬í”„ ìƒì„±"""
        from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def build_file_mapping(self):
        """ì‹¤ì œ ì¡´ìž¬í•˜ëŠ” íŒŒì¼ë“¤ì˜ ë§¤í•‘ í…Œì´ë¸” êµ¬ì¶•"""
        logger.info("íŒŒì¼ ë§¤í•‘ í…Œì´ë¸” êµ¬ì¶• ì¤‘...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                filename = file_path.name
                stem = file_path.stem
                relative_path = str(file_path.relative_to(self.root_path))
                
                # íŒŒì¼ëª…ìœ¼ë¡œ ë§¤í•‘
                if filename not in self.file_mapping:
                    self.file_mapping[filename] = []
                self.file_mapping[filename].append(relative_path)
                
                # í™•ìž¥ìž ì—†ëŠ” ì´ë¦„ìœ¼ë¡œë„ ë§¤í•‘ (Python ëª¨ë“ˆìš©)
                if stem != filename and stem not in self.file_mapping:
                    self.file_mapping[stem] = []
                self.file_mapping[stem].append(relative_path)

    def scan_broken_references(self) -> List[BrokenReference]:
        """ì‹¤ì œ ê¹¨ì§„ íŒŒì¼ ì°¸ì¡°ë§Œ ìŠ¤ìº”"""
        logger.info("ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìŠ¤ìº” ì‹œìž‘...")
        
        self.build_file_mapping()
        
        # Python íŒŒì¼ë“¤ë§Œ ìŠ¤ìº”
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            self._scan_python_file(py_file)
        
        # ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ë“¤ ìŠ¤ìº”
        for script_file in self.root_path.rglob("*.sh"):
            if script_file.name.startswith('.'):
                continue
            self._scan_script_file(script_file)
        
        for script_file in self.root_path.rglob("*.bat"):
            if script_file.name.startswith('.'):
                continue
            self._scan_script_file(script_file)
        
        logger.info(f"ì´ {len(self.broken_references)}ê°œì˜ ì‹¤ì œ ê¹¨ì§„ ì°¸ì¡° ë°œê²¬")
        return self.broken_references

    def _scan_python_file(self, file_path: Path):
        """Python íŒŒì¼ì˜ import ë° íŒŒì¼ ì°¸ì¡° ìŠ¤ìº”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # Python ëª¨ë“ˆ import ê²€ì‚¬
                for pattern in self.file_reference_patterns['python_file']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        module_name = match.group(1)
                        if self._is_broken_python_import(module_name, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=module_name,
                                line_number=line_num,
                                reference_type="python_import",
                                context=line.strip(),
                                suggested_fix=self._suggest_python_import_fix(module_name)
                            )
                            self.broken_references.append(broken_ref)
                
                # íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ê²€ì‚¬
                for pattern in self.file_reference_patterns['file_path']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        file_ref = match.group(1)
                        if self._is_broken_file_reference(file_ref, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=file_ref,
                                line_number=line_num,
                                reference_type="file_path",
                                context=line.strip(),
                                suggested_fix=self._suggest_file_path_fix(file_ref)
                            )
                            self.broken_references.append(broken_ref)
                            
        except Exception as e:
            logger.error(f"Python íŒŒì¼ ìŠ¤ìº” ì˜¤ë¥˜ {file_path}: {e}")

    def _scan_script_file(self, file_path: Path):
        """ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì˜ íŒŒì¼ ì°¸ì¡° ìŠ¤ìº”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì°¸ì¡° ê²€ì‚¬
                for pattern in self.file_reference_patterns['script_execution']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        script_ref = match.group(1)
                        if self._is_broken_file_reference(script_ref, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=script_ref,
                                line_number=line_num,
                                reference_type="script_execution",
                                context=line.strip(),
                                suggested_fix=self._suggest_file_path_fix(script_ref)
                            )
                            self.broken_references.append(broken_ref)
                            
        except Exception as e:
            logger.error(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ìŠ¤ìº” ì˜¤ë¥˜ {file_path}: {e}")

    def _is_broken_python_import(self, module_name: str, source_file: Path) -> bool:
        """Python importê°€ ê¹¨ì§„ ê²ƒì¸ì§€ í™•ì¸"""
        # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì œì™¸
        base_module = module_name.split('.')[0]
        if base_module in self.standard_library:
            return False
        
        # ìƒëŒ€ importëŠ” ì œì™¸ (í˜„ìž¬ íŒ¨í‚¤ì§€ ë‚´)
        if module_name.startswith('.'):
            return False
        
        # ì‹¤ì œ íŒŒì¼ì´ ì¡´ìž¬í•˜ëŠ”ì§€ í™•ì¸
        module_file = f"{module_name.replace('.', '/')}.py"
        if (self.root_path / module_file).exists():
            return False
        
        # __init__.pyê°€ ìžˆëŠ” íŒ¨í‚¤ì§€ì¸ì§€ í™•ì¸
        package_init = f"{module_name.replace('.', '/')}/__init__.py"
        if (self.root_path / package_init).exists():
            return False
        
        # íŒŒì¼ ë§¤í•‘ì—ì„œ ì°¾ê¸°
        if module_name in self.file_mapping or base_module in self.file_mapping:
            return False
        
        return True

    def _is_broken_file_reference(self, file_ref: str, source_file: Path) -> bool:
        """íŒŒì¼ ì°¸ì¡°ê°€ ê¹¨ì§„ ê²ƒì¸ì§€ í™•ì¸"""
        # ì ˆëŒ€ ê²½ë¡œ í™•ì¸
        if os.path.isabs(file_ref):
            return not Path(file_ref).exists()
        
        # ìƒëŒ€ ê²½ë¡œ í™•ì¸
        source_dir = source_file.parent
        full_path = source_dir / file_ref
        if full_path.exists():
            return False
        
        # ë£¨íŠ¸ ê¸°ì¤€ ê²½ë¡œ í™•ì¸
        root_path = self.root_path / file_ref
        if root_path.exists():
            return False
        
        # URLì´ë‚˜ íŠ¹ìˆ˜ ê²½ë¡œëŠ” ì œì™¸
        if file_ref.startswith(('http://', 'https://', 'ftp://', 'file://')):
            return False
        
        return True

    def _suggest_python_import_fix(self, module_name: str) -> Optional[str]:
        """Python import ìˆ˜ì • ë°©ì•ˆ ì œì•ˆ"""
        base_module = module_name.split('.')[0]
        
        # ì§ì ‘ ë§¤ì¹­
        if base_module in self.file_mapping:
            candidates = self.file_mapping[base_module]
            if candidates:
                # .py í™•ìž¥ìž ì œê±°í•˜ì—¬ ëª¨ë“ˆëª…ìœ¼ë¡œ ë³€í™˜
                best_candidate = candidates[0]
                if best_candidate.endswith('.py'):
                    return best_candidate[:-3].replace('/', '.')
        
        # ìœ ì‚¬í•œ ì´ë¦„ ì°¾ê¸°
        for mapped_name in self.file_mapping.keys():
            if mapped_name.lower() == base_module.lower() or base_module.lower() in mapped_name.lower():
                candidates = self.file_mapping[mapped_name]
                if candidates and candidates[0].endswith('.py'):
                    return candidates[0][:-3].replace('/', '.')
        
        return None

    def _suggest_file_path_fix(self, file_ref: str) -> Optional[str]:
        """íŒŒì¼ ê²½ë¡œ ìˆ˜ì • ë°©ì•ˆ ì œì•ˆ"""
        filename = Path(file_ref).name
        
        # ì •í™•í•œ íŒŒì¼ëª… ë§¤ì¹­
        if filename in self.file_mapping:
            candidates = self.file_mapping[filename]
            if len(candidates) == 1:
                return candidates[0]
            elif len(candidates) > 1:
                # ê°€ìž¥ ìœ ì‚¬í•œ ê²½ë¡œ ì„ íƒ
                return self._find_best_path_match(file_ref, candidates)
        
        # ìœ ì‚¬í•œ íŒŒì¼ëª… ì°¾ê¸°
        similar_files = self._find_similar_files(filename)
        if similar_files:
            return similar_files[0]
        
        return None

    def _find_similar_files(self, filename: str) -> List[str]:
        """ìœ ì‚¬í•œ íŒŒì¼ëª… ì°¾ê¸°"""
        similar = []
        filename_lower = filename.lower()
        
        for mapped_name, paths in self.file_mapping.items():
            if (mapped_name.lower() in filename_lower or 
                filename_lower in mapped_name.lower() or
                self._calculate_similarity(filename_lower, mapped_name.lower()) > 0.7):
                similar.extend(paths)
        
        return similar[:3]

    def _calculate_similarity(self, str1: str, str2: str) -> float:
        """ë¬¸ìžì—´ ìœ ì‚¬ë„ ê³„ì‚°"""
        if not str1 or not str2:
            return 0.0
        
        # ê°„ë‹¨í•œ Jaccard ìœ ì‚¬ë„
        set1 = set(str1)
        set2 = set(str2)
        intersection = len(set1 & set2)
        union = len(set1 | set2)
        
        return intersection / union if union > 0 else 0.0

    def _find_best_path_match(self, original_path: str, candidates: List[str]) -> str:
        """ê°€ìž¥ ì í•©í•œ ê²½ë¡œ ë§¤ì¹˜ ì°¾ê¸°"""
        original_parts = Path(original_path).parts
        best_score = 0
        best_match = candidates[0]
        
        for candidate in candidates:
            candidate_parts = Path(candidate).parts
            score = len(set(original_parts) & set(candidate_parts))
            if score > best_score:
                best_score = score
                best_match = candidate
        
        return best_match

    def repair_broken_references(self) -> List[RepairResult]:
        """ê¹¨ì§„ ì°¸ì¡° ìˆ˜ë¦¬"""
        logger.info("ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìˆ˜ë¦¬ ì‹œìž‘...")
        
        # íŒŒì¼ë³„ë¡œ ê·¸ë£¹í™”
        files_to_repair = {}
        for ref in self.broken_references:
            if ref.source_file not in files_to_repair:
                files_to_repair[ref.source_file] = []
            files_to_repair[ref.source_file].append(ref)
        
        # ê° íŒŒì¼ ìˆ˜ë¦¬
        for file_path, references in files_to_repair.items():
            result = self._repair_file_references(file_path, references)
            self.repair_results.append(result)
        
        logger.info(f"ì´ {len(self.repair_results)}ê°œ íŒŒì¼ ìˆ˜ë¦¬ ì™„ë£Œ")
        return self.repair_results

    def _repair_file_references(self, file_path: str, references: List[BrokenReference]) -> RepairResult:
        """ê°œë³„ íŒŒì¼ì˜ ì°¸ì¡° ìˆ˜ë¦¬"""
        full_path = self.root_path / file_path
        changes_made = []
        
        try:
            # ë°±ì—… ìƒì„±
            backup_created = self.create_backup(full_path)
            
            # íŒŒì¼ ì½ê¸°
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # ë¼ì¸ë³„ ìˆ˜ì • (ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ë¼ì¸ ë²ˆí˜¸ ë³€ê²½ ë°©ì§€)
            references_sorted = sorted(references, key=lambda x: x.line_number, reverse=True)
            
            for ref in references_sorted:
                if ref.suggested_fix:
                    old_line = lines[ref.line_number - 1]
                    new_line = old_line.replace(ref.referenced_path, ref.suggested_fix)
                    lines[ref.line_number - 1] = new_line
                    changes_made.append(f"Line {ref.line_number}: {ref.referenced_path} â†’ {ref.suggested_fix}")
                else:
                    # ìˆ˜ì • ë°©ì•ˆì´ ì—†ìœ¼ë©´ ì£¼ì„ ì²˜ë¦¬
                    old_line = lines[ref.line_number - 1]
                    if not old_line.strip().startswith('#'):
                        lines[ref.line_number - 1] = f"# BROKEN_REF: {old_line}"
                        changes_made.append(f"Line {ref.line_number}: ì£¼ì„ ì²˜ë¦¬ - {ref.referenced_path}")
            
            # íŒŒì¼ ì“°ê¸°
            if changes_made:
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
            
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=True,
                changes_made=changes_made,
                backup_created=backup_created
            )
            
        except Exception as e:
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=False,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def generate_report(self) -> Dict:
        """ìˆ˜ë¦¬ ë³´ê³ ì„œ ìƒì„±"""
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_broken_references": len(self.broken_references),
                "files_repaired": len(self.repair_results),
                "successful_repairs": len([r for r in self.repair_results if r.success]),
                "failed_repairs": len([r for r in self.repair_results if not r.success])
            },
            "broken_references_by_type": {
                "python_import": len([r for r in self.broken_references if r.reference_type == "python_import"]),
                "file_path": len([r for r in self.broken_references if r.reference_type == "file_path"]),
                "script_execution": len([r for r in self.broken_references if r.reference_type == "script_execution"])
            },
            "broken_references": [
                {
                    "source_file": ref.source_file,
                    "referenced_path": ref.referenced_path,
                    "line_number": ref.line_number,
                    "reference_type": ref.reference_type,
                    "context": ref.context,
                    "suggested_fix": ref.suggested_fix
                }
                for ref in self.broken_references
            ],
            "repair_results": [
                {
                    "file_path": result.file_path,
                    "repair_type": result.repair_type,
                    "success": result.success,
                    "changes_made": result.changes_made,
                    "backup_created": result.backup_created,
                    "error_message": result.error_message
                }
                for result in self.repair_results
            ]
        }
        
        return report

    def save_report(self, report: Dict, filename: str = "refined_file_reference_repair_report.json"):
        """ë³´ê³ ì„œ íŒŒì¼ë¡œ ì €ìž¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"ë³´ê³ ì„œ ì €ìž¥: {filename}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ðŸ”§ POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³µêµ¬ ë„êµ¬ (ê°œì„ ëœ ë²„ì „)")
    print("=" * 60)
    
    repairer = RefinedFileReferenceRepairer()
    
    # 1. ê¹¨ì§„ ì°¸ì¡° ìŠ¤ìº”
    print("\n1ï¸âƒ£ ì‹¤ì œ ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìŠ¤ìº” ì¤‘...")
    broken_refs = repairer.scan_broken_references()
    print(f"   âœ… {len(broken_refs)}ê°œì˜ ì‹¤ì œ ê¹¨ì§„ ì°¸ì¡° ë°œê²¬")
    
    if broken_refs:
        # 2. ì°¸ì¡° ìˆ˜ë¦¬
        print("\n2ï¸âƒ£ ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìˆ˜ë¦¬ ì¤‘...")
        repair_results = repairer.repair_broken_references()
        successful = len([r for r in repair_results if r.success])
        print(f"   âœ… {successful}/{len(repair_results)}ê°œ íŒŒì¼ ìˆ˜ë¦¬ ì™„ë£Œ")
        
        # 3. ë³´ê³ ì„œ ìƒì„±
        print("\n3ï¸âƒ£ ìˆ˜ë¦¬ ë³´ê³ ì„œ ìƒì„± ì¤‘...")
        report = repairer.generate_report()
        repairer.save_report(report)
        print("   âœ… ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ")
        
        # ê²°ê³¼ ìš”ì•½
        print(f"\nðŸ“Š ìˆ˜ë¦¬ ê²°ê³¼ ìš”ì•½:")
        print(f"   â€¢ ë°œê²¬ëœ ê¹¨ì§„ ì°¸ì¡°: {len(broken_refs)}ê°œ")
        print(f"     - Python import: {report['broken_references_by_type']['python_import']}ê°œ")
        print(f"     - íŒŒì¼ ê²½ë¡œ: {report['broken_references_by_type']['file_path']}ê°œ")
        print(f"     - ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰: {report['broken_references_by_type']['script_execution']}ê°œ")
        print(f"   â€¢ ìˆ˜ë¦¬ëœ íŒŒì¼: {successful}ê°œ")
        print(f"   â€¢ ë°±ì—… ë””ë ‰í† ë¦¬: {repairer.backup_dir}")
    else:
        print("   âœ… ê¹¨ì§„ íŒŒì¼ ì°¸ì¡°ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")
    
    return len(broken_refs) == 0 or len([r for r in repairer.repair_results if r.success]) > 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)