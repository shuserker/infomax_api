#!/usr/bin/env python3
"""
POSCO 시스템 파일 참조 무결성 복구 도구 (개선된 버전)

이 도구는 실제 파일 참조 문제만을 대상으로 합니다:
- 존재하지 않는 파일 경로 참조 수정
- 와일드카드 패턴 오인식 문제 해결
- 상대 경로 참조 정확성 검증 및 표준화
- Python 표준 라이브러리는 제외
"""

import os
import re
import json
import shutil
from pathlib import Path
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
import logging

# 로깅 설정
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class BrokenReference:
    """깨진 파일 참조 정보"""
    source_file: str
    referenced_path: str
    line_number: int
    reference_type: str
    context: str
    suggested_fix: Optional[str] = None

@dataclass
class RepairResult:
    """수리 결과 정보"""
    file_path: str
    repair_type: str
    success: bool
    changes_made: List[str]
    backup_created: bool
    error_message: Optional[str] = None

class RefinedFileReferenceRepairer:
    """개선된 파일 참조 무결성 복구 클래스"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.broken_references: List[BrokenReference] = []
        self.repair_results: List[RepairResult] = []
        self.file_mapping: Dict[str, List[str]] = {}
        self.backup_dir = Path(".refined_file_reference_backup")
        
        # Python 표준 라이브러리 (제외할 모듈들)
        self.standard_library = {
            'os', 'sys', 'json', 'time', 'datetime', 'pathlib', 'logging', 'unittest',
            'subprocess', 'shutil', 'glob', 'collections', 'itertools', 'functools',
            'typing', 'dataclasses', 'abc', 'contextlib', 'warnings', 'traceback',
            'inspect', 'importlib', 'pkgutil', 'threading', 'multiprocessing',
            'queue', 'socket', 'urllib', 'http', 'email', 'html', 'xml', 'csv',
            'sqlite3', 'hashlib', 'hmac', 'secrets', 'uuid', 'random', 'math',
            'statistics', 'decimal', 'fractions', 'cmath', 'operator', 'copy',
            'pickle', 'copyreg', 'shelve', 'marshal', 'dbm', 'zlib', 'gzip',
            'bz2', 'lzma', 'zipfile', 'tarfile', 'configparser', 'netrc',
            'xdrlib', 'plistlib', 'calendar', 'locale', 'gettext', 'argparse',
            'optparse', 'getopt', 'tempfile', 'glob', 'fnmatch', 'linecache',
            'shlex', 'string', 'textwrap', 'unicodedata', 'stringprep',
            'readline', 'rlcompleter', 'struct', 'codecs', 'encodings',
            'io', 'mmap', 'select', 'selectors', 'asyncio', 'asynchat',
            'asyncore', 'signal', 'msilib', 'msvcrt', 'winreg', 'winsound'
        }
        
        # 실제 파일 참조 패턴만 포함
        self.file_reference_patterns = {
            'python_file': [
                r'from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import',
                r'import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)',
            ],
            'file_path': [
                r'[\'"]([^\'"\s]+\.(py|sh|bat|json|md|txt|log|command|html|css|js))[\'"]',
                r'Path\([\'"]([^\'"]+)[\'"]',
                r'open\([\'"]([^\'"]+)[\'"]',
                r'with\s+open\([\'"]([^\'"]+)[\'"]'
            ],
            'script_execution': [
                r'python3?\s+([^\s]+\.py)',
                r'bash\s+([^\s]+\.sh)',
                r'\.\/([^\s]+\.(sh|command|bat))',
                r'exec\s+([^\s]+\.(sh|command|bat))'
            ]
        }

    def create_backup(self, file_path: Path) -> bool:
        """파일 백업 생성"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            backup_path = self.backup_dir / f"{file_path.name}.backup_{self._get_timestamp()}"
            shutil.copy2(file_path, backup_path)
            return True
        except Exception as e:
            logger.error(f"백업 생성 실패 {file_path}: {e}")
            return False

    def _get_timestamp(self) -> str:
        """타임스탬프 생성"""
        from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def build_file_mapping(self):
        """실제 존재하는 파일들의 매핑 테이블 구축"""
        logger.info("파일 매핑 테이블 구축 중...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                filename = file_path.name
                stem = file_path.stem
                relative_path = str(file_path.relative_to(self.root_path))
                
                # 파일명으로 매핑
                if filename not in self.file_mapping:
                    self.file_mapping[filename] = []
                self.file_mapping[filename].append(relative_path)
                
                # 확장자 없는 이름으로도 매핑 (Python 모듈용)
                if stem != filename and stem not in self.file_mapping:
                    self.file_mapping[stem] = []
                self.file_mapping[stem].append(relative_path)

    def scan_broken_references(self) -> List[BrokenReference]:
        """실제 깨진 파일 참조만 스캔"""
        logger.info("깨진 파일 참조 스캔 시작...")
        
        self.build_file_mapping()
        
        # Python 파일들만 스캔
        for py_file in self.root_path.rglob("*.py"):
            if py_file.name.startswith('.'):
                continue
            self._scan_python_file(py_file)
        
        # 스크립트 파일들 스캔
        for script_file in self.root_path.rglob("*.sh"):
            if script_file.name.startswith('.'):
                continue
            self._scan_script_file(script_file)
        
        for script_file in self.root_path.rglob("*.bat"):
            if script_file.name.startswith('.'):
                continue
            self._scan_script_file(script_file)
        
        logger.info(f"총 {len(self.broken_references)}개의 실제 깨진 참조 발견")
        return self.broken_references

    def _scan_python_file(self, file_path: Path):
        """Python 파일의 import 및 파일 참조 스캔"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # Python 모듈 import 검사
                for pattern in self.file_reference_patterns['python_file']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        module_name = match.group(1)
                        if self._is_broken_python_import(module_name, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=module_name,
                                line_number=line_num,
                                reference_type="python_import",
                                context=line.strip(),
                                suggested_fix=self._suggest_python_import_fix(module_name)
                            )
                            self.broken_references.append(broken_ref)
                
                # 파일 경로 참조 검사
                for pattern in self.file_reference_patterns['file_path']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        file_ref = match.group(1)
                        if self._is_broken_file_reference(file_ref, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=file_ref,
                                line_number=line_num,
                                reference_type="file_path",
                                context=line.strip(),
                                suggested_fix=self._suggest_file_path_fix(file_ref)
                            )
                            self.broken_references.append(broken_ref)
                            
        except Exception as e:
            logger.error(f"Python 파일 스캔 오류 {file_path}: {e}")

    def _scan_script_file(self, file_path: Path):
        """스크립트 파일의 파일 참조 스캔"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                # 스크립트 실행 참조 검사
                for pattern in self.file_reference_patterns['script_execution']:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        script_ref = match.group(1)
                        if self._is_broken_file_reference(script_ref, file_path):
                            broken_ref = BrokenReference(
                                source_file=str(file_path.relative_to(self.root_path)),
                                referenced_path=script_ref,
                                line_number=line_num,
                                reference_type="script_execution",
                                context=line.strip(),
                                suggested_fix=self._suggest_file_path_fix(script_ref)
                            )
                            self.broken_references.append(broken_ref)
                            
        except Exception as e:
            logger.error(f"스크립트 파일 스캔 오류 {file_path}: {e}")

    def _is_broken_python_import(self, module_name: str, source_file: Path) -> bool:
        """Python import가 깨진 것인지 확인"""
        # 표준 라이브러리는 제외
        base_module = module_name.split('.')[0]
        if base_module in self.standard_library:
            return False
        
        # 상대 import는 제외 (현재 패키지 내)
        if module_name.startswith('.'):
            return False
        
        # 실제 파일이 존재하는지 확인
        module_file = f"{module_name.replace('.', '/')}.py"
        if (self.root_path / module_file).exists():
            return False
        
        # __init__.py가 있는 패키지인지 확인
        package_init = f"{module_name.replace('.', '/')}/__init__.py"
        if (self.root_path / package_init).exists():
            return False
        
        # 파일 매핑에서 찾기
        if module_name in self.file_mapping or base_module in self.file_mapping:
            return False
        
        return True

    def _is_broken_file_reference(self, file_ref: str, source_file: Path) -> bool:
        """파일 참조가 깨진 것인지 확인"""
        # 절대 경로 확인
        if os.path.isabs(file_ref):
            return not Path(file_ref).exists()
        
        # 상대 경로 확인
        source_dir = source_file.parent
        full_path = source_dir / file_ref
        if full_path.exists():
            return False
        
        # 루트 기준 경로 확인
        root_path = self.root_path / file_ref
        if root_path.exists():
            return False
        
        # URL이나 특수 경로는 제외
        if file_ref.startswith(('http://', 'https://', 'ftp://', 'file://')):
            return False
        
        return True

    def _suggest_python_import_fix(self, module_name: str) -> Optional[str]:
        """Python import 수정 방안 제안"""
        base_module = module_name.split('.')[0]
        
        # 직접 매칭
        if base_module in self.file_mapping:
            candidates = self.file_mapping[base_module]
            if candidates:
                # .py 확장자 제거하여 모듈명으로 변환
                best_candidate = candidates[0]
                if best_candidate.endswith('.py'):
                    return best_candidate[:-3].replace('/', '.')
        
        # 유사한 이름 찾기
        for mapped_name in self.file_mapping.keys():
            if mapped_name.lower() == base_module.lower() or base_module.lower() in mapped_name.lower():
                candidates = self.file_mapping[mapped_name]
                if candidates and candidates[0].endswith('.py'):
                    return candidates[0][:-3].replace('/', '.')
        
        return None

    def _suggest_file_path_fix(self, file_ref: str) -> Optional[str]:
        """파일 경로 수정 방안 제안"""
        filename = Path(file_ref).name
        
        # 정확한 파일명 매칭
        if filename in self.file_mapping:
            candidates = self.file_mapping[filename]
            if len(candidates) == 1:
                return candidates[0]
            elif len(candidates) > 1:
                # 가장 유사한 경로 선택
                return self._find_best_path_match(file_ref, candidates)
        
        # 유사한 파일명 찾기
        similar_files = self._find_similar_files(filename)
        if similar_files:
            return similar_files[0]
        
        return None

    def _find_similar_files(self, filename: str) -> List[str]:
        """유사한 파일명 찾기"""
        similar = []
        filename_lower = filename.lower()
        
        for mapped_name, paths in self.file_mapping.items():
            if (mapped_name.lower() in filename_lower or 
                filename_lower in mapped_name.lower() or
                self._calculate_similarity(filename_lower, mapped_name.lower()) > 0.7):
                similar.extend(paths)
        
        return similar[:3]

    def _calculate_similarity(self, str1: str, str2: str) -> float:
        """문자열 유사도 계산"""
        if not str1 or not str2:
            return 0.0
        
        # 간단한 Jaccard 유사도
        set1 = set(str1)
        set2 = set(str2)
        intersection = len(set1 & set2)
        union = len(set1 | set2)
        
        return intersection / union if union > 0 else 0.0

    def _find_best_path_match(self, original_path: str, candidates: List[str]) -> str:
        """가장 적합한 경로 매치 찾기"""
        original_parts = Path(original_path).parts
        best_score = 0
        best_match = candidates[0]
        
        for candidate in candidates:
            candidate_parts = Path(candidate).parts
            score = len(set(original_parts) & set(candidate_parts))
            if score > best_score:
                best_score = score
                best_match = candidate
        
        return best_match

    def repair_broken_references(self) -> List[RepairResult]:
        """깨진 참조 수리"""
        logger.info("깨진 파일 참조 수리 시작...")
        
        # 파일별로 그룹화
        files_to_repair = {}
        for ref in self.broken_references:
            if ref.source_file not in files_to_repair:
                files_to_repair[ref.source_file] = []
            files_to_repair[ref.source_file].append(ref)
        
        # 각 파일 수리
        for file_path, references in files_to_repair.items():
            result = self._repair_file_references(file_path, references)
            self.repair_results.append(result)
        
        logger.info(f"총 {len(self.repair_results)}개 파일 수리 완료")
        return self.repair_results

    def _repair_file_references(self, file_path: str, references: List[BrokenReference]) -> RepairResult:
        """개별 파일의 참조 수리"""
        full_path = self.root_path / file_path
        changes_made = []
        
        try:
            # 백업 생성
            backup_created = self.create_backup(full_path)
            
            # 파일 읽기
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # 라인별 수정 (역순으로 처리하여 라인 번호 변경 방지)
            references_sorted = sorted(references, key=lambda x: x.line_number, reverse=True)
            
            for ref in references_sorted:
                if ref.suggested_fix:
                    old_line = lines[ref.line_number - 1]
                    new_line = old_line.replace(ref.referenced_path, ref.suggested_fix)
                    lines[ref.line_number - 1] = new_line
                    changes_made.append(f"Line {ref.line_number}: {ref.referenced_path} → {ref.suggested_fix}")
                else:
                    # 수정 방안이 없으면 주석 처리
                    old_line = lines[ref.line_number - 1]
                    if not old_line.strip().startswith('#'):
                        lines[ref.line_number - 1] = f"# BROKEN_REF: {old_line}"
                        changes_made.append(f"Line {ref.line_number}: 주석 처리 - {ref.referenced_path}")
            
            # 파일 쓰기
            if changes_made:
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
            
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=True,
                changes_made=changes_made,
                backup_created=backup_created
            )
            
        except Exception as e:
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=False,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def generate_report(self) -> Dict:
        """수리 보고서 생성"""
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_broken_references": len(self.broken_references),
                "files_repaired": len(self.repair_results),
                "successful_repairs": len([r for r in self.repair_results if r.success]),
                "failed_repairs": len([r for r in self.repair_results if not r.success])
            },
            "broken_references_by_type": {
                "python_import": len([r for r in self.broken_references if r.reference_type == "python_import"]),
                "file_path": len([r for r in self.broken_references if r.reference_type == "file_path"]),
                "script_execution": len([r for r in self.broken_references if r.reference_type == "script_execution"])
            },
            "broken_references": [
                {
                    "source_file": ref.source_file,
                    "referenced_path": ref.referenced_path,
                    "line_number": ref.line_number,
                    "reference_type": ref.reference_type,
                    "context": ref.context,
                    "suggested_fix": ref.suggested_fix
                }
                for ref in self.broken_references
            ],
            "repair_results": [
                {
                    "file_path": result.file_path,
                    "repair_type": result.repair_type,
                    "success": result.success,
                    "changes_made": result.changes_made,
                    "backup_created": result.backup_created,
                    "error_message": result.error_message
                }
                for result in self.repair_results
            ]
        }
        
        return report

    def save_report(self, report: Dict, filename: str = "refined_file_reference_repair_report.json"):
        """보고서 파일로 저장"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"보고서 저장: {filename}")

def main():
    """메인 실행 함수"""
    print("🔧 POSCO 시스템 파일 참조 무결성 복구 도구 (개선된 버전)")
    print("=" * 60)
    
    repairer = RefinedFileReferenceRepairer()
    
    # 1. 깨진 참조 스캔
    print("\n1️⃣ 실제 깨진 파일 참조 스캔 중...")
    broken_refs = repairer.scan_broken_references()
    print(f"   ✅ {len(broken_refs)}개의 실제 깨진 참조 발견")
    
    if broken_refs:
        # 2. 참조 수리
        print("\n2️⃣ 깨진 파일 참조 수리 중...")
        repair_results = repairer.repair_broken_references()
        successful = len([r for r in repair_results if r.success])
        print(f"   ✅ {successful}/{len(repair_results)}개 파일 수리 완료")
        
        # 3. 보고서 생성
        print("\n3️⃣ 수리 보고서 생성 중...")
        report = repairer.generate_report()
        repairer.save_report(report)
        print("   ✅ 보고서 생성 완료")
        
        # 결과 요약
        print(f"\n📊 수리 결과 요약:")
        print(f"   • 발견된 깨진 참조: {len(broken_refs)}개")
        print(f"     - Python import: {report['broken_references_by_type']['python_import']}개")
        print(f"     - 파일 경로: {report['broken_references_by_type']['file_path']}개")
        print(f"     - 스크립트 실행: {report['broken_references_by_type']['script_execution']}개")
        print(f"   • 수리된 파일: {successful}개")
        print(f"   • 백업 디렉토리: {repairer.backup_dir}")
    else:
        print("   ✅ 깨진 파일 참조가 발견되지 않았습니다!")
    
    return len(broken_refs) == 0 or len([r for r in repairer.repair_results if r.success]) > 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)