#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Enhanced Process Manager
POSCO 시스템 구성요소

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

# BROKEN_REF: import subprocess
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
import posco_news_250808_monitor.log
import system_functionality_verification.py
# BROKEN_REF: import psutil
import test_config.json
# BROKEN_REF: from datetime import datetime, timedelta
# BROKEN_REF: from typing import Dict, List, Optional, Tuple, Any
# BROKEN_REF: import logging
# BROKEN_REF: from enum import Enum
# BROKEN_REF: from dataclasses import dataclass

class ProcessStatus(Enum):
    """프로세스 상태 열거형"""
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    FAILED = "failed"
    RECOVERING = "recovering"
    DISABLED = "disabled"

@dataclass
class ProcessInfo:
    """프로세스 정보 데이터 클래스"""
    name: str
    pid: Optional[int]
    status: ProcessStatus
    start_time: Optional[datetime]
    last_health_check: datetime
    restart_count: int
    last_error: Optional[str]
cpu_usage:_float =  0.0
memory_usage:_float =  0.0

class ProcessManager:
    """
    Enhanced ProcessManager for WatchHamster System
    
    새로운 아키텍처에 맞는 프로세스 관리 클래스
    - 모든 하위 프로세스의 생명주기 관리
    - 지능적 헬스체크 및 자동 복구
    - 시스템 리소스 모니터링
    """
    
    def __init__(self, script_dir: str):
        """
        ProcessManager 초기화
        
        Args:
            script_dir (str): 스크립트 디렉토리 경로
        """
        self.script_dir = script_dir
        self.logger = logging.getLogger(__name__)
        
        # 프로세스 관리
self.processes:_Dict[str,_subprocess.Popen] =  {}
self.process_info:_Dict[str,_ProcessInfo] =  {}
        
        # 설정
        self.max_restart_attempts = 3
        self.health_check_interval = 300  # 5분
        self.restart_delay = 5  # 재시작 간 대기시간
        
        # 통계
        self.total_restarts = 0
        self.last_system_check = datetime.now()
        
        self.logger.info("🔧 Enhanced ProcessManager 초기화 완료")
    
    def start_process(self, name: str, script_path: str, args: List[str] = None, working_dir: str = None) -> bool:
        """
        프로세스 시작
        
        Args:
            name (str): 프로세스 이름
            script_path (str): 스크립트 경로
            args (List[str]): 명령행 인수
            
        Returns:
            bool: 시작 성공 여부
        """
        try:
            # 이미 실행 중인 프로세스가 있으면 중지
            if name in self.processes:
                self.stop_process(name)
            
            # 프로세스 정보 초기화
            self.process_info[name] = ProcessInfo(
                name=name,
                pid=None,
                status=ProcessStatus.STARTING,
                start_time=None,
                last_health_check=datetime.now(),
                restart_count=0,
                last_error=None
            )
            
            # working directory 설정
            if working_dir:
                if working_dir.startswith('/') or working_dir.startswith('C:'):
                    # 절대 경로
                    work_dir = working_dir
                else:
                    # 상대 경로 - script_dir 기준
                    work_dir = os.path.join(self.script_dir, working_dir)
            else:
                work_dir = self.script_dir
            
            # 스크립트 경로 확인
            if script_path.startswith('/') or script_path.startswith('C:'):
                # 절대 경로
                full_script_path = script_path
            else:
                # 상대 경로 - working_directory 기준
                full_script_path = os.path.join(work_dir, script_path)
            
            if not os.path.exists(full_script_path):
                error_msg = f"스크립트 파일을 찾을 수 없습니다: {full_script_path}"
                self.process_info[name].last_error = error_msg
                self.process_info[name].status = ProcessStatus.FAILED
                self.logger.error(f"❌ {name}: {error_msg}")
                return False
            
            # 명령어 구성
            cmd = [sys.executable, full_script_path]
            if args:
                cmd.extend(args)
            
            self.logger.info(f"🚀 {name} 프로세스 시작: {' '.join(cmd)} (작업 디렉토리: {work_dir})")
            
            # 프로세스 시작
            if os.name == 'nt':  # Windows
                process = subprocess.Popen(
                    cmd,
                    cwd=work_dir,
                    creationflags=subprocess.CREATE_NEW_CONSOLE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
            else:  # macOS/Linux
                process = subprocess.Popen(
                    cmd,
                    cwd=work_dir,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
            
            # 프로세스 등록
            self.processes[name] = process
            self.process_info[name].pid = process.pid
            self.process_info[name].start_time = datetime.now()
            
            # 시작 확인 대기
            time.sleep(3)
            
            # 프로세스 상태 확인
            if self.is_process_running(name):
                self.process_info[name].status = ProcessStatus.RUNNING
                self.logger.info(f"✅ {name} 프로세스 시작 성공 (PID: {process.pid})")
                return True
            else:
                self.process_info[name].status = ProcessStatus.FAILED
                self.process_info[name].last_error = "프로세스 시작 후 즉시 종료됨"
                self.logger.error(f"❌ {name} 프로세스 시작 실패")
                return False
                
        except Exception as e:
            error_msg = f"프로세스 시작 오류: {str(e)}"
            if name in self.process_info:
                self.process_info[name].last_error = error_msg
                self.process_info[name].status = ProcessStatus.FAILED
            self.logger.error(f"❌ {name}: {error_msg}")
            return False
    
    def stop_process(self, name: str, timeout: int = 30) -> bool:
        """
        프로세스 중지
        
        Args:
            name (str): 프로세스 이름
            timeout (int): 종료 대기 시간 (초)
            
        Returns:
            bool: 중지 성공 여부
        """
        try:
            if name not in self.processes:
                self.logger.info(f"📋 {name}: 중지할 프로세스가 없습니다")
                return True
            
            process = self.processes[name]
            
            # 프로세스가 이미 종료되었는지 확인
            if process.poll() is not None:
                self._cleanup_process(name)
                return True
            
            self.logger.info(f"⏹️ {name} 프로세스 중지 시작 (PID: {process.pid})")
            
            # 정상 종료 시도
            process.terminate()
            
            try:
                # 지정된 시간만큼 대기
                process.wait(timeout=timeout)
                self.logger.info(f"✅ {name} 프로세스 정상 종료")
            except subprocess.TimeoutExpired:
                # 강제 종료
                self.logger.warning(f"⚠️ {name} 프로세스 강제 종료")
                process.kill()
                process.wait()
            
            self._cleanup_process(name)
            return True
            
        except Exception as e:
            self.logger.error(f"❌ {name} 프로세스 중지 오류: {e}")
            return False
    
    def restart_process(self, name: str) -> bool:
        """
        프로세스 재시작
        
        Args:
            name (str): 프로세스 이름
            
        Returns:
            bool: 재시작 성공 여부
        """
        try:
            if name not in self.process_info:
                self.logger.error(f"❌ {name}: 알 수 없는 프로세스")
                return False
            
            # 재시작 횟수 증가
self.process_info[name].restart_count_+ =  1
self.total_restarts_+ =  1
            
            # 최대 재시작 횟수 확인
            if self.process_info[name].restart_count > self.max_restart_attempts:
                self.process_info[name].status = ProcessStatus.DISABLED
                self.logger.error(f"❌ {name}: 최대 재시작 횟수 초과, 프로세스 비활성화")
                return False
            
            self.logger.info(f"🔄 {name} 프로세스 재시작 시도 ({self.process_info[name].restart_count}/{self.max_restart_attempts})")
            
            # 프로세스 중지
            self.stop_process(name)
            
            # 재시작 대기
            time.sleep(self.restart_delay)
            
            # 프로세스 시작 (기존 설정 사용)
            # 실제 구현에서는 ModuleRegistry에서 설정을 가져와야 함
            # 여기서는 기본 설정으로 시작
            return self._restart_with_config(name)
            
        except Exception as e:
            self.logger.error(f"❌ {name} 프로세스 재시작 오류: {e}")
            return False
    
    def _restart_with_config(self, name: str) -> bool:
        """
        설정을 사용하여 프로세스 재시작
        
        Args:
            name (str): 프로세스 이름
            
        Returns:
            bool: 재시작 성공 여부
        """
        # 기본 프로세스 설정 (실제로는 ModuleRegistry에서 가져와야 함)
        default_configs = {
            "posco_main_notifier": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/posco_main_notifier.py",
                "args": []
            },
            "realtime_news_monitor": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/realtime_news_monitor.py", 
                "args": []
            },
            "integrated_report_scheduler": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/integrated_report_scheduler.py",
                "args": []
            },
            "historical_data_collector": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/historical_data_collector.py",
                "args": []
            }
        }
        
        if name in default_configs:
            config = default_configs[name]
            return self.start_process(name, config["script"], config["args"])
        else:
            self.logger.error(f"❌ {name}: 알 수 없는 프로세스 설정")
            return False
    
    def is_process_running(self, name: str) -> bool:
        """
        프로세스 실행 상태 확인
        
        Args:
            name (str): 프로세스 이름
            
        Returns:
            bool: 실행 중이면 True
        """
        try:
            if name not in self.processes:
                return False
            
            process = self.processes[name]
            
            # 프로세스 종료 상태 확인
            if process.poll() is not None:
                return False
            
            # psutil을 사용한 실제 프로세스 확인
            try:
                psutil_process = psutil.Process(process.pid)
                return psutil_process.is_running()
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                return False
                
        except Exception as e:
            self.logger.error(f"❌ {name} 프로세스 상태 확인 오류: {e}")
            return False
    
    def get_process_info(self, name: str) -> Optional[ProcessInfo]:
        """
        프로세스 정보 조회
        
        Args:
            name (str): 프로세스 이름
            
        Returns:
            Optional[ProcessInfo]: 프로세스 정보
        """
        if name not in self.process_info:
            return None
        
        # 실시간 정보 업데이트
        self._update_process_metrics(name)
        return self.process_info[name]
    
    def _update_process_metrics(self, name: str):
        """
        프로세스 메트릭 업데이트
        
        Args:
            name (str): 프로세스 이름
        """
        try:
            if name not in self.processes or name not in self.process_info:
                return
            
            process = self.processes[name]
            if process.poll() is not None:
                return
            
            # psutil을 사용한 메트릭 수집
            psutil_process = psutil.Process(process.pid)
            
            # CPU 및 메모리 사용률
            self.process_info[name].cpu_usage = psutil_process.cpu_percent()
            memory_info = psutil_process.memory_info()
            self.process_info[name].memory_usage = memory_info.rss / 1024 / 1024  # MB
            
        except (psutil.NoSuchProcess, psutil.AccessDenied, Exception):
            # 프로세스가 종료되었거나 접근할 수 없는 경우
            pass
    
    def perform_health_check(self) -> Dict[str, bool]:
        """
        모든 프로세스 헬스체크 수행
        
        Returns:
            Dict[str, bool]: 프로세스별 헬스체크 결과
        """
        results = {}
        current_time = datetime.now()
        
        for name in self.process_info.keys():
            is_healthy = self.is_process_running(name)
            results[name] = is_healthy
            
            # 프로세스 정보 업데이트
            self.process_info[name].last_health_check = current_time
            
            if is_healthy:
                if self.process_info[name].status != ProcessStatus.RUNNING:
                    self.process_info[name].status = ProcessStatus.RUNNING
                    self.logger.info(f"✅ {name}: 헬스체크 정상")
            else:
                if self.process_info[name].status == ProcessStatus.RUNNING:
                    self.process_info[name].status = ProcessStatus.FAILED
                    self.logger.warning(f"⚠️ {name}: 헬스체크 실패")
        
        self.last_system_check = current_time
        return results
    
    def auto_recovery(self, failed_process: str) -> bool:
        """
        실패한 프로세스 자동 복구
        
        Args:
            failed_process (str): 실패한 프로세스 이름
            
        Returns:
            bool: 복구 성공 여부
        """
        try:
            if failed_process not in self.process_info:
                return False
            
            process_info = self.process_info[failed_process]
            
            # 비활성화된 프로세스는 복구하지 않음
            if process_info.status == ProcessStatus.DISABLED:
                self.logger.info(f"📋 {failed_process}: 비활성화된 프로세스, 복구 생략")
                return False
            
            # 복구 상태로 변경
            process_info.status = ProcessStatus.RECOVERING
            
            self.logger.info(f"🔧 {failed_process}: 자동 복구 시작")
            
            # 3단계 복구 로직
            # 1단계: 즉시 재시작
            if self.restart_process(failed_process):
                self.logger.info(f"✅ {failed_process}: 1단계 복구 성공")
                return True
            
            # 2단계: 5분 후 재시도
            self.logger.info(f"⏳ {failed_process}: 5분 후 2단계 복구 시도")
            time.sleep(300)  # 5분 대기
            
            if self.restart_process(failed_process):
                self.logger.info(f"✅ {failed_process}: 2단계 복구 성공")
                return True
            
            # 3단계: 최종 재시도
            self.logger.info(f"⏳ {failed_process}: 5분 후 3단계 최종 복구 시도")
            time.sleep(300)  # 5분 대기
            
            if self.restart_process(failed_process):
                self.logger.info(f"✅ {failed_process}: 3단계 복구 성공")
                return True
            
            # 복구 실패 - 프로세스 비활성화
            process_info.status = ProcessStatus.DISABLED
            self.logger.error(f"❌ {failed_process}: 모든 복구 시도 실패, 프로세스 비활성화")
            return False
            
        except Exception as e:
            self.logger.error(f"❌ {failed_process} 자동 복구 오류: {e}")
            return False
    
    def kill_all_processes(self):
        """모든 프로세스 강제 종료"""
        self.logger.info("🛑 모든 프로세스 강제 종료 시작")
        
        for name in list(self.processes.keys()):
            try:
self.stop_process(name,_timeout = 10)
            except Exception as e:
                self.logger.error(f"❌ {name} 강제 종료 오류: {e}")
        
        self.processes.clear()
        
        # 프로세스 정보 상태 업데이트
        for name in self.process_info.keys():
            self.process_info[name].status = ProcessStatus.STOPPED
            self.process_info[name].pid = None
        
        self.logger.info("✅ 모든 프로세스 강제 종료 완료")
    
    def _cleanup_process(self, name: str):
        """프로세스 정리"""
        if name in self.processes:
            del self.processes[name]
        
        if name in self.process_info:
            self.process_info[name].status = ProcessStatus.STOPPED
            self.process_info[name].pid = None
    
    def get_system_status(self) -> Dict[str, Any]:
        """
        시스템 전체 상태 조회
        
        Returns:
            Dict[str, Any]: 시스템 상태 정보
        """
        try:
            # 프로세스 상태 통계
            total_processes = len(self.process_info)
            running_processes = sum(1 for info in self.process_info.values() 
                                  if info.status == ProcessStatus.RUNNING)
            failed_processes = sum(1 for info in self.process_info.values() 
                                 if info.status == ProcessStatus.FAILED)
            
            # 시스템 리소스
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('.')
            
            # 워치햄스터 프로세스들의 총 메모리 사용량
            total_memory_mb = sum(info.memory_usage for info in self.process_info.values())
            
            return {
                'timestamp': datetime.now().isoformat(),
                'uptime': (datetime.now() - self.last_system_check).total_seconds(),
                'total_processes': total_processes,
                'running_processes': running_processes,
                'failed_processes': failed_processes,
                'total_restarts': self.total_restarts,
                'system_metrics': {
                    'cpu_percent': cpu_percent,
                    'memory_percent': memory.percent,
                    'memory_available_gb': memory.available / 1024 / 1024 / 1024,
                    'disk_percent': disk.percent,
                    'watchhamster_memory_mb': total_memory_mb
                },
                'process_details': {
                    name: {
                        'status': info.status.value,
                        'pid': info.pid,
                        'restart_count': info.restart_count,
                        'cpu_usage': info.cpu_usage,
                        'memory_usage': info.memory_usage,
                        'last_error': info.last_error
                    } for name, info in self.process_info.items()
                }
            }
            
        except Exception as e:
            self.logger.error(f"❌ 시스템 상태 조회 오류: {e}")
            return {
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }