#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Enhanced Process Manager
POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

# BROKEN_REF: import subprocess
import .comprehensive_repair_backup/realtime_news_monitor.py.backup_20250809_181657
import posco_news_250808_monitor.log
import system_functionality_verification.py
# BROKEN_REF: import psutil
import test_config.json
# BROKEN_REF: from datetime import datetime, timedelta
# BROKEN_REF: from typing import Dict, List, Optional, Tuple, Any
# BROKEN_REF: import logging
# BROKEN_REF: from enum import Enum
# BROKEN_REF: from dataclasses import dataclass

class ProcessStatus(Enum):
    """í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì—´ê±°í˜•"""
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    FAILED = "failed"
    RECOVERING = "recovering"
    DISABLED = "disabled"

@dataclass
class ProcessInfo:
    """í”„ë¡œì„¸ìŠ¤ ì •ë³´ ë°ì´í„° í´ë˜ìŠ¤"""
    name: str
    pid: Optional[int]
    status: ProcessStatus
    start_time: Optional[datetime]
    last_health_check: datetime
    restart_count: int
    last_error: Optional[str]
cpu_usage:_float =  0.0
memory_usage:_float =  0.0

class ProcessManager:
    """
    Enhanced ProcessManager for WatchHamster System
    
    ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ì— ë§ëŠ” í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í´ë˜ìŠ¤
    - ëª¨ë“  í•˜ìœ„ í”„ë¡œì„¸ìŠ¤ì˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬
    - ì§€ëŠ¥ì  í—¬ìŠ¤ì²´í¬ ë° ìë™ ë³µêµ¬
    - ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
    """
    
    def __init__(self, script_dir: str):
        """
        ProcessManager ì´ˆê¸°í™”
        
        Args:
            script_dir (str): ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œ
        """
        self.script_dir = script_dir
        self.logger = logging.getLogger(__name__)
        
        # í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬
self.processes:_Dict[str,_subprocess.Popen] =  {}
self.process_info:_Dict[str,_ProcessInfo] =  {}
        
        # ì„¤ì •
        self.max_restart_attempts = 3
        self.health_check_interval = 300  # 5ë¶„
        self.restart_delay = 5  # ì¬ì‹œì‘ ê°„ ëŒ€ê¸°ì‹œê°„
        
        # í†µê³„
        self.total_restarts = 0
        self.last_system_check = datetime.now()
        
        self.logger.info("ğŸ”§ Enhanced ProcessManager ì´ˆê¸°í™” ì™„ë£Œ")
    
    def start_process(self, name: str, script_path: str, args: List[str] = None, working_dir: str = None) -> bool:
        """
        í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            script_path (str): ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ
            args (List[str]): ëª…ë ¹í–‰ ì¸ìˆ˜
            
        Returns:
            bool: ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        try:
            # ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ìˆìœ¼ë©´ ì¤‘ì§€
            if name in self.processes:
                self.stop_process(name)
            
            # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì´ˆê¸°í™”
            self.process_info[name] = ProcessInfo(
                name=name,
                pid=None,
                status=ProcessStatus.STARTING,
                start_time=None,
                last_health_check=datetime.now(),
                restart_count=0,
                last_error=None
            )
            
            # working directory ì„¤ì •
            if working_dir:
                if working_dir.startswith('/') or working_dir.startswith('C:'):
                    # ì ˆëŒ€ ê²½ë¡œ
                    work_dir = working_dir
                else:
                    # ìƒëŒ€ ê²½ë¡œ - script_dir ê¸°ì¤€
                    work_dir = os.path.join(self.script_dir, working_dir)
            else:
                work_dir = self.script_dir
            
            # ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ í™•ì¸
            if script_path.startswith('/') or script_path.startswith('C:'):
                # ì ˆëŒ€ ê²½ë¡œ
                full_script_path = script_path
            else:
                # ìƒëŒ€ ê²½ë¡œ - working_directory ê¸°ì¤€
                full_script_path = os.path.join(work_dir, script_path)
            
            if not os.path.exists(full_script_path):
                error_msg = f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {full_script_path}"
                self.process_info[name].last_error = error_msg
                self.process_info[name].status = ProcessStatus.FAILED
                self.logger.error(f"âŒ {name}: {error_msg}")
                return False
            
            # ëª…ë ¹ì–´ êµ¬ì„±
            cmd = [sys.executable, full_script_path]
            if args:
                cmd.extend(args)
            
            self.logger.info(f"ğŸš€ {name} í”„ë¡œì„¸ìŠ¤ ì‹œì‘: {' '.join(cmd)} (ì‘ì—… ë””ë ‰í† ë¦¬: {work_dir})")
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            if os.name == 'nt':  # Windows
                process = subprocess.Popen(
                    cmd,
                    cwd=work_dir,
                    creationflags=subprocess.CREATE_NEW_CONSOLE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
            else:  # macOS/Linux
                process = subprocess.Popen(
                    cmd,
                    cwd=work_dir,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
            
            # í”„ë¡œì„¸ìŠ¤ ë“±ë¡
            self.processes[name] = process
            self.process_info[name].pid = process.pid
            self.process_info[name].start_time = datetime.now()
            
            # ì‹œì‘ í™•ì¸ ëŒ€ê¸°
            time.sleep(3)
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            if self.is_process_running(name):
                self.process_info[name].status = ProcessStatus.RUNNING
                self.logger.info(f"âœ… {name} í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì„±ê³µ (PID: {process.pid})")
                return True
            else:
                self.process_info[name].status = ProcessStatus.FAILED
                self.process_info[name].last_error = "í”„ë¡œì„¸ìŠ¤ ì‹œì‘ í›„ ì¦‰ì‹œ ì¢…ë£Œë¨"
                self.logger.error(f"âŒ {name} í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            error_msg = f"í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì˜¤ë¥˜: {str(e)}"
            if name in self.process_info:
                self.process_info[name].last_error = error_msg
                self.process_info[name].status = ProcessStatus.FAILED
            self.logger.error(f"âŒ {name}: {error_msg}")
            return False
    
    def stop_process(self, name: str, timeout: int = 30) -> bool:
        """
        í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            timeout (int): ì¢…ë£Œ ëŒ€ê¸° ì‹œê°„ (ì´ˆ)
            
        Returns:
            bool: ì¤‘ì§€ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if name not in self.processes:
                self.logger.info(f"ğŸ“‹ {name}: ì¤‘ì§€í•  í”„ë¡œì„¸ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤")
                return True
            
            process = self.processes[name]
            
            # í”„ë¡œì„¸ìŠ¤ê°€ ì´ë¯¸ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if process.poll() is not None:
                self._cleanup_process(name)
                return True
            
            self.logger.info(f"â¹ï¸ {name} í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì‹œì‘ (PID: {process.pid})")
            
            # ì •ìƒ ì¢…ë£Œ ì‹œë„
            process.terminate()
            
            try:
                # ì§€ì •ëœ ì‹œê°„ë§Œí¼ ëŒ€ê¸°
                process.wait(timeout=timeout)
                self.logger.info(f"âœ… {name} í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ")
            except subprocess.TimeoutExpired:
                # ê°•ì œ ì¢…ë£Œ
                self.logger.warning(f"âš ï¸ {name} í”„ë¡œì„¸ìŠ¤ ê°•ì œ ì¢…ë£Œ")
                process.kill()
                process.wait()
            
            self._cleanup_process(name)
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ {name} í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì˜¤ë¥˜: {e}")
            return False
    
    def restart_process(self, name: str) -> bool:
        """
        í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ì¬ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if name not in self.process_info:
                self.logger.error(f"âŒ {name}: ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤")
                return False
            
            # ì¬ì‹œì‘ íšŸìˆ˜ ì¦ê°€
self.process_info[name].restart_count_+ =  1
self.total_restarts_+ =  1
            
            # ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ í™•ì¸
            if self.process_info[name].restart_count > self.max_restart_attempts:
                self.process_info[name].status = ProcessStatus.DISABLED
                self.logger.error(f"âŒ {name}: ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ ì´ˆê³¼, í”„ë¡œì„¸ìŠ¤ ë¹„í™œì„±í™”")
                return False
            
            self.logger.info(f"ğŸ”„ {name} í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹œë„ ({self.process_info[name].restart_count}/{self.max_restart_attempts})")
            
            # í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€
            self.stop_process(name)
            
            # ì¬ì‹œì‘ ëŒ€ê¸°
            time.sleep(self.restart_delay)
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ (ê¸°ì¡´ ì„¤ì • ì‚¬ìš©)
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ModuleRegistryì—ì„œ ì„¤ì •ì„ ê°€ì ¸ì™€ì•¼ í•¨
            # ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì‹œì‘
            return self._restart_with_config(name)
            
        except Exception as e:
            self.logger.error(f"âŒ {name} í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì˜¤ë¥˜: {e}")
            return False
    
    def _restart_with_config(self, name: str) -> bool:
        """
        ì„¤ì •ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ì¬ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        # ê¸°ë³¸ í”„ë¡œì„¸ìŠ¤ ì„¤ì • (ì‹¤ì œë¡œëŠ” ModuleRegistryì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨)
        default_configs = {
            "posco_main_notifier": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/posco_main_notifier.py",
                "args": []
            },
            "realtime_news_monitor": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/realtime_news_monitor.py", 
                "args": []
            },
            "integrated_report_scheduler": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/integrated_report_scheduler.py",
                "args": []
            },
            "historical_data_collector": {
                "script": "Monitoring/POSCO_News_250808/Monitoring/POSCO_News_250808/historical_data_collector.py",
                "args": []
            }
        }
        
        if name in default_configs:
            config = default_configs[name]
            return self.start_process(name, config["script"], config["args"])
        else:
            self.logger.error(f"âŒ {name}: ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤ ì„¤ì •")
            return False
    
    def is_process_running(self, name: str) -> bool:
        """
        í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ìƒíƒœ í™•ì¸
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ì‹¤í–‰ ì¤‘ì´ë©´ True
        """
        try:
            if name not in self.processes:
                return False
            
            process = self.processes[name]
            
            # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ìƒíƒœ í™•ì¸
            if process.poll() is not None:
                return False
            
            # psutilì„ ì‚¬ìš©í•œ ì‹¤ì œ í”„ë¡œì„¸ìŠ¤ í™•ì¸
            try:
                psutil_process = psutil.Process(process.pid)
                return psutil_process.is_running()
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                return False
                
        except Exception as e:
            self.logger.error(f"âŒ {name} í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    def get_process_info(self, name: str) -> Optional[ProcessInfo]:
        """
        í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì¡°íšŒ
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            Optional[ProcessInfo]: í”„ë¡œì„¸ìŠ¤ ì •ë³´
        """
        if name not in self.process_info:
            return None
        
        # ì‹¤ì‹œê°„ ì •ë³´ ì—…ë°ì´íŠ¸
        self._update_process_metrics(name)
        return self.process_info[name]
    
    def _update_process_metrics(self, name: str):
        """
        í”„ë¡œì„¸ìŠ¤ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        
        Args:
            name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
        """
        try:
            if name not in self.processes or name not in self.process_info:
                return
            
            process = self.processes[name]
            if process.poll() is not None:
                return
            
            # psutilì„ ì‚¬ìš©í•œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
            psutil_process = psutil.Process(process.pid)
            
            # CPU ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
            self.process_info[name].cpu_usage = psutil_process.cpu_percent()
            memory_info = psutil_process.memory_info()
            self.process_info[name].memory_usage = memory_info.rss / 1024 / 1024  # MB
            
        except (psutil.NoSuchProcess, psutil.AccessDenied, Exception):
            # í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
            pass
    
    def perform_health_check(self) -> Dict[str, bool]:
        """
        ëª¨ë“  í”„ë¡œì„¸ìŠ¤ í—¬ìŠ¤ì²´í¬ ìˆ˜í–‰
        
        Returns:
            Dict[str, bool]: í”„ë¡œì„¸ìŠ¤ë³„ í—¬ìŠ¤ì²´í¬ ê²°ê³¼
        """
        results = {}
        current_time = datetime.now()
        
        for name in self.process_info.keys():
            is_healthy = self.is_process_running(name)
            results[name] = is_healthy
            
            # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì—…ë°ì´íŠ¸
            self.process_info[name].last_health_check = current_time
            
            if is_healthy:
                if self.process_info[name].status != ProcessStatus.RUNNING:
                    self.process_info[name].status = ProcessStatus.RUNNING
                    self.logger.info(f"âœ… {name}: í—¬ìŠ¤ì²´í¬ ì •ìƒ")
            else:
                if self.process_info[name].status == ProcessStatus.RUNNING:
                    self.process_info[name].status = ProcessStatus.FAILED
                    self.logger.warning(f"âš ï¸ {name}: í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨")
        
        self.last_system_check = current_time
        return results
    
    def auto_recovery(self, failed_process: str) -> bool:
        """
        ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ ìë™ ë³µêµ¬
        
        Args:
            failed_process (str): ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ë³µêµ¬ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if failed_process not in self.process_info:
                return False
            
            process_info = self.process_info[failed_process]
            
            # ë¹„í™œì„±í™”ëœ í”„ë¡œì„¸ìŠ¤ëŠ” ë³µêµ¬í•˜ì§€ ì•ŠìŒ
            if process_info.status == ProcessStatus.DISABLED:
                self.logger.info(f"ğŸ“‹ {failed_process}: ë¹„í™œì„±í™”ëœ í”„ë¡œì„¸ìŠ¤, ë³µêµ¬ ìƒëµ")
                return False
            
            # ë³µêµ¬ ìƒíƒœë¡œ ë³€ê²½
            process_info.status = ProcessStatus.RECOVERING
            
            self.logger.info(f"ğŸ”§ {failed_process}: ìë™ ë³µêµ¬ ì‹œì‘")
            
            # 3ë‹¨ê³„ ë³µêµ¬ ë¡œì§
            # 1ë‹¨ê³„: ì¦‰ì‹œ ì¬ì‹œì‘
            if self.restart_process(failed_process):
                self.logger.info(f"âœ… {failed_process}: 1ë‹¨ê³„ ë³µêµ¬ ì„±ê³µ")
                return True
            
            # 2ë‹¨ê³„: 5ë¶„ í›„ ì¬ì‹œë„
            self.logger.info(f"â³ {failed_process}: 5ë¶„ í›„ 2ë‹¨ê³„ ë³µêµ¬ ì‹œë„")
            time.sleep(300)  # 5ë¶„ ëŒ€ê¸°
            
            if self.restart_process(failed_process):
                self.logger.info(f"âœ… {failed_process}: 2ë‹¨ê³„ ë³µêµ¬ ì„±ê³µ")
                return True
            
            # 3ë‹¨ê³„: ìµœì¢… ì¬ì‹œë„
            self.logger.info(f"â³ {failed_process}: 5ë¶„ í›„ 3ë‹¨ê³„ ìµœì¢… ë³µêµ¬ ì‹œë„")
            time.sleep(300)  # 5ë¶„ ëŒ€ê¸°
            
            if self.restart_process(failed_process):
                self.logger.info(f"âœ… {failed_process}: 3ë‹¨ê³„ ë³µêµ¬ ì„±ê³µ")
                return True
            
            # ë³µêµ¬ ì‹¤íŒ¨ - í”„ë¡œì„¸ìŠ¤ ë¹„í™œì„±í™”
            process_info.status = ProcessStatus.DISABLED
            self.logger.error(f"âŒ {failed_process}: ëª¨ë“  ë³µêµ¬ ì‹œë„ ì‹¤íŒ¨, í”„ë¡œì„¸ìŠ¤ ë¹„í™œì„±í™”")
            return False
            
        except Exception as e:
            self.logger.error(f"âŒ {failed_process} ìë™ ë³µêµ¬ ì˜¤ë¥˜: {e}")
            return False
    
    def kill_all_processes(self):
        """ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ê°•ì œ ì¢…ë£Œ"""
        self.logger.info("ğŸ›‘ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ê°•ì œ ì¢…ë£Œ ì‹œì‘")
        
        for name in list(self.processes.keys()):
            try:
self.stop_process(name,_timeout = 10)
            except Exception as e:
                self.logger.error(f"âŒ {name} ê°•ì œ ì¢…ë£Œ ì˜¤ë¥˜: {e}")
        
        self.processes.clear()
        
        # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ìƒíƒœ ì—…ë°ì´íŠ¸
        for name in self.process_info.keys():
            self.process_info[name].status = ProcessStatus.STOPPED
            self.process_info[name].pid = None
        
        self.logger.info("âœ… ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ê°•ì œ ì¢…ë£Œ ì™„ë£Œ")
    
    def _cleanup_process(self, name: str):
        """í”„ë¡œì„¸ìŠ¤ ì •ë¦¬"""
        if name in self.processes:
            del self.processes[name]
        
        if name in self.process_info:
            self.process_info[name].status = ProcessStatus.STOPPED
            self.process_info[name].pid = None
    
    def get_system_status(self) -> Dict[str, Any]:
        """
        ì‹œìŠ¤í…œ ì „ì²´ ìƒíƒœ ì¡°íšŒ
        
        Returns:
            Dict[str, Any]: ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´
        """
        try:
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í†µê³„
            total_processes = len(self.process_info)
            running_processes = sum(1 for info in self.process_info.values() 
                                  if info.status == ProcessStatus.RUNNING)
            failed_processes = sum(1 for info in self.process_info.values() 
                                 if info.status == ProcessStatus.FAILED)
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('.')
            
            # ì›Œì¹˜í–„ìŠ¤í„° í”„ë¡œì„¸ìŠ¤ë“¤ì˜ ì´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
            total_memory_mb = sum(info.memory_usage for info in self.process_info.values())
            
            return {
                'timestamp': datetime.now().isoformat(),
                'uptime': (datetime.now() - self.last_system_check).total_seconds(),
                'total_processes': total_processes,
                'running_processes': running_processes,
                'failed_processes': failed_processes,
                'total_restarts': self.total_restarts,
                'system_metrics': {
                    'cpu_percent': cpu_percent,
                    'memory_percent': memory.percent,
                    'memory_available_gb': memory.available / 1024 / 1024 / 1024,
                    'disk_percent': disk.percent,
                    'watchhamster_memory_mb': total_memory_mb
                },
                'process_details': {
                    name: {
                        'status': info.status.value,
                        'pid': info.pid,
                        'restart_count': info.restart_count,
                        'cpu_usage': info.cpu_usage,
                        'memory_usage': info.memory_usage,
                        'last_error': info.last_error
                    } for name, info in self.process_info.items()
                }
            }
            
        except Exception as e:
            self.logger.error(f"âŒ ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return {
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }