#!/usr/bin/env python3
"""
POSCO 시스템 파일 참조 무결성 복구 도구

이 도구는 다음 문제들을 해결합니다:
- 83개 깨진 파일 참조 수정
- 존재하지 않는 파일 경로 참조 제거 또는 수정
- 와일드카드 패턴 오인식 문제 해결
- 상대 경로 참조 정확성 검증 및 표준화
"""

import posco_news_250808_monitor.log
import verify_folder_reorganization.py
import test_config.json
# BROKEN_REF: import shutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from typing import Dict, List, Set, Tuple, Optional
# BROKEN_REF: from dataclasses import dataclass
# BROKEN_REF: import logging

# 로깅 설정
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class BrokenReference:
    """깨진 파일 참조 정보"""
    source_file: str
    referenced_path: str
    line_number: int
    reference_type: str  # 'import', 'file_path', 'config', 'script'
    context: str
    suggested_fix: Optional[str] = None

@dataclass
class RepairResult:
    """수리 결과 정보"""
    file_path: str
    repair_type: str
    success: bool
    changes_made: List[str]
    backup_created: bool
    error_message: Optional[str] = None

class FileReferenceRepairer:
    """파일 참조 무결성을 복구하는 클래스"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.broken_references: List[BrokenReference] = []
        self.repair_results: List[RepairResult] = []
        self.file_mapping: Dict[str, str] = {}
# BROKEN_REF:         self.backup_dir = Path(".file_reference_backup")
        
        # 파일 확장자별 처리 패턴
        self.file_patterns = {
            'python': [r'/.py$'],
            'shell': [r'/.sh$', r'/.command$'],
            'batch': [r'/.bat$'],
            'config': [r'/.json$', r'/.md$', r'/.txt$'],
            'markdown': [r'/.md$']
        }
        
        # 참조 패턴 정의
        self.reference_patterns = {
            'import': [
                r'from/s+([^/s]+)/s+import',
                r'import/s+([^/s,]+)',
                r'importlib/.import_module/([/'"]([^/'"]+)[/'"]'
            ],
            'file_path': [
                r'[/'"]([^/'"/s]+/.(py|sh|bat|json|md|txt|log|command))[/'"]',
                r'Path/([/'"]([^/'"]+)[/'"]',
                r'open/([/'"]([^/'"]+)[/'"]',
                r'with/s+open/([/'"]([^/'"]+)[/'"]'
            ],
            'config': [
                r'"([^"]+/.(py|sh|bat|json|md|txt|log))"',
                r"'([^']+/.(py|sh|bat|json|md|txt|log))'"
            ],
            'script': [
                r'python3?/s+([^/s]+/.py)',
                r'bash/s+([^/s]+/.sh)',
                r'/./([^/s]+/.(sh|command|bat))',
                r'exec/s+([^/s]+/.(sh|command|bat))'
            ]
        }

    def create_backup(self, file_path: Path) -> bool:
        """파일 백업 생성"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            backup_path = self.backup_dir / f"{file_path.name}.backup_{self._get_timestamp()}"
            shutil.copy2(file_path, backup_path)
            logger.info(f"백업 생성: {backup_path}")
            return True
        except Exception as e:
            logger.error(f"백업 생성 실패 {file_path}: {e}")
            return False

    def _get_timestamp(self) -> str:
        """타임스탬프 생성"""
# BROKEN_REF:         from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def scan_all_references(self) -> List[BrokenReference]:
        """모든 파일의 참조를 스캔하여 깨진 참조 찾기"""
        logger.info("파일 참조 스캔 시작...")
        
        # 먼저 모든 파일 목록 생성
        self._build_file_mapping()
        
        # 각 파일 타입별로 스캔
        for file_type, patterns in self.file_patterns.items():
            for pattern in patterns:
                for file_path in self.root_path.rglob("*"):
                    if file_path.is_file() and re.search(pattern, str(file_path)):
                        self._scan_file_references(file_path, file_type)
        
        logger.info(f"총 {len(self.broken_references)}개의 깨진 참조 발견")
        return self.broken_references

    def _build_file_mapping(self):
        """파일 매핑 테이블 구축"""
        logger.info("파일 매핑 테이블 구축 중...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file():
                # 파일명으로 매핑
                filename = file_path.name
                relative_path = str(file_path.relative_to(self.root_path))
                
                if filename not in self.file_mapping:
                    self.file_mapping[filename] = []
                self.file_mapping[filename].append(relative_path)
                
                # 확장자 없는 이름으로도 매핑
                stem = file_path.stem
                if stem not in self.file_mapping:
                    self.file_mapping[stem] = []
                self.file_mapping[stem].append(relative_path)

    def _scan_file_references(self, file_path: Path, file_type: str):
        """개별 파일의 참조 스캔"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                for ref_type, patterns in self.reference_patterns.items():
                    for pattern in patterns:
                        matches = re.finditer(pattern, line)
                        for match in matches:
                            referenced_path = match.group(1)
                            if self._is_broken_reference(referenced_path, file_path):
                                broken_ref = BrokenReference(
                                    source_file=str(file_path.relative_to(self.root_path)),
                                    referenced_path=referenced_path,
                                    line_number=line_num,
                                    reference_type=ref_type,
                                    context=line.strip(),
                                    suggested_fix=self._suggest_fix(referenced_path)
                                )
                                self.broken_references.append(broken_ref)
                                
        except Exception as e:
            logger.error(f"파일 스캔 오류 {file_path}: {e}")

    def _is_broken_reference(self, referenced_path: str, source_file: Path) -> bool:
        """참조가 깨진 것인지 확인"""
        # 절대 경로 확인
        if os.path.isabs(referenced_path):
            return not Path(referenced_path).exists()
        
        # 상대 경로 확인
        source_dir = source_file.parent
        full_path = source_dir / referenced_path
        
        if full_path.exists():
            return False
        
        # 루트 기준 경로 확인
        root_path = self.root_path / referenced_path
        if root_path.exists():
            return False
        
        # 와일드카드 패턴 확인
        if '*' in referenced_path or '?' in referenced_path:
# BROKEN_REF:             import glob
            pattern_path = str(source_dir / referenced_path)
            if glob.glob(pattern_path):
                return False
        
        return True

    def _suggest_fix(self, referenced_path: str) -> Optional[str]:
        """수정 방안 제안"""
        filename = Path(referenced_path).name
        
        # 정확한 파일명 매칭
        if filename in self.file_mapping:
            candidates = self.file_mapping[filename]
            if len(candidates) == 1:
                return candidates[0]
            elif len(candidates) > 1:
                # 가장 유사한 경로 선택
                return self._find_best_match(referenced_path, candidates)
        
        # 유사한 파일명 찾기
        similar_files = self._find_similar_files(filename)
        if similar_files:
            return similar_files[0]
        
        return None

    def _find_similar_files(self, filename: str) -> List[str]:
        """유사한 파일명 찾기"""
        similar = []
        filename_lower = filename.lower()
        
        for mapped_name, paths in self.file_mapping.items():
            if mapped_name.lower() in filename_lower or filename_lower in mapped_name.lower():
                similar.extend(paths)
        
        return similar[:3]  # 상위 3개만 반환

    def _find_best_match(self, original_path: str, candidates: List[str]) -> str:
        """가장 적합한 매치 찾기"""
        # 경로 유사도 기반으로 선택
        original_parts = Path(original_path).parts
        best_score = 0
        best_match = candidates[0]
        
        for candidate in candidates:
            candidate_parts = Path(candidate).parts
            score = len(set(original_parts) & set(candidate_parts))
            if score > best_score:
                best_score = score
                best_match = candidate
        
        return best_match

    def repair_all_references(self) -> List[RepairResult]:
        """모든 깨진 참조 수리"""
        logger.info("파일 참조 수리 시작...")
        
        # 파일별로 그룹화
        files_to_repair = {}
        for ref in self.broken_references:
            if ref.source_file not in files_to_repair:
                files_to_repair[ref.source_file] = []
            files_to_repair[ref.source_file].append(ref)
        
        # 각 파일 수리
        for file_path, references in files_to_repair.items():
            result = self._repair_file_references(file_path, references)
            self.repair_results.append(result)
        
        logger.info(f"총 {len(self.repair_results)}개 파일 수리 완료")
        return self.repair_results

    def _repair_file_references(self, file_path: str, references: List[BrokenReference]) -> RepairResult:
        """개별 파일의 참조 수리"""
        full_path = self.root_path / file_path
        changes_made = []
        
        try:
            # 백업 생성
            backup_created = self.create_backup(full_path)
            
            # 파일 읽기
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # 라인별 수정 (역순으로 처리하여 라인 번호 변경 방지)
            references_sorted = sorted(references, key=lambda x: x.line_number, reverse=True)
            
            for ref in references_sorted:
                if ref.suggested_fix:
                    old_line = lines[ref.line_number - 1]
                    new_line = old_line.replace(ref.referenced_path, ref.suggested_fix)
                    lines[ref.line_number - 1] = new_line
                    changes_made.append(f"Line {ref.line_number}: {ref.referenced_path} → {ref.suggested_fix}")
                else:
                    # 수정 방안이 없으면 주석 처리
                    old_line = lines[ref.line_number - 1]
                    if not old_line.strip().startswith('#'):
                        lines[ref.line_number - 1] = f"# BROKEN_REF: {old_line}"
                        changes_made.append(f"Line {ref.line_number}: 주석 처리 - {ref.referenced_path}")
            
            # 파일 쓰기
            if changes_made:
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
            
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=True,
                changes_made=changes_made,
                backup_created=backup_created
            )
            
        except Exception as e:
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=False,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def standardize_path_references(self) -> List[RepairResult]:
        """경로 참조 표준화"""
        logger.info("경로 참조 표준화 시작...")
        standardization_results = []
        
        # Python 파일들의 경로 참조 표준화
        for py_file in self.root_path.rglob("*.py"):
            result = self._standardize_file_paths(py_file)
            if result:
                standardization_results.append(result)
        
        return standardization_results

    def _standardize_file_paths(self, file_path: Path) -> Optional[RepairResult]:
        """개별 파일의 경로 참조 표준화"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            original_content = content
            changes_made = []
            
            # Windows 경로를 Unix 스타일로 변경
            content = re.sub(r'/+', '/', content)
            if content != original_content:
                changes_made.append("Windows 경로 구분자를 Unix 스타일로 변경")
            
            # 상대 경로 정규화
            content = re.sub(r'/./+', './', content)
            content = re.sub(r'/+', '/', content)
            
            if changes_made:
                # 백업 생성
                backup_created = self.create_backup(file_path)
                
                # 파일 쓰기
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                return RepairResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    repair_type="path_standardization",
                    success=True,
                    changes_made=changes_made,
                    backup_created=backup_created
                )
        
        except Exception as e:
            logger.error(f"경로 표준화 오류 {file_path}: {e}")
        
        return None

    def generate_report(self) -> Dict:
        """수리 보고서 생성"""
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_broken_references": len(self.broken_references),
                "files_repaired": len(self.repair_results),
                "successful_repairs": len([r for r in self.repair_results if r.success]),
                "failed_repairs": len([r for r in self.repair_results if not r.success])
            },
            "broken_references": [
                {
                    "source_file": ref.source_file,
                    "referenced_path": ref.referenced_path,
                    "line_number": ref.line_number,
                    "reference_type": ref.reference_type,
                    "context": ref.context,
                    "suggested_fix": ref.suggested_fix
                }
                for ref in self.broken_references
            ],
            "repair_results": [
                {
                    "file_path": result.file_path,
                    "repair_type": result.repair_type,
                    "success": result.success,
                    "changes_made": result.changes_made,
                    "backup_created": result.backup_created,
                    "error_message": result.error_message
                }
                for result in self.repair_results
            ]
        }
        
        return report

# BROKEN_REF:     def save_report(self, report: Dict, filename: str = "file_reference_repair_report.json"):
        """보고서 파일로 저장"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"보고서 저장: {filename}")

def main():
    """메인 실행 함수"""
    print("🔧 POSCO 시스템 파일 참조 무결성 복구 도구")
    print("=" * 50)
    
    repairer = FileReferenceRepairer()
    
    # 1. 깨진 참조 스캔
    print("/n1️⃣ 파일 참조 스캔 중...")
    broken_refs = repairer.scan_all_references()
    print(f"   ✅ {len(broken_refs)}개의 깨진 참조 발견")
    
    # 2. 참조 수리
    print("/n2️⃣ 파일 참조 수리 중...")
    repair_results = repairer.repair_all_references()
    successful = len([r for r in repair_results if r.success])
    print(f"   ✅ {successful}/{len(repair_results)}개 파일 수리 완료")
    
    # 3. 경로 표준화
    print("/n3️⃣ 경로 참조 표준화 중...")
    std_results = repairer.standardize_path_references()
    print(f"   ✅ {len(std_results)}개 파일 경로 표준화 완료")
    
    # 4. 보고서 생성
    print("/n4️⃣ 수리 보고서 생성 중...")
    report = repairer.generate_report()
    repairer.save_report(report)
    print("   ✅ 보고서 생성 완료")
    
    # 결과 요약
    print(f"/n📊 수리 결과 요약:")
    print(f"   • 발견된 깨진 참조: {len(broken_refs)}개")
    print(f"   • 수리된 파일: {successful}개")
    print(f"   • 표준화된 파일: {len(std_results)}개")
    print(f"   • 백업 디렉토리: {repairer.backup_dir}")
    
    return len(broken_refs) == 0 or successful > 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)