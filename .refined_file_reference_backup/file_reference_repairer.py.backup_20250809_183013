#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³µêµ¬ ë„êµ¬

ì´ ë„êµ¬ëŠ” ë‹¤ìŒ ë¬¸ì œë“¤ì„ í•´ê²°í•©ë‹ˆë‹¤:
- 83ê°œ ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ìˆ˜ì •
- ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ì œê±° ë˜ëŠ” ìˆ˜ì •
- ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ ì˜¤ì¸ì‹ ë¬¸ì œ í•´ê²°
- ìƒëŒ€ ê²½ë¡œ ì°¸ì¡° ì •í™•ì„± ê²€ì¦ ë° í‘œì¤€í™”
"""

import posco_news_250808_monitor.log
import verify_folder_reorganization.py
import test_config.json
# BROKEN_REF: import shutil
# BROKEN_REF: from pathlib import Path
# BROKEN_REF: from typing import Dict, List, Set, Tuple, Optional
# BROKEN_REF: from dataclasses import dataclass
# BROKEN_REF: import logging

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class BrokenReference:
    """ê¹¨ì§„ íŒŒì¼ ì°¸ì¡° ì •ë³´"""
    source_file: str
    referenced_path: str
    line_number: int
    reference_type: str  # 'import', 'file_path', 'config', 'script'
    context: str
    suggested_fix: Optional[str] = None

@dataclass
class RepairResult:
    """ìˆ˜ë¦¬ ê²°ê³¼ ì •ë³´"""
    file_path: str
    repair_type: str
    success: bool
    changes_made: List[str]
    backup_created: bool
    error_message: Optional[str] = None

class FileReferenceRepairer:
    """íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„±ì„ ë³µêµ¬í•˜ëŠ” í´ëž˜ìŠ¤"""
    
    def __init__(self, root_path: str = "."):
        self.root_path = Path(root_path).resolve()
        self.broken_references: List[BrokenReference] = []
        self.repair_results: List[RepairResult] = []
        self.file_mapping: Dict[str, str] = {}
# BROKEN_REF:         self.backup_dir = Path(".file_reference_backup")
        
        # íŒŒì¼ í™•ìž¥ìžë³„ ì²˜ë¦¬ íŒ¨í„´
        self.file_patterns = {
            'python': [r'/.py$'],
            'shell': [r'/.sh$', r'/.command$'],
            'batch': [r'/.bat$'],
            'config': [r'/.json$', r'/.md$', r'/.txt$'],
            'markdown': [r'/.md$']
        }
        
        # ì°¸ì¡° íŒ¨í„´ ì •ì˜
        self.reference_patterns = {
            'import': [
                r'from/s+([^/s]+)/s+import',
                r'import/s+([^/s,]+)',
                r'importlib/.import_module/([/'"]([^/'"]+)[/'"]'
            ],
            'file_path': [
                r'[/'"]([^/'"/s]+/.(py|sh|bat|json|md|txt|log|command))[/'"]',
                r'Path/([/'"]([^/'"]+)[/'"]',
                r'open/([/'"]([^/'"]+)[/'"]',
                r'with/s+open/([/'"]([^/'"]+)[/'"]'
            ],
            'config': [
                r'"([^"]+/.(py|sh|bat|json|md|txt|log))"',
                r"'([^']+/.(py|sh|bat|json|md|txt|log))'"
            ],
            'script': [
                r'python3?/s+([^/s]+/.py)',
                r'bash/s+([^/s]+/.sh)',
                r'/./([^/s]+/.(sh|command|bat))',
                r'exec/s+([^/s]+/.(sh|command|bat))'
            ]
        }

    def create_backup(self, file_path: Path) -> bool:
        """íŒŒì¼ ë°±ì—… ìƒì„±"""
        try:
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True)
            
            backup_path = self.backup_dir / f"{file_path.name}.backup_{self._get_timestamp()}"
            shutil.copy2(file_path, backup_path)
            logger.info(f"ë°±ì—… ìƒì„±: {backup_path}")
            return True
        except Exception as e:
            logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨ {file_path}: {e}")
            return False

    def _get_timestamp(self) -> str:
        """íƒ€ìž„ìŠ¤íƒ¬í”„ ìƒì„±"""
# BROKEN_REF:         from datetime import datetime
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def scan_all_references(self) -> List[BrokenReference]:
        """ëª¨ë“  íŒŒì¼ì˜ ì°¸ì¡°ë¥¼ ìŠ¤ìº”í•˜ì—¬ ê¹¨ì§„ ì°¸ì¡° ì°¾ê¸°"""
        logger.info("íŒŒì¼ ì°¸ì¡° ìŠ¤ìº” ì‹œìž‘...")
        
        # ë¨¼ì € ëª¨ë“  íŒŒì¼ ëª©ë¡ ìƒì„±
        self._build_file_mapping()
        
        # ê° íŒŒì¼ íƒ€ìž…ë³„ë¡œ ìŠ¤ìº”
        for file_type, patterns in self.file_patterns.items():
            for pattern in patterns:
                for file_path in self.root_path.rglob("*"):
                    if file_path.is_file() and re.search(pattern, str(file_path)):
                        self._scan_file_references(file_path, file_type)
        
        logger.info(f"ì´ {len(self.broken_references)}ê°œì˜ ê¹¨ì§„ ì°¸ì¡° ë°œê²¬")
        return self.broken_references

    def _build_file_mapping(self):
        """íŒŒì¼ ë§¤í•‘ í…Œì´ë¸” êµ¬ì¶•"""
        logger.info("íŒŒì¼ ë§¤í•‘ í…Œì´ë¸” êµ¬ì¶• ì¤‘...")
        
        for file_path in self.root_path.rglob("*"):
            if file_path.is_file():
                # íŒŒì¼ëª…ìœ¼ë¡œ ë§¤í•‘
                filename = file_path.name
                relative_path = str(file_path.relative_to(self.root_path))
                
                if filename not in self.file_mapping:
                    self.file_mapping[filename] = []
                self.file_mapping[filename].append(relative_path)
                
                # í™•ìž¥ìž ì—†ëŠ” ì´ë¦„ìœ¼ë¡œë„ ë§¤í•‘
                stem = file_path.stem
                if stem not in self.file_mapping:
                    self.file_mapping[stem] = []
                self.file_mapping[stem].append(relative_path)

    def _scan_file_references(self, file_path: Path, file_type: str):
        """ê°œë³„ íŒŒì¼ì˜ ì°¸ì¡° ìŠ¤ìº”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                for ref_type, patterns in self.reference_patterns.items():
                    for pattern in patterns:
                        matches = re.finditer(pattern, line)
                        for match in matches:
                            referenced_path = match.group(1)
                            if self._is_broken_reference(referenced_path, file_path):
                                broken_ref = BrokenReference(
                                    source_file=str(file_path.relative_to(self.root_path)),
                                    referenced_path=referenced_path,
                                    line_number=line_num,
                                    reference_type=ref_type,
                                    context=line.strip(),
                                    suggested_fix=self._suggest_fix(referenced_path)
                                )
                                self.broken_references.append(broken_ref)
                                
        except Exception as e:
            logger.error(f"íŒŒì¼ ìŠ¤ìº” ì˜¤ë¥˜ {file_path}: {e}")

    def _is_broken_reference(self, referenced_path: str, source_file: Path) -> bool:
        """ì°¸ì¡°ê°€ ê¹¨ì§„ ê²ƒì¸ì§€ í™•ì¸"""
        # ì ˆëŒ€ ê²½ë¡œ í™•ì¸
        if os.path.isabs(referenced_path):
            return not Path(referenced_path).exists()
        
        # ìƒëŒ€ ê²½ë¡œ í™•ì¸
        source_dir = source_file.parent
        full_path = source_dir / referenced_path
        
        if full_path.exists():
            return False
        
        # ë£¨íŠ¸ ê¸°ì¤€ ê²½ë¡œ í™•ì¸
        root_path = self.root_path / referenced_path
        if root_path.exists():
            return False
        
        # ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ í™•ì¸
        if '*' in referenced_path or '?' in referenced_path:
# BROKEN_REF:             import glob
            pattern_path = str(source_dir / referenced_path)
            if glob.glob(pattern_path):
                return False
        
        return True

    def _suggest_fix(self, referenced_path: str) -> Optional[str]:
        """ìˆ˜ì • ë°©ì•ˆ ì œì•ˆ"""
        filename = Path(referenced_path).name
        
        # ì •í™•í•œ íŒŒì¼ëª… ë§¤ì¹­
        if filename in self.file_mapping:
            candidates = self.file_mapping[filename]
            if len(candidates) == 1:
                return candidates[0]
            elif len(candidates) > 1:
                # ê°€ìž¥ ìœ ì‚¬í•œ ê²½ë¡œ ì„ íƒ
                return self._find_best_match(referenced_path, candidates)
        
        # ìœ ì‚¬í•œ íŒŒì¼ëª… ì°¾ê¸°
        similar_files = self._find_similar_files(filename)
        if similar_files:
            return similar_files[0]
        
        return None

    def _find_similar_files(self, filename: str) -> List[str]:
        """ìœ ì‚¬í•œ íŒŒì¼ëª… ì°¾ê¸°"""
        similar = []
        filename_lower = filename.lower()
        
        for mapped_name, paths in self.file_mapping.items():
            if mapped_name.lower() in filename_lower or filename_lower in mapped_name.lower():
                similar.extend(paths)
        
        return similar[:3]  # ìƒìœ„ 3ê°œë§Œ ë°˜í™˜

    def _find_best_match(self, original_path: str, candidates: List[str]) -> str:
        """ê°€ìž¥ ì í•©í•œ ë§¤ì¹˜ ì°¾ê¸°"""
        # ê²½ë¡œ ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ ì„ íƒ
        original_parts = Path(original_path).parts
        best_score = 0
        best_match = candidates[0]
        
        for candidate in candidates:
            candidate_parts = Path(candidate).parts
            score = len(set(original_parts) & set(candidate_parts))
            if score > best_score:
                best_score = score
                best_match = candidate
        
        return best_match

    def repair_all_references(self) -> List[RepairResult]:
        """ëª¨ë“  ê¹¨ì§„ ì°¸ì¡° ìˆ˜ë¦¬"""
        logger.info("íŒŒì¼ ì°¸ì¡° ìˆ˜ë¦¬ ì‹œìž‘...")
        
        # íŒŒì¼ë³„ë¡œ ê·¸ë£¹í™”
        files_to_repair = {}
        for ref in self.broken_references:
            if ref.source_file not in files_to_repair:
                files_to_repair[ref.source_file] = []
            files_to_repair[ref.source_file].append(ref)
        
        # ê° íŒŒì¼ ìˆ˜ë¦¬
        for file_path, references in files_to_repair.items():
            result = self._repair_file_references(file_path, references)
            self.repair_results.append(result)
        
        logger.info(f"ì´ {len(self.repair_results)}ê°œ íŒŒì¼ ìˆ˜ë¦¬ ì™„ë£Œ")
        return self.repair_results

    def _repair_file_references(self, file_path: str, references: List[BrokenReference]) -> RepairResult:
        """ê°œë³„ íŒŒì¼ì˜ ì°¸ì¡° ìˆ˜ë¦¬"""
        full_path = self.root_path / file_path
        changes_made = []
        
        try:
            # ë°±ì—… ìƒì„±
            backup_created = self.create_backup(full_path)
            
            # íŒŒì¼ ì½ê¸°
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # ë¼ì¸ë³„ ìˆ˜ì • (ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ë¼ì¸ ë²ˆí˜¸ ë³€ê²½ ë°©ì§€)
            references_sorted = sorted(references, key=lambda x: x.line_number, reverse=True)
            
            for ref in references_sorted:
                if ref.suggested_fix:
                    old_line = lines[ref.line_number - 1]
                    new_line = old_line.replace(ref.referenced_path, ref.suggested_fix)
                    lines[ref.line_number - 1] = new_line
                    changes_made.append(f"Line {ref.line_number}: {ref.referenced_path} â†’ {ref.suggested_fix}")
                else:
                    # ìˆ˜ì • ë°©ì•ˆì´ ì—†ìœ¼ë©´ ì£¼ì„ ì²˜ë¦¬
                    old_line = lines[ref.line_number - 1]
                    if not old_line.strip().startswith('#'):
                        lines[ref.line_number - 1] = f"# BROKEN_REF: {old_line}"
                        changes_made.append(f"Line {ref.line_number}: ì£¼ì„ ì²˜ë¦¬ - {ref.referenced_path}")
            
            # íŒŒì¼ ì“°ê¸°
            if changes_made:
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
            
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=True,
                changes_made=changes_made,
                backup_created=backup_created
            )
            
        except Exception as e:
            return RepairResult(
                file_path=file_path,
                repair_type="file_reference",
                success=False,
                changes_made=[],
                backup_created=False,
                error_message=str(e)
            )

    def standardize_path_references(self) -> List[RepairResult]:
        """ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”"""
        logger.info("ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™” ì‹œìž‘...")
        standardization_results = []
        
        # Python íŒŒì¼ë“¤ì˜ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”
        for py_file in self.root_path.rglob("*.py"):
            result = self._standardize_file_paths(py_file)
            if result:
                standardization_results.append(result)
        
        return standardization_results

    def _standardize_file_paths(self, file_path: Path) -> Optional[RepairResult]:
        """ê°œë³„ íŒŒì¼ì˜ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™”"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            original_content = content
            changes_made = []
            
            # Windows ê²½ë¡œë¥¼ Unix ìŠ¤íƒ€ì¼ë¡œ ë³€ê²½
            content = re.sub(r'/+', '/', content)
            if content != original_content:
                changes_made.append("Windows ê²½ë¡œ êµ¬ë¶„ìžë¥¼ Unix ìŠ¤íƒ€ì¼ë¡œ ë³€ê²½")
            
            # ìƒëŒ€ ê²½ë¡œ ì •ê·œí™”
            content = re.sub(r'/./+', './', content)
            content = re.sub(r'/+', '/', content)
            
            if changes_made:
                # ë°±ì—… ìƒì„±
                backup_created = self.create_backup(file_path)
                
                # íŒŒì¼ ì“°ê¸°
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                return RepairResult(
                    file_path=str(file_path.relative_to(self.root_path)),
                    repair_type="path_standardization",
                    success=True,
                    changes_made=changes_made,
                    backup_created=backup_created
                )
        
        except Exception as e:
            logger.error(f"ê²½ë¡œ í‘œì¤€í™” ì˜¤ë¥˜ {file_path}: {e}")
        
        return None

    def generate_report(self) -> Dict:
        """ìˆ˜ë¦¬ ë³´ê³ ì„œ ìƒì„±"""
        report = {
            "timestamp": self._get_timestamp(),
            "summary": {
                "total_broken_references": len(self.broken_references),
                "files_repaired": len(self.repair_results),
                "successful_repairs": len([r for r in self.repair_results if r.success]),
                "failed_repairs": len([r for r in self.repair_results if not r.success])
            },
            "broken_references": [
                {
                    "source_file": ref.source_file,
                    "referenced_path": ref.referenced_path,
                    "line_number": ref.line_number,
                    "reference_type": ref.reference_type,
                    "context": ref.context,
                    "suggested_fix": ref.suggested_fix
                }
                for ref in self.broken_references
            ],
            "repair_results": [
                {
                    "file_path": result.file_path,
                    "repair_type": result.repair_type,
                    "success": result.success,
                    "changes_made": result.changes_made,
                    "backup_created": result.backup_created,
                    "error_message": result.error_message
                }
                for result in self.repair_results
            ]
        }
        
        return report

# BROKEN_REF:     def save_report(self, report: Dict, filename: str = "file_reference_repair_report.json"):
        """ë³´ê³ ì„œ íŒŒì¼ë¡œ ì €ìž¥"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        logger.info(f"ë³´ê³ ì„œ ì €ìž¥: {filename}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ðŸ”§ POSCO ì‹œìŠ¤í…œ íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³µêµ¬ ë„êµ¬")
    print("=" * 50)
    
    repairer = FileReferenceRepairer()
    
    # 1. ê¹¨ì§„ ì°¸ì¡° ìŠ¤ìº”
    print("/n1ï¸âƒ£ íŒŒì¼ ì°¸ì¡° ìŠ¤ìº” ì¤‘...")
    broken_refs = repairer.scan_all_references()
    print(f"   âœ… {len(broken_refs)}ê°œì˜ ê¹¨ì§„ ì°¸ì¡° ë°œê²¬")
    
    # 2. ì°¸ì¡° ìˆ˜ë¦¬
    print("/n2ï¸âƒ£ íŒŒì¼ ì°¸ì¡° ìˆ˜ë¦¬ ì¤‘...")
    repair_results = repairer.repair_all_references()
    successful = len([r for r in repair_results if r.success])
    print(f"   âœ… {successful}/{len(repair_results)}ê°œ íŒŒì¼ ìˆ˜ë¦¬ ì™„ë£Œ")
    
    # 3. ê²½ë¡œ í‘œì¤€í™”
    print("/n3ï¸âƒ£ ê²½ë¡œ ì°¸ì¡° í‘œì¤€í™” ì¤‘...")
    std_results = repairer.standardize_path_references()
    print(f"   âœ… {len(std_results)}ê°œ íŒŒì¼ ê²½ë¡œ í‘œì¤€í™” ì™„ë£Œ")
    
    # 4. ë³´ê³ ì„œ ìƒì„±
    print("/n4ï¸âƒ£ ìˆ˜ë¦¬ ë³´ê³ ì„œ ìƒì„± ì¤‘...")
    report = repairer.generate_report()
    repairer.save_report(report)
    print("   âœ… ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ")
    
    # ê²°ê³¼ ìš”ì•½
    print(f"/nðŸ“Š ìˆ˜ë¦¬ ê²°ê³¼ ìš”ì•½:")
    print(f"   â€¢ ë°œê²¬ëœ ê¹¨ì§„ ì°¸ì¡°: {len(broken_refs)}ê°œ")
    print(f"   â€¢ ìˆ˜ë¦¬ëœ íŒŒì¼: {successful}ê°œ")
    print(f"   â€¢ í‘œì¤€í™”ëœ íŒŒì¼: {len(std_results)}ê°œ")
    print(f"   â€¢ ë°±ì—… ë””ë ‰í† ë¦¬: {repairer.backup_dir}")
    
    return len(broken_refs) == 0 or successful > 0

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)