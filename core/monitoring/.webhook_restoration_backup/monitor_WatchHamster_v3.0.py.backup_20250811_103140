#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Monitor Watchhamster V3.0
POSCO ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import subprocess
import os
import sys
import json
import requests
from datetime import datetime, timedelta
import psutil

# ì¶œë ¥ ë²„í¼ë§ í•´ì œ - ì‹¤ì‹œê°„ ë¡œê·¸ ì¶œë ¥ì„ ìœ„í•´
sys.stdout.reconfigure(line_buffering=True)
sys.stderr.reconfigure(line_buffering=True)

# í™˜ê²½ ë³€ìˆ˜ë¡œë„ ì¶œë ¥ ë²„í¼ë§ ë¹„í™œì„±í™”
os.environ['PYTHONUNBUFFERED'] = '1'

# í˜„ì¬ ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬ë¥¼ Python ê²½ë¡œì— ì¶”ê°€
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

try:
    from config import API_CONFIG, DOORAY_WEBHOOK_URL, BOT_PROFILE_IMAGE_URL
    print("[INFO] Configuration loaded successfully")
except ImportError as e:
    print(f"[WARNING] Configuration import failed: {e}")
    # ê¸°ë³¸ ì„¤ì • ì‚¬ìš©
    API_CONFIG = {}
    DOORAY_WEBHOOK_URL = "https://infomax.dooray.com/services/3262462484277387103/4121380745073081229/5FbudzTwTki4wCeBszBrAg"
    BOT_PROFILE_IMAGE_URL = "https://raw.githubusercontent.com/shuserker/infomax_api/main/Monitoring/POSCO_News_250808/posco_logo_mini.jpg"

# í•µì‹¬ ëª¨ë“ˆë“¤ import ì‹œë„
try:
    from core.process_manager import ProcessManager
except ImportError:
    ProcessManager = None
    print("[WARNING] ProcessManager not available")

try:
    from core.state_manager import StateManager
except ImportError:
    StateManager = None
    print("[WARNING] StateManager not available")

try:
    from core.colorful_ui import ColorfulConsoleUI
except ImportError:
    ColorfulConsoleUI = None
    print("[WARNING] ColorfulConsoleUI not available")

# ì¶”ê°€ ëª¨ë‹ˆí„°ë§ ëª¨ë“ˆë“¤
try:
    from backup_archive_20250806.disabled_monitors_20250803.newyork_monitor import NewYorkMarketMonitor
except ImportError:
    NewYorkMarketMonitor = None
    print("[INFO] NewYorkMarketMonitor ë¹„í™œì„±í™”ë¨ - í†µí•© ë¦¬í¬íŠ¸ ì‹œìŠ¤í…œ ì‚¬ìš©")

try:
    from backup_archive_20250806.disabled_monitors_20250803.kospi_monitor import KospiCloseMonitor
except ImportError:
    KospiCloseMonitor = None
    print("[INFO] KospiCloseMonitor ë¹„í™œì„±í™”ë¨")
    
try:
    from backup_archive_20250806.disabled_monitors_20250803.exchange_monitor import ExchangeRateMonitor
except ImportError:
    ExchangeRateMonitor = None
    print("[INFO] ExchangeRateMonitor ë¹„í™œì„±í™”ë¨")

try:
    from backup_archive_20250806.disabled_monitors_20250803.master_news_monitor import MasterNewsMonitor
except ImportError:
    MasterNewsMonitor = None
    print("[INFO] MasterNewsMonitor ë¹„í™œì„±í™”ë¨")

# ê¸°ë³¸ ì„¤ì • ì™„ë£Œ
print("[INFO] ëª¨ë“  ëª¨ë“ˆ import ì™„ë£Œ - ê¸°ë³¸ ê¸°ëŠ¥ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.")

class WatchHamsterV3Monitor:
    """
    POSCO WatchHamster v3.0 ğŸ›¡ï¸ í´ë˜ìŠ¤
    
    ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ì˜ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ëŠ” ìë™ ë³µêµ¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.
    
    ì£¼ìš” ê¸°ëŠ¥:
    - ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ê°ì‹œ (5ë¶„ ê°„ê²©)
    - ìë™ Git ì—…ë°ì´íŠ¸ ì²´í¬ (1ì‹œê°„ ê°„ê²©)
    - í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì‹œ ìë™ ì¬ì‹œì‘
    - Doorayë¥¼ í†µí•œ ìƒíƒœ ì•Œë¦¼ ì „ì†¡
    - ë¡œê·¸ íŒŒì¼ ê´€ë¦¬ ë° ìƒíƒœ ì €ì¥
    
    Attributes:
        script_dir (str): ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œ
        monitor_script (str): ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ
        log_file (str): ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
        status_file (str): ìƒíƒœ íŒŒì¼ ê²½ë¡œ
        monitor_process (subprocess.Popen): ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ê°ì²´
        last_git_check (datetime): ë§ˆì§€ë§‰ Git ì²´í¬ ì‹œê°„
        git_check_interval (int): Git ì²´í¬ ê°„ê²© (ì´ˆ)
        process_check_interval (int): í”„ë¡œì„¸ìŠ¤ ì²´í¬ ê°„ê²© (ì´ˆ)
    """
    
    def __init__(self):
        """
        WatchHamster v3.0.0 í†µí•© ë ˆì´ì–´ êµ¬í˜„
        
        v2 ì»´í¬ë„ŒíŠ¸ë“¤ì„ ì•ˆì „í•˜ê²Œ ë¡œë“œí•˜ê³ , ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±í•˜ëŠ” í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜
        """
        self.script_dir = current_dir
        self.log_file = os.path.join(self.script_dir, ".naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log")
        self.status_file = os.path.join(self.script_dir, ".naming_backup/config_data_backup/.naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster_status.json")
        
        # ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ê°€ë™ ì‹œê°„ ê³„ì‚°ìš©)
        self.start_time = datetime.now()
        
        # ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ê°ì²´ë“¤ (í˜¸í™˜ì„± ìœ ì§€)
        self.monitor_process = None
        self.realtime_process = None
        self.last_git_check = datetime.now() - timedelta(hours=1)  # ì´ˆê¸° ì²´í¬ ê°•ì œ
        
        # v2 í†µí•© ìƒíƒœ ì¶”ì 
        self.v3_0_enabled = False
        self.v3_0_components = {
            'process_manager': None,
            'module_registry': None,
            'notification_manager': None
        }
        self.fallback_reason = None
        
        # v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹œë„
        self._initialize_v3_0_components()
        
        # ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ëª©ë¡ ì„¤ì •
        if self.v3_0_enabled and self.v3_0_components['module_registry']:
            # v2 ë°©ì‹: ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ìë™ ë¡œë“œ
            self.managed_processes = self.v3_0_components['module_registry'].get_startup_order()
            self.log(f"ğŸ“‹ v2 ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ë¡œë“œ: {len(self.managed_processes)}ê°œ")
            for process_name in self.managed_processes:
                self.log(f"  â€¢ {process_name}")
            
            # ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì´ˆê¸°í™”
            self._initialize_module_status_tracking()
        else:
            # ê¸°ì¡´ ë°©ì‹: í•˜ë“œì½”ë”©ëœ í”„ë¡œì„¸ìŠ¤ ëª©ë¡
            self.managed_processes = ['POSCO News 250808_monitor', 'integrated_report_scheduler']
            self.log(f"ğŸ“‹ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ì„¤ì •: {len(self.managed_processes)}ê°œ")
        
        # StateManager ì´ˆê¸°í™” (ì•ˆì •ì„± ê°œì„ )
        if StateManager:
            self.state_manager = StateManager(self.status_file)
        else:
            self.state_manager = None
            self.log("âš ï¸ StateManagerë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ìƒíƒœ ê´€ë¦¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        
        # ColorfulConsoleUI ì´ˆê¸°í™” (ì»¬ëŸ¬í’€í•œ UI)
        if ColorfulConsoleUI:
            self.ui = ColorfulConsoleUI()
        else:
            self.ui = None
        
        # ì´ì „ ìƒíƒœ ë¡œë“œ
        self.load_previous_state()
        
        # ì ˆëŒ€ì‹œê°„ ê¸°ì¤€ ì•Œë¦¼ ì„¤ì •
        self.status_notification_start_hour = 7  # ì‹œì‘ ì‹œê°„ (7ì‹œ)
        self.status_notification_interval_hours = 2  # ê°„ê²© (2ì‹œê°„)
        self.last_status_notification_hour = None  # ë§ˆì§€ë§‰ ì•Œë¦¼ ì‹œê°„ (ì‹œê°„ë§Œ ì €ì¥)
        self.last_status_notification = None  # ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
        self.last_hourly_check_hour = None  # ë§ˆì§€ë§‰ ë§¤ì‹œê°„ ì²´í¬ ì‹œê°„
        
        # ì›Œì¹˜í–„ìŠ¤í„°ëŠ” ìˆœìˆ˜ ì‹œìŠ¤í…œ ê´€ë¦¬ë§Œ ë‹´ë‹¹ - ë‰´ìŠ¤ ê´€ë ¨ ê¸°ëŠ¥ ì œê±°
        # ë‰´ìŠ¤ ê´€ë ¨ ê¸°ëŠ¥ì€ realtime_news_monitor.pyì™€ integrated_report_scheduler.pyì—ì„œ ì²˜ë¦¬
        self.fixed_time_tasks = {}  # ë‰´ìŠ¤ ê´€ë ¨ ê³ ì • ì‘ì—… ì œê±°
        self.executed_fixed_tasks = set()  # í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
        
        self.git_check_interval = 60 * 60 * 4  # 4ì‹œê°„ë§ˆë‹¤ Git ì²´í¬
        self.process_check_interval = 5 * 60  # 5ë¶„ë§ˆë‹¤ í”„ë¡œì„¸ìŠ¤ ì²´í¬ (ë‰´ìŠ¤ ë°œí–‰ ê°„ê²© ê³ ë ¤)
        
        # ìŠ¤ì¼€ì¤„ ì‘ì—… ì¶”ì 
        self.last_scheduled_tasks = {
            'morning_status_check': None,
            'morning_comparison': None,
            'evening_daily_summary': None,
            'evening_detailed_summary': None,
            'evening_advanced_analysis': None,
            'hourly_status_check': None,
            'integrated_report_generation': None,
            'integrated_report_notification': None
        }
        
        # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        try:
            self.api_client = POSCONews250808APIClient(API_CONFIG)
            self.data_processor = NewsDataProcessor()
            self.smart_notifier = DoorayNotifier(DOORAY_WEBHOOK_URL, BOT_PROFILE_IMAGE_URL, self.api_client)
            self.smart_enabled = True
            self.log("ğŸ§  ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            self.log(f"âš ï¸ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.smart_enabled = False
        
        # ê°œë³„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ë¹„í™œì„±í™” (í†µí•© ë¦¬í¬íŠ¸ë¡œ ì „í™˜)
        self.individual_monitors_enabled = False
        self.log("ğŸ”„ ê°œë³„ ëª¨ë‹ˆí„°ë§ ë¹„í™œì„±í™” - í†µí•© ë¦¬í¬íŠ¸ ì‹œìŠ¤í…œìœ¼ë¡œ ì „í™˜ë¨")
        
        # í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì´ˆê¸°í™”
        try:
            pass  # REMOVED
            self.integrated_scheduler = IntegratedReportScheduler()
            self.integrated_scheduler_enabled = True
            self.log("ğŸ“Š í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            self.log(f"âš ï¸ í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.integrated_scheduler_enabled = False
        
        # ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        try:
            if MasterNewsMonitor:
                self.master_monitor = MasterNewsMonitor()
                self.master_monitor_enabled = True
                self.log("ğŸ›ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì—°ê²° ì™„ë£Œ")
            else:
                self.master_monitor_enabled = False
                self.log("âš ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ë¹„í™œì„±í™” (ëª¨ë“ˆ ì—†ìŒ)")
        except Exception as e:
            self.log(f"âš ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.master_monitor_enabled = False
        
        # v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        self.performance_monitor = None
        self.performance_optimizer = None
        self.performance_comparator = None
        self._initialize_performance_monitoring()
    
    def _initialize_v3_0_components(self):
        """
        v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹œìŠ¤í…œ - ë™ì  import test_performance_monitoring/POSCO_News_250808/ğŸ“‹POSCO_ì‹œìŠ¤í…œ_ì •ë¦¬_ë°_ê²€ì¦_ì™„ë£Œ_20250806.md ìƒíƒœ ê²€ì¦
        
        v2 ì»´í¬ë„ŒíŠ¸ë“¤ì„ ë™ì ìœ¼ë¡œ ë¡œë“œí•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ í´ë°±í•˜ëŠ” í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.
        
        êµ¬í˜„ ë‚´ìš©:
                        # REMOVED: ì›ë³¸ ì½”ë“œ
        - ì»´í¬ë„ŒíŠ¸ë³„ ìƒíƒœ ì²´í¬ ë° ê²€ì¦ ì‹œìŠ¤í…œ
        - ì•ˆì „í•œ í´ë°± ë©”ì»¤ë‹ˆì¦˜
        """
        initialization_start = datetime.now()
        
        try:
            self.log("ğŸ”§ v2 ì•„í‚¤í…ì²˜ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹œì‘...")
            
            # 1. v2 ê²½ë¡œ ê²€ì¦ ë° ì„¤ì •
            v2_path = self._setup_v2_paths()
            
            # 2. v2 ì»´í¬ë„ŒíŠ¸ ë™ì  import test_performance_monitoring/POSCO_News_250808/ğŸ“‹POSCO_ì‹œìŠ¤í…œ_ì •ë¦¬_ë°_ê²€ì¦_ì™„ë£Œ_20250806.md ì´ˆê¸°í™”
            self._load_v3_0_components(v2_path)
            
            # 3. ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ê²€ì¦
            self._validate_v3_0_components()
            
            # 4. v2 í†µí•© ì„±ê³µ ì²˜ë¦¬
            self.v3_0_enabled = True
            initialization_time = (datetime.now() - initialization_start).total_seconds()
            
            self.log(f"ğŸ‰ v2 ì•„í‚¤í…ì²˜ í™œì„±í™” ì„±ê³µ! (ì´ˆê¸°í™” ì‹œê°„: {initialization_time:.2f}ì´ˆ)")
            self.log("ğŸ”„ í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œë¡œ ë™ì‘í•©ë‹ˆë‹¤ - v2 ê¸°ëŠ¥ ìš°ì„ , ì‹¤íŒ¨ ì‹œ v1 í´ë°±")
            
            # ì´ˆê¸°í™” ì„±ê³µ í†µê³„ ê¸°ë¡
            self._record_initialization_success(initialization_time)
            
        except Exception as e:
            # v2 ì´ˆê¸°í™” ì‹¤íŒ¨ - ì•ˆì „í•œ í´ë°± ì²˜ë¦¬
            self._handle_v2_initialization_failure(e, initialization_start)
    
    def _setup_v2_paths(self):
        """
        v2 ê²½ë¡œ ì„¤ì • ë° ê²€ì¦
        
        Returns:
            str: v2 ë””ë ‰í† ë¦¬ ê²½ë¡œ
            
        Raises:
            FileNotFoundError: í•„ìˆ˜ íŒŒì¼/ë””ë ‰í† ë¦¬ê°€ ì—†ëŠ” ê²½ìš°
        """
        # v2 ë””ë ‰í† ë¦¬ ê²½ë¡œ ì„¤ì •
        v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
        
        # í•„ìˆ˜ ê²½ë¡œ ê²€ì¦
        required_paths = {
            'v2_directory': v2_path,
            'core_directory': os.path.join(v2_path, 'core'),
            'modules_config': os.path.join(v2_path, 'modules.json')
        }
        
        for path_name, path in required_paths.items():
            if not os.path.exists(path):
                raise FileNotFoundError(f"{path_name}ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}")
        
        # v2 core ëª¨ë“ˆ íŒŒì¼ ê²€ì¦
        core_modules = [
            'Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py',
            'Monitoring/WatchHamster_v3.0/core/module_registry.py', 
            'Monitoring/WatchHamster_v3.0/core/notification_manager.py'
        ]
        
        for module_file in core_modules:
            module_path = os.path.join(required_paths['core_directory'], module_file)
            if not os.path.exists(module_path):
                raise FileNotFoundError(f"v2 í•µì‹¬ ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {module_path}")
        
        self.log(f"âœ… v2 ê²½ë¡œ ê²€ì¦ ì™„ë£Œ: {v2_path}")
        
        # Python ê²½ë¡œì— v2 ë””ë ‰í† ë¦¬ ì¶”ê°€
        if v2_path not in sys.path:
            sys.path.insert(0, v2_path)
            self.log(f"ğŸ“ Python ê²½ë¡œì— v2 ë””ë ‰í† ë¦¬ ì¶”ê°€: {v2_path}")
        
        return v2_path
    
    def _load_v3_0_components(self, v2_path):
        """
        v2 ì»´í¬ë„ŒíŠ¸ ë™ì  import test_performance_monitoring/POSCO_News_250808/ğŸ“‹POSCO_ì‹œìŠ¤í…œ_ì •ë¦¬_ë°_ê²€ì¦_ì™„ë£Œ_20250806.md ì´ˆê¸°í™”
        
        Args:
            v2_path (str): v2 ë””ë ‰í† ë¦¬ ê²½ë¡œ
        """
        # 1. Enhanced ProcessManager ë™ì  ë¡œë“œ
        try:
            self.log("ğŸ”§ Enhanced ProcessManager ë¡œë“œ ì¤‘...")
            
            # importlibë¥¼ ì‚¬ìš©í•œ ë™ì  import
            import importlib.util
            
            # ëª¨ë“ˆ íŒŒì¼ ê²½ë¡œ
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py')
            
            # ëª¨ë“ˆ ìŠ¤í™ ìƒì„±
            spec = importlib.util.spec_from_file_location("enhanced_process_manager", module_path)
            if spec is None:
                raise ImportError(f"ëª¨ë“ˆ ìŠ¤í™ ìƒì„± ì‹¤íŒ¨: {module_path}")
            
            # ëª¨ë“ˆ ë¡œë“œ
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # ProcessManager í´ë˜ìŠ¤ ì¶”ì¶œ
            EnhancedProcessManager = getattr(module, 'ProcessManager')
            
            self.v3_0_components['process_manager'] = EnhancedProcessManager(self.script_dir)
            self.log("âœ… Enhanced ProcessManager ì´ˆê¸°í™” ì™„ë£Œ")
            
        except ImportError as e:
            # REMOVED: raise ImportError(f"Enhanced ProcessManager import ì‹¤íŒ¨: {e}")
            pass
        except Exception as e:
            raise Exception(f"Enhanced ProcessManager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        
        # 2. ModuleRegistry ë™ì  ë¡œë“œ
        try:
            self.log("ğŸ”§ ModuleRegistry ë¡œë“œ ì¤‘...")
            
            # importlibë¥¼ ì‚¬ìš©í•œ ë™ì  import
            import importlib.util
            
            # ëª¨ë“ˆ íŒŒì¼ ê²½ë¡œ
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
            
            # ëª¨ë“ˆ ìŠ¤í™ ìƒì„±
            spec = importlib.util.spec_from_file_location("module_registry", module_path)
            if spec is None:
                raise ImportError(f"ëª¨ë“ˆ ìŠ¤í™ ìƒì„± ì‹¤íŒ¨: {module_path}")
            
            # ëª¨ë“ˆ ë¡œë“œ
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # ModuleRegistry í´ë˜ìŠ¤ ì¶”ì¶œ
            ModuleRegistry = getattr(module, 'ModuleRegistry')
            
            # ë©”ì¸ ì‹œìŠ¤í…œì˜ modules.json ì‚¬ìš© (í˜„ì¬ ë””ë ‰í† ë¦¬)
            modules_json_path = os.path.join(self.script_dir, 'modules.json')
            self.v3_0_components['module_registry'] = ModuleRegistry(modules_json_path)
            self.log("âœ… ModuleRegistry ì´ˆê¸°í™” ì™„ë£Œ")
            
        except ImportError as e:
            pass  # REMOVED
        except Exception as e:
            raise Exception(f"ModuleRegistry ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        
        # 3. NotificationManager ë™ì  ë¡œë“œ
        try:
            self.log("ğŸ”§ NotificationManager ë¡œë“œ ì¤‘...")
            
            # importlibë¥¼ ì‚¬ìš©í•œ ë™ì  import
            import importlib.util
            
            # ëª¨ë“ˆ íŒŒì¼ ê²½ë¡œ
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/notification_manager.py')
            
            # ëª¨ë“ˆ ìŠ¤í™ ìƒì„±
            spec = importlib.util.spec_from_file_location("notification_manager", module_path)
            if spec is None:
                raise ImportError(f"ëª¨ë“ˆ ìŠ¤í™ ìƒì„± ì‹¤íŒ¨: {module_path}")
            
            # ëª¨ë“ˆ ë¡œë“œ
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # NotificationManager í´ë˜ìŠ¤ ì¶”ì¶œ
            NotificationManager = getattr(module, 'NotificationManager')
            
            self.v3_0_components['notification_manager'] = NotificationManager(
                DOORAY_WEBHOOK_URL, 
                BOT_PROFILE_IMAGE_URL
            )
            self.log("âœ… NotificationManager ì´ˆê¸°í™” ì™„ë£Œ")
            
        except ImportError as e:
            pass  # REMOVED
        except Exception as e:
            raise Exception(f"NotificationManager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
    
    def _validate_v3_0_components(self):
        """
        v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ê²€ì¦ ì‹œìŠ¤í…œ
        
        ì´ˆê¸°í™”ëœ v2 ì»´í¬ë„ŒíŠ¸ë“¤ì´ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.
        ê° ì»´í¬ë„ŒíŠ¸ë³„ë¡œ ê¸°ë³¸ ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•˜ì—¬ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
        """
        validation_results = {}
        
        try:
            self.log("ğŸ” v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ê²€ì¦ ì‹œì‘...")
            
            # 1. Enhanced ProcessManager ê²€ì¦
            if self.v3_0_components['process_manager']:
                try:
                    # ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸
                    status = self.v3_0_components['process_manager'].get_system_status()
                    
                    if isinstance(status, dict) and 'timestamp' in status:
                        validation_results['process_manager'] = {
                            'status': 'valid',
                            'details': f"ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ ì„±ê³µ, í”„ë¡œì„¸ìŠ¤ ìˆ˜: {len(status.get('process_details', {}))}"
                        }
                        self.log("âœ… Enhanced ProcessManager ìƒíƒœ ê²€ì¦ ì™„ë£Œ")
                    else:
                        raise ValueError("ProcessManager ìƒíƒœ ì¡°íšŒ ê²°ê³¼ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
                        
                except Exception as e:
                    validation_results['process_manager'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"âŒ Enhanced ProcessManager ê²€ì¦ ì‹¤íŒ¨: {e}")
            
            # 2. ModuleRegistry ê²€ì¦
            if self.v3_0_components['module_registry']:
                try:
                    # ëª¨ë“ˆ ëª©ë¡ ì¡°íšŒ í…ŒìŠ¤íŠ¸
                    modules = self.v3_0_components['module_registry'].list_modules()
                    startup_order = self.v3_0_components['module_registry'].get_startup_order()
                    
                    if isinstance(modules, dict) and isinstance(startup_order, list):
                        validation_results['module_registry'] = {
                            'status': 'valid',
                            'details': f"ëª¨ë“ˆ {len(modules)}ê°œ ë“±ë¡ë¨, ì‹œì‘ ìˆœì„œ {len(startup_order)}ê°œ"
                        }
                        self.log(f"âœ… ModuleRegistry ê²€ì¦ ì™„ë£Œ ({len(modules)}ê°œ ëª¨ë“ˆ)")
                        
                        # ë“±ë¡ëœ ëª¨ë“ˆ ëª©ë¡ ë¡œê·¸
                        for module_name in modules.keys():
                            self.log(f"  ğŸ“‹ ë“±ë¡ëœ ëª¨ë“ˆ: {module_name}")
                    else:
                        raise ValueError("ModuleRegistry ëª¨ë“ˆ ëª©ë¡ ì¡°íšŒ ê²°ê³¼ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
                        
                except Exception as e:
                    validation_results['module_registry'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"âŒ ModuleRegistry ê²€ì¦ ì‹¤íŒ¨: {e}")
            
            # 3. NotificationManager ê²€ì¦
            if self.v3_0_components['notification_manager']:
                try:
                    # ì•Œë¦¼ í†µê³„ ì¡°íšŒ í…ŒìŠ¤íŠ¸
                    stats = self.v3_0_components['notification_manager'].get_notification_stats()
                    
                    if isinstance(stats, dict) and 'total_notifications' in stats:
                        validation_results['notification_manager'] = {
                            'status': 'valid',
                            'details': f"ì•Œë¦¼ í†µê³„ ì¡°íšŒ ì„±ê³µ, ì´ ì•Œë¦¼: {stats.get('total_notifications', 0)}"
                        }
                        self.log("âœ… NotificationManager ê²€ì¦ ì™„ë£Œ")
                    else:
                        raise ValueError("NotificationManager í†µê³„ ì¡°íšŒ ê²°ê³¼ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
                        
                except Exception as e:
                    validation_results['notification_manager'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"âŒ NotificationManager ê²€ì¦ ì‹¤íŒ¨: {e}")
            
            # ê²€ì¦ ê²°ê³¼ ìš”ì•½
            valid_components = sum(1 for result in validation_results.values() if result['status'] == 'valid')
            total_components = len(validation_results)
            
            if valid_components == total_components:
                self.log(f"ğŸ” ëª¨ë“  v2 ì»´í¬ë„ŒíŠ¸ ê²€ì¦ ì™„ë£Œ ({valid_components}/{total_components})")
            else:
                self.log(f"âš ï¸ ì¼ë¶€ v2 ì»´í¬ë„ŒíŠ¸ ê²€ì¦ ì‹¤íŒ¨ ({valid_components}/{total_components})")
                
                # ì‹¤íŒ¨í•œ ì»´í¬ë„ŒíŠ¸ ìƒì„¸ ë¡œê·¸
                for component, result in validation_results.items():
                    if result['status'] == 'invalid':
                        self.log(f"  âŒ {component}: {result['error']}")
            
            # ê²€ì¦ ê²°ê³¼ë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì— ì €ì¥
            self.v2_validation_results = validation_results
            self.log(f"ğŸ“‹ ê²€ì¦ ê²°ê³¼ ì €ì¥ ì™„ë£Œ: {len(validation_results)}ê°œ ì»´í¬ë„ŒíŠ¸")
            
        except Exception as e:
            self.log(f"âŒ v2 ì»´í¬ë„ŒíŠ¸ ê²€ì¦ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")
            # ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ ë¹ˆ ê²°ê³¼ë¼ë„ ì €ì¥
            self.v2_validation_results = {}
            import traceback
            self.log(f"âŒ ê²€ì¦ ì˜ˆì™¸ ìƒì„¸: {traceback.format_exc()}")
            # ê²€ì¦ ì‹¤íŒ¨í•´ë„ v2_enabledëŠ” ìœ ì§€ (ê¸°ë³¸ ê¸°ëŠ¥ì€ ë™ì‘í•  ìˆ˜ ìˆìŒ)
    
    def _initialize_performance_monitoring(self):
        """
        v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        
        ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§, ìµœì í™”, ë¹„êµ ì‹œìŠ¤í…œì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        v2 ì»´í¬ë„ŒíŠ¸ê°€ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ ë™ì‘í•©ë‹ˆë‹¤.
        
        Requirements: 7.1, 7.2, 7.3, 7.4
        """
        try:
            if not self.v3_0_enabled:
                self.log("âš ï¸ v2 ì•„í‚¤í…ì²˜ê°€ ë¹„í™œì„±í™”ë˜ì–´ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤")
                return
            
            self.log("ğŸ“Š v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...")
            
            # v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëª¨ë“ˆ ë™ì  import
            v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
            
            if v2_path not in sys.path:
                sys.path.insert(0, v2_path)
            
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëª¨ë“ˆ import
            import importlib.util
            
            # PerformanceMonitor ë¡œë“œ
            monitor_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/performance_monitor.py')
            spec = importlib.util.spec_from_file_location("performance_monitor", monitor_path)
            monitor_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(monitor_module)
            
            PerformanceMonitor = getattr(monitor_module, 'PerformanceMonitor')
            PerformanceComparator = getattr(monitor_module, 'PerformanceComparator')
            
            # PerformanceOptimizer ë¡œë“œ
            optimizer_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/performance_optimizer.py')
            spec = importlib.util.spec_from_file_location("performance_optimizer", optimizer_path)
            optimizer_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(optimizer_module)
            
            PerformanceOptimizer = getattr(optimizer_module, 'PerformanceOptimizer')
            
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            self.performance_monitor = PerformanceMonitor(
                script_dir=self.script_dir,
                monitoring_interval=300  # 5ë¶„ ê°„ê²©
            )
            
            self.performance_optimizer = PerformanceOptimizer(self.script_dir)
            self.performance_comparator = PerformanceComparator(self.script_dir)
            
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            self.performance_monitor.start_monitoring()
            
            # v1 ê¸°ì¤€ì„  ìˆ˜ì§‘ ë° ì„¤ì • (ë°±ê·¸ë¼ìš´ë“œì—ì„œ)
            try:
                v1_baseline = self.performance_comparator.collect_v1_baseline()
                if v1_baseline:
                    self.performance_monitor.set_v1_baseline(v1_baseline)
                    self.log("ğŸ“Š v1 ì‹œìŠ¤í…œ ê¸°ì¤€ì„  ì„¤ì • ì™„ë£Œ")
            except Exception as e:
                self.log(f"âš ï¸ v1 ê¸°ì¤€ì„  ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            
            self.log("âœ… v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìƒíƒœë¥¼ ì•Œë¦¼ìœ¼ë¡œ ì „ì†¡
            if self.v3_0_components.get('notification_manager'):
                try:
                    self.v3_0_components['notification_manager'].send_notification(
                        "ğŸ¯ POSCO WatchHamster v3.0.0 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤./n"
                        "â€¢ CPU ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì‹¤ì‹œê°„ ì¶”ì /n"
                        "â€¢ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ì‘ë‹µì‹œê°„ ëª¨ë‹ˆí„°ë§/n"
                        "â€¢ v1/v2 ì„±ëŠ¥ ë¹„êµ ë¶„ì„/n"
                        "â€¢ ìë™ ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„±"
                    )
                except Exception as e:
                    self.log(f"âš ï¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
            
        except ImportError as e:
            pass  # REMOVED
            self.performance_monitor = None
            self.performance_optimizer = None
            self.performance_comparator = None
        except Exception as e:
            self.log(f"âŒ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.performance_monitor = None
            self.performance_optimizer = None
            self.performance_comparator = None
    
    def _perform_performance_analysis(self):
        """
        ì„±ëŠ¥ ë¶„ì„ ë° ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„±
        
        10ë¶„ë§ˆë‹¤ ì‹¤í–‰ë˜ì–´ ì‹œìŠ¤í…œ ì„±ëŠ¥ì„ ë¶„ì„í•˜ê³  í•„ìš”ì‹œ ìµœì í™” ê¶Œì¥ì‚¬í•­ì„ ìƒì„±í•©ë‹ˆë‹¤.
        """
        try:
            if not self.performance_monitor or not self.performance_optimizer:
                return
            
            # ì„±ëŠ¥ ìš”ì•½ ì¡°íšŒ
            performance_summary = self.performance_monitor.get_performance_summary()
            
            if 'error' in performance_summary:
                self.log(f"âš ï¸ ì„±ëŠ¥ ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨: {performance_summary['error']}")
                return
            
            # ì„±ëŠ¥ ìˆ˜ì¤€ í‰ê°€
            performance_level = performance_summary.get('performance_level', 'unknown')
            
            # ì„±ëŠ¥ ì´ìŠˆ ë¶„ì„
            issues = self.performance_optimizer.analyze_system_performance(performance_summary)
            
            if issues:
                self.log(f"ğŸ” ì„±ëŠ¥ ì´ìŠˆ {len(issues)}ê°œ ê°ì§€ë¨")
                
                # ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„±
                recommendations = self.performance_optimizer.generate_optimization_recommendations(issues)
                
                if recommendations:
                    self.log(f"ğŸ’¡ ìµœì í™” ê¶Œì¥ì‚¬í•­ {len(recommendations)}ê°œ ìƒì„±ë¨")
                    
                    # ë†’ì€ ìš°ì„ ìˆœìœ„ ê¶Œì¥ì‚¬í•­ì´ ìˆìœ¼ë©´ ì•Œë¦¼ ì „ì†¡
                    high_priority_recs = [
                        rec for rec in recommendations 
                        if rec.priority.value in ['critical', 'high']
                    ]
                    
                    if high_priority_recs and not self.is_quiet_hours():
                        self._send_performance_alert(performance_summary, high_priority_recs)
            
            # v1/v2 ì„±ëŠ¥ ë¹„êµ (1ì‹œê°„ë§ˆë‹¤)
            if (hasattr(self, '_last_performance_comparison') and 
                (datetime.now() - self._last_performance_comparison).total_seconds() >= 3600):
                self._perform_v1_v2_comparison()
                self._last_performance_comparison = datetime.now()
            elif not hasattr(self, '_last_performance_comparison'):
                self._last_performance_comparison = datetime.now()
            
            # ì„±ëŠ¥ ë¡œê·¸ (ë””ë²„ê·¸ìš©)
            current_cpu = performance_summary.get('current', {}).get('cpu_percent', 0)
            current_memory = performance_summary.get('current', {}).get('memory_percent', 0)
            
            self.log(f"ğŸ“Š ì„±ëŠ¥ ìƒíƒœ: CPU {current_cpu:.1f}%, ë©”ëª¨ë¦¬ {current_memory:.1f}%, ìˆ˜ì¤€: {performance_level}")
            
        except Exception as e:
            self.log(f"âŒ ì„±ëŠ¥ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    
    def _send_performance_alert(self, performance_summary: dict, recommendations: list):
        """
        ì„±ëŠ¥ ì•Œë¦¼ ì „ì†¡
        
        Args:
            performance_summary (dict): ì„±ëŠ¥ ìš”ì•½ ì •ë³´
            recommendations (list): ë†’ì€ ìš°ì„ ìˆœìœ„ ê¶Œì¥ì‚¬í•­ ëª©ë¡
        """
        try:
            current_stats = performance_summary.get('current', {})
            
            # ì•Œë¦¼ ë©”ì‹œì§€ êµ¬ì„±
            alert_message = (
                f"âš ï¸ POSCO WatchHamster v3.0.0 ì„±ëŠ¥ ì•Œë¦¼/n/n"
                f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"ğŸ“Š í˜„ì¬ ìƒíƒœ:/n"
                f"  â€¢ CPU ì‚¬ìš©ë¥ : {current_stats.get('cpu_percent', 0):.1f}%/n"
                f"  â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {current_stats.get('memory_percent', 0):.1f}%/n"
                f"  â€¢ í”„ë¡œì„¸ìŠ¤ ìˆ˜: {current_stats.get('process_count', 0)}ê°œ/n"
                f"  â€¢ ì„±ëŠ¥ ìˆ˜ì¤€: {performance_summary.get('performance_level', 'unknown')}/n/n"
                f"ğŸ”§ ê¶Œì¥ì‚¬í•­ ({len(recommendations)}ê°œ):/n"
            )
            
            for i, rec in enumerate(recommendations[:3], 1):  # ìµœëŒ€ 3ê°œë§Œ í‘œì‹œ
                priority_emoji = {"critical": "ğŸš¨", "high": "âš ï¸"}.get(rec.priority.value, "ğŸ“‹")
                alert_message += f"  {i}. {priority_emoji} {rec.title}/n"
                alert_message += f"     ì˜ˆìƒ íš¨ê³¼: {rec.estimated_improvement}/n"
            
            if len(recommendations) > 3:
                alert_message += f"  ... ì™¸ {len(recommendations) - 3}ê°œ ì¶”ê°€ ê¶Œì¥ì‚¬í•­/n"
            
            alert_message += f"/nğŸ’¡ ìì„¸í•œ ë‚´ìš©ì€ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”."
            
            # ì•Œë¦¼ ì „ì†¡
            if self.v3_0_components.get('notification_manager'):
                self.v3_0_components['notification_manager'].send_notification(alert_message, is_error=True)
            else:
                self.send_notification(alert_message, is_error=True)
            
            self.log("ğŸ“¤ ì„±ëŠ¥ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
            
        except Exception as e:
            self.log(f"âŒ ì„±ëŠ¥ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
    
    def _perform_v1_v2_comparison(self):
        """
        v1ê³¼ v2 ì‹œìŠ¤í…œ ì„±ëŠ¥ ë¹„êµ ìˆ˜í–‰
        """
        try:
            if not self.performance_monitor:
                return
            
            # v1/v2 ì„±ëŠ¥ ë¹„êµ ìˆ˜í–‰
            comparison = self.performance_monitor.get_v1_v2_comparison()
            
            if comparison:
                # ë¹„êµ ë³´ê³ ì„œ ìƒì„±
                if self.performance_comparator:
                    report = self.performance_comparator.generate_comparison_report(
                        comparison.v1_metrics, 
                        comparison.v2_metrics
                    )
                    
                    # ë³´ê³ ì„œ ì €ì¥
                    report_file = self.performance_comparator.save_comparison_report(report)
                    
                    if report_file:
                        self.log(f"ğŸ“Š v1/v2 ì„±ëŠ¥ ë¹„êµ ë³´ê³ ì„œ ìƒì„±: {os.path.basename(report_file)}")
                        
                        # ì£¼ìš” ê°œì„ ì‚¬í•­ì´ ìˆìœ¼ë©´ ì•Œë¦¼ ì „ì†¡ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì œì™¸)
                        significant_improvements = [
                            metric for metric, improvement in comparison.improvement_percentage.items()
                            if improvement > 15  # 15% ì´ìƒ ê°œì„ 
                        ]
                        
                        if significant_improvements and not self.is_quiet_hours():
                            improvement_summary = "/n".join([
                                f"  â€¢ {metric}: {comparison.improvement_percentage[metric]:+.1f}% ê°œì„ "
                                for metric in significant_improvements
                            ])
                            
                            comparison_message = (
                                f"ğŸ“ˆ POSCO WatchHamster v3.0.0 ì„±ëŠ¥ ê°œì„  ë³´ê³ /n/n"
                                f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                                f"ğŸ¯ ì£¼ìš” ê°œì„ ì‚¬í•­:/n{improvement_summary}/n/n"
                                f"ğŸ“‹ ìƒì„¸ ë³´ê³ ì„œ: {os.path.basename(report_file)}"
                            )
                            
                            if self.v3_0_components.get('notification_manager'):
                                self.v3_0_components['notification_manager'].send_notification(comparison_message)
                            else:
                                self.send_notification(comparison_message)
            
        except Exception as e:
            self.log(f"âŒ v1/v2 ì„±ëŠ¥ ë¹„êµ ì‹¤íŒ¨: {e}")
    
    def get_performance_status(self):
        """
        ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì¡°íšŒ
        
        Returns:
            dict: ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì •ë³´
        """
        try:
            if not self.performance_monitor:
                return {'error': 'ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤'}
            
            # ì„±ëŠ¥ ìš”ì•½ ì¡°íšŒ
            performance_summary = self.performance_monitor.get_performance_summary()
            
            # ìµœì í™” ìš”ì•½ ì¡°íšŒ
            optimization_summary = {}
            if self.performance_optimizer:
                optimization_summary = self.performance_optimizer.get_optimization_summary()
            
            return {
                'performance_monitoring_enabled': True,
                'performance_summary': performance_summary,
                'optimization_summary': optimization_summary,
                'last_performance_check': getattr(self, '_last_performance_check', None),
                'last_performance_comparison': getattr(self, '_last_performance_comparison', None)
            }
            
        except Exception as e:
            return {'error': f'ì„±ëŠ¥ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}'}
    
    def measure_operation_performance(self, operation_name: str):
        """
        ì‘ì—… ì„±ëŠ¥ ì¸¡ì •ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ë°˜í™˜
        
        Args:
            operation_name (str): ì¸¡ì •í•  ì‘ì—… ì´ë¦„
            
        Returns:
            OperationTimer: ì‘ì—… ì‹œê°„ ì¸¡ì • ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €
        """
        if self.performance_monitor:
            return self.performance_monitor.measure_operation_time(operation_name)
        else:
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„±í™”ëœ ê²½ìš° ë”ë¯¸ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ë°˜í™˜
            class DummyTimer:
                def __enter__(self):
                    return self
                def __exit__(self, exc_type, exc_val, exc_tb):
                    pass
            return DummyTimer()
    
    def _record_initialization_success(self, initialization_time):
        """
        ì´ˆê¸°í™” ì„±ê³µ í†µê³„ ê¸°ë¡
        
        Args:
            initialization_time (float): ì´ˆê¸°í™” ì†Œìš” ì‹œê°„ (ì´ˆ)
        """
        try:
            # ì´ˆê¸°í™” í†µê³„ ì •ë³´
            self.v2_initialization_stats = {
                'success': True,
                'initialization_time': initialization_time,
                'timestamp': datetime.now(),
                'components_loaded': len([c for c in self.v3_0_components.values() if c is not None]),
                'validation_results': getattr(self, 'v2_validation_results', {})
            }
            
            self.log(f"ğŸ“Š v2 ì´ˆê¸°í™” í†µê³„ ê¸°ë¡ ì™„ë£Œ (ì†Œìš”ì‹œê°„: {initialization_time:.2f}ì´ˆ)")
            
        except Exception as e:
            self.log(f"âš ï¸ ì´ˆê¸°í™” í†µê³„ ê¸°ë¡ ì‹¤íŒ¨: {e}")
    
    def _handle_v2_initialization_failure(self, error, initialization_start):
        """
        v2 ì´ˆê¸°í™” ì‹¤íŒ¨ ì²˜ë¦¬ ë° í´ë°±
        
        Args:
            error (Exception): ë°œìƒí•œ ì˜¤ë¥˜
            initialization_start (datetime): ì´ˆê¸°í™” ì‹œì‘ ì‹œê°„
        """
        initialization_time = (datetime.now() - initialization_start).total_seconds()
        
        # v2 ì´ˆê¸°í™” ì‹¤íŒ¨ ìƒíƒœ ì„¤ì •
        self.v3_0_enabled = False
        self.fallback_reason = str(error)
        
        # v2 ì»´í¬ë„ŒíŠ¸ ì •ë¦¬
        self.v3_0_components = {
            'process_manager': None,
            'module_registry': None,
            'notification_manager': None
        }
        
        # ê¸°ì¡´ ProcessManagerë¡œ í´ë°± ì‹œë„
        try:
            self.v3_0_components['process_manager'] = ProcessManager(self.script_dir)
            self.log("âœ… ê¸°ì¡´ ProcessManagerë¡œ í´ë°± ì™„ë£Œ")
        except Exception as fallback_error:
            self.log(f"âŒ ê¸°ì¡´ ProcessManager í´ë°±ë„ ì‹¤íŒ¨: {fallback_error}")
        
        # ì‹¤íŒ¨ í†µê³„ ê¸°ë¡
        self.v2_initialization_stats = {
            'success': False,
            'initialization_time': initialization_time,
            'timestamp': datetime.now(),
            'error': str(error),
            'fallback_reason': self.fallback_reason
        }
        
        self.log(f"âš ï¸ v2 ì•„í‚¤í…ì²˜ ì´ˆê¸°í™” ì‹¤íŒ¨ (ì†Œìš”ì‹œê°„: {initialization_time:.2f}ì´ˆ)")
        self.log(f"âŒ ì‹¤íŒ¨ ì›ì¸: {error}")
        self.log("ğŸ“‹ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±í•˜ì—¬ ì •ìƒ ë™ì‘í•©ë‹ˆë‹¤")
    
    def _initialize_module_status_tracking(self):
        """
        ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        
        ModuleRegistryì™€ ì—°ë™í•˜ì—¬ ê° ëª¨ë“ˆì˜ ìƒíƒœë¥¼ ì¶”ì í•˜ê³  ì œì–´í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        """
        try:
            self.log("ğŸ“Š ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...")
            
            if not self.v3_0_components['module_registry']:
                self.log("âš ï¸ ModuleRegistryê°€ ì—†ì–´ ìƒíƒœ ì¶”ì ì„ ì´ˆê¸°í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                return
            
            # ëª¨ë“ˆë³„ ìƒíƒœ ì¶”ì  ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™”
            self.module_status_tracking = {}
            
            # ë“±ë¡ëœ ëª¨ë“  ëª¨ë“ˆì— ëŒ€í•´ ìƒíƒœ ì¶”ì  ì´ˆê¸°í™”
            modules = self.v3_0_components['module_registry'].list_modules()
            
            for module_name, module_info in modules.items():
                self.module_status_tracking[module_name] = {
                    'config': module_info['config'],
                    'registry_status': module_info['status'],
                    'process_status': 'unknown',  # ì‹¤ì œ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ
                    'last_check': None,
                    'restart_count': 0,
                    'last_restart': None,
                    'health_check_failures': 0,
                    'last_health_check': None
                }
                
                # ModuleRegistryì—ì„œ ì´ˆê¸° ìƒíƒœ ì„¤ì •
                # ModuleStatus enumì„ ë™ì ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
                try:
                    import importlib.util
                    v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
                    module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
                    spec = importlib.util.spec_from_file_location("module_registry", module_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    ModuleStatus = getattr(module, 'ModuleStatus')
                    
                    self.v3_0_components['module_registry'].update_module_status(
                        module_name, 
                        ModuleStatus.REGISTERED
                    )
                except Exception as e:
                    self.log(f"âš ï¸ ModuleStatus ì„¤ì • ì‹¤íŒ¨ ({module_name}): {e}")
            
            self.log(f"âœ… ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì´ˆê¸°í™” ì™„ë£Œ: {len(self.module_status_tracking)}ê°œ ëª¨ë“ˆ")
            
            # ëª¨ë“ˆë³„ ìƒíƒœ ë¡œê·¸
            for module_name in self.module_status_tracking.keys():
                self.log(f"  ğŸ“‹ ì¶”ì  ëŒ€ìƒ ëª¨ë“ˆ: {module_name}")
            
        except Exception as e:
            self.log(f"âŒ ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.module_status_tracking = {}
    
    def update_module_status(self, module_name: str, process_status: str, additional_info: dict = None):
        """
        ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
        
        Args:
            module_name (str): ëª¨ë“ˆ ì´ë¦„
            process_status (str): í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ('running', 'stopped', 'error', 'unknown')
            additional_info (dict): ì¶”ê°€ ì •ë³´
        """
        try:
            current_time = datetime.now()
            
            # ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì •ë³´ê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            if not hasattr(self, 'module_status_tracking'):
                self.module_status_tracking = {}
            
            if module_name not in self.module_status_tracking:
                self.module_status_tracking[module_name] = {
                    'process_status': 'unknown',
                    'last_check': None,
                    'restart_count': 0,
                    'last_restart': None,
                    'health_check_failures': 0,
                    'last_health_check': None
                }
            
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            old_status = self.module_status_tracking[module_name]['process_status']
            self.module_status_tracking[module_name]['process_status'] = process_status
            self.module_status_tracking[module_name]['last_check'] = current_time
            
            # ì¶”ê°€ ì •ë³´ ì—…ë°ì´íŠ¸
            if additional_info:
                self.module_status_tracking[module_name].update(additional_info)
            
            # ModuleRegistry ìƒíƒœë„ ì—…ë°ì´íŠ¸
            if self.v3_0_enabled and self.v3_0_components['module_registry']:
                try:
                    # í”„ë¡œì„¸ìŠ¤ ìƒíƒœì— ë”°ë¥¸ ModuleRegistry ìƒíƒœ ë§¤í•‘
                    try:
                        import importlib.util
                        v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
                        module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
                        spec = importlib.util.spec_from_file_location("module_registry", module_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        ModuleStatus = getattr(module, 'ModuleStatus')
                        
                        if process_status == 'running':
                            registry_status = ModuleStatus.ACTIVE
                        elif process_status == 'stopped':
                            registry_status = ModuleStatus.INACTIVE
                        elif process_status == 'error':
                            registry_status = ModuleStatus.ERROR
                        else:
                            registry_status = ModuleStatus.REGISTERED
                        
                        self.v3_0_components['module_registry'].update_module_status(module_name, registry_status)
                    except Exception as enum_error:
                        self.log(f"âš ï¸ ModuleStatus enum ë¡œë“œ ì‹¤íŒ¨: {enum_error}")
                    
                except Exception as e:
                    self.log(f"âš ï¸ ModuleRegistry ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ ({module_name}): {e}")
            
            # ìƒíƒœ ë³€ê²½ ë¡œê·¸
            if old_status != process_status:
                self.log(f"ğŸ“Š ëª¨ë“ˆ ìƒíƒœ ë³€ê²½: {module_name} ({old_status} â†’ {process_status})")
            
        except Exception as e:
            self.log(f"âŒ ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ ({module_name}): {e}")
    
    def get_module_status_summary(self):
        """
        ëª¨ë“  ëª¨ë“ˆì˜ ìƒíƒœ ìš”ì•½ ì¡°íšŒ
        
        Returns:
            dict: ëª¨ë“ˆ ìƒíƒœ ìš”ì•½ ì •ë³´
        """
        try:
            if not hasattr(self, 'module_status_tracking'):
                return {'error': 'ëª¨ë“ˆ ìƒíƒœ ì¶”ì ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'}
            
            summary = {
                'timestamp': datetime.now().isoformat(),
                'total_modules': len(self.module_status_tracking),
                'status_counts': {
                    'running': 0,
                    'stopped': 0,
                    'error': 0,
                    'unknown': 0
                },
                'modules': {}
            }
            
            # ê° ëª¨ë“ˆ ìƒíƒœ ì§‘ê³„
            for module_name, status_info in self.module_status_tracking.items():
                process_status = status_info['process_status']
                summary['status_counts'][process_status] = summary['status_counts'].get(process_status, 0) + 1
                
                # ëª¨ë“ˆë³„ ìƒì„¸ ì •ë³´
                summary['modules'][module_name] = {
                    'process_status': process_status,
                    'last_check': status_info['last_check'].isoformat() if status_info['last_check'] else None,
                    'restart_count': status_info.get('restart_count', 0),
                    'health_check_failures': status_info.get('health_check_failures', 0)
                }
                
                # ModuleRegistry ìƒíƒœë„ í¬í•¨
                if self.v3_0_enabled and self.v3_0_components['module_registry']:
                    try:
                        registry_status = self.v3_0_components['module_registry'].get_module_status(module_name)
                        summary['modules'][module_name]['registry_status'] = registry_status.value if registry_status else 'unknown'
                    except Exception as e:
                        summary['modules'][module_name]['registry_status'] = f'error: {e}'
            
            return summary
            
        except Exception as e:
            return {'error': f'ìƒíƒœ ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨: {e}'}
    
    def control_module(self, module_name: str, action: str):
        """
        ê°œë³„ ëª¨ë“ˆ ì œì–´ ê¸°ëŠ¥
        
        Args:
            module_name (str): ì œì–´í•  ëª¨ë“ˆ ì´ë¦„
            action (str): ìˆ˜í–‰í•  ì‘ì—… ('start', 'stop', 'restart', 'status')
            
        Returns:
            dict: ì œì–´ ê²°ê³¼
        """
        try:
            self.log(f"ğŸ›ï¸ ëª¨ë“ˆ ì œì–´ ìš”ì²­: {module_name} - {action}")
            
            # ModuleRegistryì—ì„œ ëª¨ë“ˆ ì„¤ì • ì¡°íšŒ
            if not (self.v3_0_enabled and self.v3_0_components['module_registry']):
                return {
                    'success': False,
                    'error': 'v2 ModuleRegistryê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤',
                    'fallback': 'basic_control'
                }
            
            module_config = self.v3_0_components['module_registry'].get_module_config(module_name)
            if not module_config:
                return {
                    'success': False,
                    'error': f'ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {module_name}'
                }
            
            result = {'success': False, 'action': action, 'module': module_name}
            
            if action == 'status':
                # ëª¨ë“ˆ ìƒíƒœ ì¡°íšŒ
                if hasattr(self, 'module_status_tracking') and module_name in self.module_status_tracking:
                    result.update({
                        'success': True,
                        'status': self.module_status_tracking[module_name]
                    })
                else:
                    result.update({
                        'success': True,
                        'status': 'not_tracked'
                    })
            
            elif action == 'start':
                # ëª¨ë“ˆ ì‹œì‘
                if self.v3_0_components['process_manager']:
                    try:
                        # Enhanced ProcessManagerë¥¼ í†µí•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
                        start_result = self.v3_0_components['process_manager'].start_process(
                            module_config.script_path,
                            module_name,
                            working_dir=module_config.working_directory or self.script_dir,
                            env_vars=module_config.environment_vars
                        )
                        
                        if start_result:
                            self.update_module_status(module_name, 'running')
                            result.update({
                                'success': True,
                                'message': f'ëª¨ë“ˆ ì‹œì‘ ì„±ê³µ: {module_name}'
                            })
                        else:
                            result.update({
                                'success': False,
                                'error': f'ëª¨ë“ˆ ì‹œì‘ ì‹¤íŒ¨: {module_name}'
                            })
                    except Exception as e:
                        result.update({
                            'success': False,
                            'error': f'ëª¨ë“ˆ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: {e}'
                        })
                else:
                    result.update({
                        'success': False,
                        'error': 'ProcessManagerê°€ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
                    })
            
            elif action == 'stop':
                # ëª¨ë“ˆ ì¤‘ì§€
                if self.v3_0_components['process_manager']:
                    try:
                        # Enhanced ProcessManagerë¥¼ í†µí•œ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€
                        stop_result = self.v3_0_components['process_manager'].stop_process(module_name)
                        
                        if stop_result:
                            self.update_module_status(module_name, 'stopped')
                            result.update({
                                'success': True,
                                'message': f'ëª¨ë“ˆ ì¤‘ì§€ ì„±ê³µ: {module_name}'
                            })
                        else:
                            result.update({
                                'success': False,
                                'error': f'ëª¨ë“ˆ ì¤‘ì§€ ì‹¤íŒ¨: {module_name}'
                            })
                    except Exception as e:
                        result.update({
                            'success': False,
                            'error': f'ëª¨ë“ˆ ì¤‘ì§€ ì¤‘ ì˜¤ë¥˜: {e}'
                        })
                else:
                    result.update({
                        'success': False,
                        'error': 'ProcessManagerê°€ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
                    })
            
            elif action == 'restart':
                # ëª¨ë“ˆ ì¬ì‹œì‘
                stop_result = self.control_module(module_name, 'stop')
                if stop_result.get('success'):
                    time.sleep(2)  # ì ì‹œ ëŒ€ê¸°
                    start_result = self.control_module(module_name, 'start')
                    result = start_result
                    if start_result.get('success'):
                        result['message'] = f'ëª¨ë“ˆ ì¬ì‹œì‘ ì„±ê³µ: {module_name}'
                else:
                    result = stop_result
            
            else:
                result.update({
                    'success': False,
                    'error': f'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‘ì—…: {action}'
                })
            
            self.log(f"ğŸ›ï¸ ëª¨ë“ˆ ì œì–´ ê²°ê³¼: {module_name} - {action} - {'ì„±ê³µ' if result.get('success') else 'ì‹¤íŒ¨'}")
            return result
            
        except Exception as e:
            error_result = {
                'success': False,
                'error': f'ëª¨ë“ˆ ì œì–´ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}',
                'action': action,
                'module': module_name
            }
            self.log(f"âŒ ëª¨ë“ˆ ì œì–´ ì˜ˆì™¸: {module_name} - {action} - {e}")
            return error_result
    
    def _update_module_status_from_health_check(self, health_results: dict):
        """
        í—¬ìŠ¤ì²´í¬ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
        
        Args:
            health_results (dict): í”„ë¡œì„¸ìŠ¤ë³„ í—¬ìŠ¤ì²´í¬ ê²°ê³¼
        """
        try:
            if not hasattr(self, 'module_status_tracking'):
                return
            
            current_time = datetime.now()
            
            for process_name, is_healthy in health_results.items():
                # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ê²°ì •
                if is_healthy:
                    process_status = 'running'
                    # ì—°ì† ì‹¤íŒ¨ ì¹´ìš´íŠ¸ ë¦¬ì…‹
                    if process_name in self.module_status_tracking:
                        self.module_status_tracking[process_name]['health_check_failures'] = 0
                else:
                    process_status = 'error'
                    # ì—°ì† ì‹¤íŒ¨ ì¹´ìš´íŠ¸ ì¦ê°€
                    if process_name in self.module_status_tracking:
                        self.module_status_tracking[process_name]['health_check_failures'] = \
                            self.module_status_tracking[process_name].get('health_check_failures', 0) + 1
                
                # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
                additional_info = {
                    'last_health_check': current_time,
                    'health_check_result': is_healthy
                }
                
                self.update_module_status(process_name, process_status, additional_info)
            
            # í—¬ìŠ¤ì²´í¬ í†µê³„ ì—…ë°ì´íŠ¸
            if not hasattr(self, 'health_check_stats'):
                self.health_check_stats = {}
            
            self.health_check_stats.update({
                'last_check': current_time,
                'total_modules': len(health_results),
                'healthy_modules': sum(1 for is_healthy in health_results.values() if is_healthy),
                'failed_modules': sum(1 for is_healthy in health_results.values() if not is_healthy)
            })
            
        except Exception as e:
            self.log(f"âŒ í—¬ìŠ¤ì²´í¬ ê¸°ë°˜ ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    

    
    def get_v2_integration_status(self):
        """
        v2 í†µí•© ìƒíƒœ ì •ë³´ ì¡°íšŒ - ìƒì„¸í•œ ì»´í¬ë„ŒíŠ¸ ìƒíƒœ í¬í•¨
        
        Returns:
            dict: v2 í†µí•© ìƒíƒœ ì •ë³´
        """
        try:
            current_time = datetime.now()
            
            # ê¸°ë³¸ ìƒíƒœ ì •ë³´
            status = {
                'v3_0_enabled': self.v3_0_enabled,
                'fallback_reason': self.fallback_reason,
                'timestamp': current_time.isoformat(),
                'components': {
                    'process_manager': self.v3_0_components['process_manager'] is not None,
                    'module_registry': self.v3_0_components['module_registry'] is not None,
                    'notification_manager': self.v3_0_components['notification_manager'] is not None
                },
                'managed_processes_count': len(self.managed_processes),
                'managed_processes': self.managed_processes
            }
            
            # ì´ˆê¸°í™” í†µê³„ ì •ë³´ ì¶”ê°€
            if hasattr(self, 'v2_initialization_stats'):
                status['initialization_stats'] = self.v2_initialization_stats
            
            # ê²€ì¦ ê²°ê³¼ ì¶”ê°€
            if hasattr(self, 'v2_validation_results'):
                status['validation_results'] = self.v2_validation_results
            
            # v2 ì»´í¬ë„ŒíŠ¸ë³„ ìƒì„¸ ì •ë³´
            if self.v3_0_enabled:
                # Enhanced ProcessManager ìƒíƒœ
                if self.v3_0_components['process_manager']:
                    try:
                        system_status = self.v3_0_components['process_manager'].get_system_status()
                        status['system_metrics'] = system_status.get('system_metrics', {})
                        status['process_details'] = system_status.get('process_details', {})
                        status['process_manager_status'] = 'operational'
                    except Exception as e:
                        status['process_manager_error'] = str(e)
                        status['process_manager_status'] = 'error'
                
                # ModuleRegistry ìƒíƒœ
                if self.v3_0_components['module_registry']:
                    try:
                        modules = self.v3_0_components['module_registry'].list_modules()
                        startup_order = self.v3_0_components['module_registry'].get_startup_order()
                        
                        status['registered_modules'] = list(modules.keys())
                        status['startup_order'] = startup_order
                        status['module_registry_status'] = 'operational'
                        
                        # ëª¨ë“ˆë³„ ìƒì„¸ ì •ë³´
                        module_details = {}
                        for module_name, module_config in modules.items():
                            module_details[module_name] = {
                                'auto_start': module_config.auto_start,
                                'priority': module_config.priority,
                                'dependencies': module_config.dependencies,
                                'max_restart_attempts': module_config.max_restart_attempts
                            }
                        status['module_details'] = module_details
                        
                    except Exception as e:
                        status['module_registry_error'] = str(e)
                        status['module_registry_status'] = 'error'
                
                # NotificationManager ìƒíƒœ
                if self.v3_0_components['notification_manager']:
                    try:
                        notification_stats = self.v3_0_components['notification_manager'].get_notification_stats()
                        status['notification_stats'] = notification_stats
                        status['notification_manager_status'] = 'operational'
                    except Exception as e:
                        status['notification_manager_error'] = str(e)
                        status['notification_manager_status'] = 'error'
            
            return status
            
        except Exception as e:
            return {
                'error': f"ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}",
                'v3_0_enabled': False,
                'timestamp': datetime.now().isoformat()
            }
    
    def check_v2_component_health(self):
        """
        v2 ì»´í¬ë„ŒíŠ¸ í—¬ìŠ¤ì²´í¬ ìˆ˜í–‰
        
        Returns:
            dict: ì»´í¬ë„ŒíŠ¸ë³„ í—¬ìŠ¤ì²´í¬ ê²°ê³¼
        """
        health_results = {}
        
        try:
            if not self.v3_0_enabled:
                return {
                    'overall_status': 'disabled',
                    'reason': 'v2 ì•„í‚¤í…ì²˜ê°€ ë¹„í™œì„±í™”ë¨',
                    'fallback_reason': self.fallback_reason
                }
            
            # Enhanced ProcessManager í—¬ìŠ¤ì²´í¬
            if self.v3_0_components['process_manager']:
                try:
                    # ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒë¡œ í—¬ìŠ¤ì²´í¬
                    system_status = self.v3_0_components['process_manager'].get_system_status()
                    health_results['process_manager'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"í”„ë¡œì„¸ìŠ¤ {len(system_status.get('process_details', {}))}ê°œ ê´€ë¦¬ ì¤‘"
                    }
                except Exception as e:
                    health_results['process_manager'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # ModuleRegistry í—¬ìŠ¤ì²´í¬
            if self.v3_0_components['module_registry']:
                try:
                    # ëª¨ë“ˆ ëª©ë¡ ì¡°íšŒë¡œ í—¬ìŠ¤ì²´í¬
                    modules = self.v3_0_components['module_registry'].list_modules()
                    health_results['module_registry'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"ëª¨ë“ˆ {len(modules)}ê°œ ë“±ë¡ë¨"
                    }
                except Exception as e:
                    health_results['module_registry'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # NotificationManager í—¬ìŠ¤ì²´í¬
            if self.v3_0_components['notification_manager']:
                try:
                    # ì•Œë¦¼ í†µê³„ ì¡°íšŒë¡œ í—¬ìŠ¤ì²´í¬
                    stats = self.v3_0_components['notification_manager'].get_notification_stats()
                    health_results['notification_manager'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"ì´ ì•Œë¦¼ {stats.get('total_notifications', 0)}ê°œ ì „ì†¡ë¨"
                    }
                except Exception as e:
                    health_results['notification_manager'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # ì „ì²´ ìƒíƒœ íŒë‹¨
            healthy_components = sum(1 for result in health_results.values() 
                                   if result.get('status') == 'healthy')
            total_components = len(health_results)
            
            if healthy_components == total_components:
                overall_status = 'healthy'
            elif healthy_components > 0:
                overall_status = 'partially_healthy'
            else:
                overall_status = 'unhealthy'
            
            health_results['overall_status'] = overall_status
            health_results['healthy_components'] = healthy_components
            health_results['total_components'] = total_components
            health_results['check_timestamp'] = datetime.now().isoformat()
            
            return health_results
            
        except Exception as e:
            return {
                'overall_status': 'error',
                'error': str(e),
                'check_timestamp': datetime.now().isoformat()
            }
    
    def handle_process_failure_v3_0(self, process_name: str):
        """
        v2 ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ì²˜ë¦¬
        
        3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬ ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ë¥¼ ë³µêµ¬í•©ë‹ˆë‹¤.
        
        êµ¬í˜„ ë‚´ìš©:
        - v2 ProcessManagerì˜ auto_recovery() ë©”ì„œë“œ ì‚¬ìš©
        - 3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ: ì¦‰ì‹œ ì¬ì‹œì‘ â†’ 5ë¶„ í›„ ì¬ì‹œë„ â†’ ìµœì¢… ì¬ì‹œë„
        - ë³µêµ¬ ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¥¸ ì•Œë¦¼ ì „ì†¡
        - í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¶”ì  ë° ë¡œê¹…
        
        Args:
            process_name (str): ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ ì´ë¦„
        """
        try:
            if not self.v3_0_enabled or not self.v3_0_components['process_manager']:
                self.log(f"âš ï¸ v2 ì•„í‚¤í…ì²˜ ë¹„í™œì„±í™”, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬: {process_name}")
                self._handle_process_failure_legacy(process_name)
                return
            
            self.log(f"ğŸ”§ v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ ì‹œì‘: {process_name}")
            
            # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì¡°íšŒ
            process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
            if not process_info:
                self.log(f"âŒ {process_name}: í”„ë¡œì„¸ìŠ¤ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                # ìƒˆ í”„ë¡œì„¸ìŠ¤ë¡œ ë“±ë¡í•˜ì—¬ ë³µêµ¬ ì‹œë„
                self._register_new_process_for_recovery(process_name)
                return
            
            # í˜„ì¬ ì¬ì‹œì‘ íšŸìˆ˜ ê¸°ë¡
            current_restart_count = process_info.restart_count
            recovery_start_time = datetime.now()
            
            self.log(f"ğŸ“Š {process_name} ë³µêµ¬ ì‹œì‘ - í˜„ì¬ ì¬ì‹œì‘ íšŸìˆ˜: {current_restart_count}/3")
            
            # ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ (ë³µêµ¬ ì‹œì‘ ì „)
            if self.v3_0_components['notification_manager']:
                error_details = {
                    'error_message': process_info.last_error or 'í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨ë¨',
                    'restart_count': current_restart_count,
                    'max_attempts': 3,
                    'auto_recovery_enabled': True,
                    'recovery_stage': 'starting'
                }
                self.v3_0_components['notification_manager'].send_process_error(process_name, error_details)
            
            # v2 ProcessManagerì˜ 3ë‹¨ê³„ ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ ì‹¤í–‰
            recovery_success = self.v3_0_components['process_manager'].auto_recovery(process_name)
            
            recovery_end_time = datetime.now()
            recovery_duration = (recovery_end_time - recovery_start_time).total_seconds()
            
            if recovery_success:
                # ë³µêµ¬ ì„±ê³µ ì²˜ë¦¬
                new_process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                recovery_stage = new_process_info.restart_count if new_process_info else current_restart_count + 1
                
                self.log(f"âœ… {process_name} ìë™ ë³µêµ¬ ì„±ê³µ - {recovery_stage}ë‹¨ê³„ ë³µêµ¬ ì™„ë£Œ (ì†Œìš”ì‹œê°„: {recovery_duration:.1f}ì´ˆ)")
                
                # v2 í–¥ìƒëœ ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì‚¬ìš©
                recovery_details = {
                    'recovery_stage': f"{recovery_stage}ë‹¨ê³„ ë³µêµ¬",
                    'recovery_time': recovery_duration,
                    'new_pid': new_process_info.pid if new_process_info else None,
                    'previous_restart_count': current_restart_count,
                    'current_restart_count': recovery_stage
                }
                self.send_recovery_success_v2(process_name, recovery_details)
                
                # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ (ModuleRegistry ì‚¬ìš©)
                if self.v3_0_components['module_registry']:
                    try:
                        # REMOVED: ì›ë³¸ ì½”ë“œ
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.ACTIVE)
                        self.log(f"ğŸ“‹ {process_name} ëª¨ë“ˆ ìƒíƒœë¥¼ ACTIVEë¡œ ì—…ë°ì´íŠ¸")
                    except Exception as e:
                        self.log(f"âš ï¸ {process_name} ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
                
            else:
                # ë³µêµ¬ ì‹¤íŒ¨ ì²˜ë¦¬
                final_process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                final_restart_count = final_process_info.restart_count if final_process_info else 3
                
                self.log(f"âŒ {process_name} ìë™ ë³µêµ¬ ì‹¤íŒ¨ - ëª¨ë“  ë³µêµ¬ ë‹¨ê³„ ì‹¤íŒ¨ (ì´ {final_restart_count}íšŒ ì‹œë„)")
                
                # v2 NotificationManagerë¥¼ ì‚¬ìš©í•œ ê¸´ê¸‰ ì•Œë¦¼
                if self.v3_0_components['notification_manager']:
                    critical_details = {
                        'ìµœëŒ€_ì¬ì‹œì‘_íšŸìˆ˜': f'{final_restart_count}íšŒ ì´ˆê³¼',
                        'í”„ë¡œì„¸ìŠ¤_ìƒíƒœ': 'ë¹„í™œì„±í™”ë¨',
                        'ë³µêµ¬_ì†Œìš”ì‹œê°„': f'{recovery_duration:.1f}ì´ˆ',
                        'ë§ˆì§€ë§‰_ì˜¤ë¥˜': final_process_info.last_error if final_process_info else 'ì•Œ ìˆ˜ ì—†ìŒ',
                        'í•„ìš”_ì¡°ì¹˜': 'ìˆ˜ë™ í™•ì¸ ë° ì¬ì‹œì‘'
                    }
                    # v2 í–¥ìƒëœ ê¸´ê¸‰ ì•Œë¦¼ ì‚¬ìš©
                    self.send_critical_alert_v2(f"{process_name} í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì‹¤íŒ¨", critical_details)
                
                # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ (ModuleRegistry ì‚¬ìš©)
                if self.v3_0_components['module_registry']:
                    try:
                        # REMOVED: ì›ë³¸ ì½”ë“œ
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.FAILED)
                        self.log(f"ğŸ“‹ {process_name} ëª¨ë“ˆ ìƒíƒœë¥¼ FAILEDë¡œ ì—…ë°ì´íŠ¸")
                    except Exception as e:
                        self.log(f"âš ï¸ {process_name} ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
                
        except Exception as e:
            self.log(f"âŒ v2 í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            # ì˜ˆì™¸ ë°œìƒ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
            self._handle_process_failure_legacy(process_name)
    
    def _handle_process_failure_legacy(self, process_name: str):
        """
        ê¸°ì¡´ ë°©ì‹ì˜ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ì²˜ë¦¬ (v2 í´ë°±ìš©)
        
        Args:
            process_name (str): ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ ì´ë¦„
        """
        try:
            self.log(f"ğŸ”„ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ {process_name} ë³µêµ¬ ì‹œë„")
            
            # ê¸°ì¡´ ProcessManager ì‚¬ìš© (ìˆëŠ” ê²½ìš°)
            if self.v3_0_components['process_manager'] and hasattr(self.v3_0_components['process_manager'], 'restart_process'):
                success = self.v3_0_components['process_manager'].restart_process(process_name)
                if success:
                    self.log(f"âœ… {process_name} ê¸°ì¡´ ë°©ì‹ ë³µêµ¬ ì„±ê³µ")
                    self.send_notification(
                        f"âœ… POSCO WatchHamster v3.0 í”„ë¡œì„¸ìŠ¤ ë³µêµ¬/n/n"
                        f"ğŸ“‹ í”„ë¡œì„¸ìŠ¤: {process_name}/n"
                        f"ğŸ”§ ë³µêµ¬ ë°©ì‹: ê¸°ì¡´ ë°©ì‹ (v2 í´ë°±)/n"
                        f"ğŸ¯ í”„ë¡œì„¸ìŠ¤ê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤."
                    )
                else:
                    self.log(f"âŒ {process_name} ê¸°ì¡´ ë°©ì‹ ë³µêµ¬ ì‹¤íŒ¨")
                    self.send_notification(
                        f"âŒ POSCO WatchHamster v3.0 í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì‹¤íŒ¨/n/n"
                        f"ğŸ“‹ í”„ë¡œì„¸ìŠ¤: {process_name}/n"
                        f"ğŸ”§ ë³µêµ¬ ë°©ì‹: ê¸°ì¡´ ë°©ì‹ (v2 í´ë°±)/n"
                        f"ğŸ› ï¸ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                        is_error=True
                    )
            else:
                self.log(f"âš ï¸ {process_name}: ì‚¬ìš© ê°€ëŠ¥í•œ ë³µêµ¬ ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤")
                
        except Exception as e:
            self.log(f"âŒ ê¸°ì¡´ ë°©ì‹ í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì˜¤ë¥˜: {e}")
    
    def _register_new_process_for_recovery(self, process_name: str):
        """
        ë³µêµ¬ë¥¼ ìœ„í•´ ìƒˆ í”„ë¡œì„¸ìŠ¤ë¥¼ ë“±ë¡
        
        Args:
            process_name (str): ë“±ë¡í•  í”„ë¡œì„¸ìŠ¤ ì´ë¦„
        """
        try:
            if not self.v3_0_components['module_registry']:
                return
            
            # ëª¨ë“ˆ ì„¤ì •ì—ì„œ í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì¡°íšŒ
            module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
            if module_config:
                self.log(f"ğŸ”„ {process_name} ìƒˆ í”„ë¡œì„¸ìŠ¤ë¡œ ë“±ë¡í•˜ì—¬ ë³µêµ¬ ì‹œë„")
                success = self.v3_0_components['process_manager'].start_process(
                    process_name,
                    module_config.script_path,
                    [],
                    module_config.working_directory
                )
                if success:
                    self.log(f"âœ… {process_name} ìƒˆ í”„ë¡œì„¸ìŠ¤ ë“±ë¡ ë° ì‹œì‘ ì„±ê³µ")
                else:
                    self.log(f"âŒ {process_name} ìƒˆ í”„ë¡œì„¸ìŠ¤ ë“±ë¡ ì‹¤íŒ¨")
            else:
                self.log(f"âŒ {process_name}: ëª¨ë“ˆ ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                
        except Exception as e:
            self.log(f"âŒ ìƒˆ í”„ë¡œì„¸ìŠ¤ ë“±ë¡ ì˜¤ë¥˜: {e}")
    
    def integrate_v2_process_lifecycle_management(self):
        """
        v2 ProcessManagerì™€ ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•©
        
        ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ë¡œì§ì„ v2 ProcessManagerì˜ í–¥ìƒëœ ê¸°ëŠ¥ê³¼ í†µí•©í•˜ì—¬
        ë” ì•ˆì •ì ì´ê³  ì§€ëŠ¥ì ì¸ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
        
        êµ¬í˜„ ë‚´ìš©:
        - ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ê°ì²´ë¥¼ v2 ProcessManagerë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
        - v2ì˜ 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”
        - í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¶”ì  ë° ë©”íŠ¸ë¦­ ìˆ˜ì§‘ í†µí•©
        - í–¥ìƒëœ ì•Œë¦¼ ì‹œìŠ¤í…œ ì—°ë™
        """
        try:
            if not self.v3_0_enabled or not self.v3_0_components['process_manager']:
                self.log("âš ï¸ v2 ì•„í‚¤í…ì²˜ ë¹„í™œì„±í™”, í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í†µí•© ê±´ë„ˆëœ€")
                return False
            
            self.log("ğŸ”„ v2 ProcessManagerì™€ ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•© ì‹œì‘")
            
            integration_start_time = datetime.now()
            migrated_processes = []
            failed_migrations = []
            
            # 1. ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ê°ì²´ë“¤ì„ v2 ProcessManagerë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
            existing_processes = getattr(self, 'monitor_process', None), getattr(self, 'realtime_process', None)
            
            for process_obj in existing_processes:
                if process_obj and hasattr(process_obj, 'pid'):
                    try:
                        # ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ë¥¼ v2 ProcessManagerì— ë“±ë¡
                        process_name = self._identify_process_name(process_obj)
                        if process_name:
                            # v2 ProcessManagerì— ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì •ë³´ ë“±ë¡
                            self._migrate_existing_process_to_v2(process_name, process_obj)
                            migrated_processes.append(process_name)
                            self.log(f"âœ… {process_name} v2 ProcessManagerë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ")
                        
                    except Exception as e:
                        failed_migrations.append(f"Unknown Process: {e}")
                        self.log(f"âŒ í”„ë¡œì„¸ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: {e}")
            
            # 2. ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ë“¤ì˜ v2 í†µí•© ìƒíƒœ í™•ì¸
            for process_name in self.managed_processes:
                if process_name not in migrated_processes:
                    # ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ë¡œ v2 ì‹œìŠ¤í…œì— ë“±ë¡
                    try:
                        module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                        if module_config:
                            # v2 ProcessManagerì— í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì´ˆê¸°í™”
                            self.v3_0_components['process_manager']._initialize_process_info(process_name)
                            migrated_processes.append(process_name)
                            self.log(f"ğŸ“‹ {process_name} v2 ì‹œìŠ¤í…œì— ìƒˆë¡œ ë“±ë¡ë¨")
                        
                    except Exception as e:
                        failed_migrations.append(f"{process_name}: {e}")
                        self.log(f"âŒ {process_name} v2 ë“±ë¡ ì‹¤íŒ¨: {e}")
            
            # 3. v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”
            if migrated_processes:
                self.log("ğŸ›¡ï¸ v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”")
                
                # ë³µêµ¬ ì‹œìŠ¤í…œ ì„¤ì • ì ìš©
                for process_name in migrated_processes:
                    try:
                        process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                        if process_info:
                            # ë³µêµ¬ ì‹œìŠ¤í…œ ë©”íƒ€ë°ì´í„° ì„¤ì •
                            process_info.recovery_enabled = True
                            process_info.max_recovery_attempts = 3
                            process_info.recovery_stages = ['immediate', '5min_delay', 'final_attempt']
                            
                            self.log(f"ğŸ”§ {process_name} 3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ ì„¤ì • ì™„ë£Œ")
                        
                    except Exception as e:
                        self.log(f"âš ï¸ {process_name} ë³µêµ¬ ì‹œìŠ¤í…œ ì„¤ì • ì‹¤íŒ¨: {e}")
            
            # 4. í†µí•© ì™„ë£Œ ì²˜ë¦¬
            integration_end_time = datetime.now()
            integration_duration = (integration_end_time - integration_start_time).total_seconds()
            
            success_count = len(migrated_processes)
            failure_count = len(failed_migrations)
            
            self.log(f"ğŸ“Š v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í†µí•© ì™„ë£Œ:")
            self.log(f"  âœ… ì„±ê³µ: {success_count}ê°œ í”„ë¡œì„¸ìŠ¤")
            self.log(f"  âŒ ì‹¤íŒ¨: {failure_count}ê°œ í”„ë¡œì„¸ìŠ¤")
            self.log(f"  â±ï¸ ì†Œìš”ì‹œê°„: {integration_duration:.2f}ì´ˆ")
            
            if success_count > 0:
                # í†µí•© ì„±ê³µ ì•Œë¦¼
                if self.v3_0_components['notification_manager']:
                    integration_details = {
                        'migrated_processes': migrated_processes,
                        'failed_migrations': failed_migrations,
                        'integration_time': integration_duration,
                        'recovery_system_enabled': True
                    }
                    self.v3_0_components['notification_manager'].send_integration_success_notification(integration_details)
                else:
                    # ê¸°ì¡´ ë°©ì‹ ì•Œë¦¼
                    self.send_notification(
                        f"ğŸ”„ POSCO WatchHamster v3.0.0 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í†µí•© ì™„ë£Œ/n/n"
                        f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"âœ… í†µí•© ì„±ê³µ: {success_count}ê°œ í”„ë¡œì„¸ìŠ¤/n"
                        f"âŒ í†µí•© ì‹¤íŒ¨: {failure_count}ê°œ í”„ë¡œì„¸ìŠ¤/n"
                        f"â±ï¸ ì†Œìš”ì‹œê°„: {integration_duration:.2f}ì´ˆ/n"
                        f"ğŸ›¡ï¸ 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”ë¨/n"
                        f"ğŸ¯ í–¥ìƒëœ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤."
                    )
                
                return True
            else:
                # í†µí•© ì‹¤íŒ¨
                self.log("âŒ v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í†µí•© ì‹¤íŒ¨ - ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            self.log(f"âŒ v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í†µí•© ì˜¤ë¥˜: {e}")
            import traceback
            self.log(f"âŒ ìƒì„¸ ì˜¤ë¥˜: {traceback.format_exc()}")
            return False
    
    def _identify_process_name(self, process_obj):
        """
        í”„ë¡œì„¸ìŠ¤ ê°ì²´ì—ì„œ í”„ë¡œì„¸ìŠ¤ ì´ë¦„ ì‹ë³„
        
        Args:
            process_obj: í”„ë¡œì„¸ìŠ¤ ê°ì²´
            
        Returns:
            str: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ ë˜ëŠ” None
        """
        try:
            if hasattr(process_obj, 'args') and process_obj.args:
                # ëª…ë ¹í–‰ ì¸ìˆ˜ì—ì„œ ìŠ¤í¬ë¦½íŠ¸ ì´ë¦„ ì¶”ì¶œ
                script_path = process_obj.args[-1] if isinstance(process_obj.args, list) else str(process_obj.args)
                script_name = os.path.basename(script_path).replace('.py', '')
                
                # ì•Œë ¤ì§„ í”„ë¡œì„¸ìŠ¤ ì´ë¦„ê³¼ ë§¤ì¹­
                known_processes = {
                    'posco_main_notifier': 'posco_main_notifier',
                    'realtime_news_monitor': 'realtime_news_monitor',
                    'integrated_report_scheduler': 'integrated_report_scheduler',
                    'historical_data_collector': 'historical_data_collector'
                }
                
                return known_processes.get(script_name, script_name)
            
            return None
            
        except Exception as e:
            self.log(f"âš ï¸ í”„ë¡œì„¸ìŠ¤ ì´ë¦„ ì‹ë³„ ì‹¤íŒ¨: {e}")
            return None
    
    def _migrate_existing_process_to_v3_0(self, process_name: str, process_obj):
        """
        ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ë¥¼ v2 ProcessManagerë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            process_obj: ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ê°ì²´
        """
        try:
            # v2 ProcessManagerì— ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ë“±ë¡
                        # REMOVED: ì›ë³¸ ì½”ë“œ
            
            # ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì •ë³´ë¥¼ v2 í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            process_info = ProcessInfo(
                name=process_name,
                pid=process_obj.pid,
                status=ProcessStatus.RUNNING if process_obj.poll() is None else ProcessStatus.STOPPED,
                start_time=datetime.now(),  # ì •í™•í•œ ì‹œì‘ ì‹œê°„ì€ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í˜„ì¬ ì‹œê°„ ì‚¬ìš©
                last_health_check=datetime.now(),
                restart_count=0,
                last_error=None
            )
            
            # v2 ProcessManagerì— ë“±ë¡
            self.v3_0_components['process_manager'].processes[process_name] = process_obj
            self.v3_0_components['process_manager'].process_info[process_name] = process_info
            
            self.log(f"ğŸ“‹ {process_name} v2 ProcessManagerì— ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ (PID: {process_obj.pid})")
            
        except Exception as e:
            self.log(f"âŒ {process_name} v2 ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: {e}")
            raise
    
    def _create_system_status_object_v3_0(self, current_time, health_results):
        """
        v2 NotificationManagerìš© ì‹œìŠ¤í…œ ìƒíƒœ ê°ì²´ ìƒì„±
        
        Args:
            current_time (datetime): í˜„ì¬ ì‹œê°„
            health_results (dict): í—¬ìŠ¤ì²´í¬ ê²°ê³¼
            
        Returns:
            SystemStatus: ì‹œìŠ¤í…œ ìƒíƒœ ê°ì²´
        """
        try:
            pass  # REMOVED
            from datetime import timedelta
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í†µê³„
            running_processes = sum(1 for is_healthy in health_results.values() if is_healthy)
            total_processes = len(health_results)
            failed_processes = total_processes - running_processes
            
            # í”„ë¡œì„¸ìŠ¤ ìƒì„¸ ì •ë³´
            process_details = {}
            for process_name, is_healthy in health_results.items():
                if self.v3_0_components['process_manager']:
                    process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                    if process_info:
                        process_details[process_name] = {
                            'status': 'running' if is_healthy else process_info.status.value,
                            'pid': process_info.pid,
                            'restart_count': process_info.restart_count,
                            'cpu_usage': process_info.cpu_usage,
                            'memory_usage': process_info.memory_usage,
                            'last_error': process_info.last_error
                        }
                    else:
                        process_details[process_name] = {
                            'status': 'running' if is_healthy else 'unknown',
                            'pid': None,
                            'restart_count': 0,
                            'cpu_usage': 0.0,
                            'memory_usage': 0.0,
                            'last_error': None
                        }
            
            # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
            system_metrics = {}
            if self.v3_0_components['process_manager']:
                system_status = self.v3_0_components['process_manager'].get_system_status()
                system_metrics = system_status.get('system_metrics', {})
            
            # ë‹¤ìŒ ìƒíƒœ ë³´ê³  ì‹œê°„ ê³„ì‚°
            next_hour = None
            for hour in range(current_time.hour + 1, 24):
                if hour >= self.status_notification_start_hour:
                    hour_diff = hour - self.status_notification_start_hour
                    if hour_diff % self.status_notification_interval_hours == 0:
                        next_hour = hour
                        break
            
            if next_hour is None:
                next_hour = self.status_notification_start_hour
            
            next_status_report = current_time.replace(hour=next_hour, minute=0, second=0, microsecond=0)
            
            return SystemStatus(
                timestamp=current_time,
                uptime=timedelta(seconds=0),  # ì‹¤ì œë¡œëŠ” ì‹œì‘ ì‹œê°„ì„ ì¶”ì í•´ì•¼ í•¨
                total_processes=total_processes,
                running_processes=running_processes,
                failed_processes=failed_processes,
                process_details=process_details,
                system_metrics=system_metrics,
                next_status_report=next_status_report
            )
            
        except Exception as e:
            self.log(f"âŒ ì‹œìŠ¤í…œ ìƒíƒœ ê°ì²´ ìƒì„± ì˜¤ë¥˜: {e}")
            # ê¸°ë³¸ ê°ì²´ ë°˜í™˜
            from datetime import timedelta
            return type('SystemStatus', (), {
                'timestamp': current_time,
                'uptime': timedelta(0),
                'total_processes': len(health_results),
                'running_processes': sum(1 for is_healthy in health_results.values() if is_healthy),
                'failed_processes': len(health_results) - sum(1 for is_healthy in health_results.values() if is_healthy),
                'process_details': {},
                'system_metrics': {},
                'next_status_report': None
            })()
        
    def log(self, message):
        """
        ë¡œê·¸ ë©”ì‹œì§€ ê¸°ë¡
        
        ì½˜ì†”ê³¼ ë¡œê·¸ íŒŒì¼ì— íƒ€ì„ìŠ¤íƒ¬í”„ì™€ í•¨ê»˜ ë©”ì‹œì§€ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
        Windows ì½˜ì†” ì¸ì½”ë”© ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
        
        Args:
            message (str): ê¸°ë¡í•  ë¡œê·¸ ë©”ì‹œì§€
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"[{timestamp}] {message}"
        
        # Windows ì½˜ì†” ì¶œë ¥ ì‹œ ì¸ì½”ë”© ë¬¸ì œ í•´ê²° + ì¦‰ì‹œ ì¶œë ¥
        try:
print(log_message,_flush = True)  # flush=Trueë¡œ ì¦‰ì‹œ ì¶œë ¥
        except UnicodeEncodeError:
            # ì½˜ì†”ì—ì„œ í•œê¸€ ì¶œë ¥ ì‹¤íŒ¨ ì‹œ ì˜ì–´ë¡œ ëŒ€ì²´
            safe_message = message.encode('ascii', 'ignore').decode('ascii')
            print(f"[{timestamp}] {safe_message}", flush=True)
        
        # ë¡œê·¸ íŒŒì¼ì—ëŠ” í•­ìƒ UTF-8ë¡œ ì €ì¥
        try:
with_open(self.log_file,_"a",_encoding = "utf-8") as f:
                f.write(log_message + "/n")
        except Exception as e:
            print(f"[ERROR] ë¡œê·¸ íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨: {e}")
    
    def should_send_status_notification(self):
        """
        ì ˆëŒ€ì‹œê°„ ê¸°ì¤€ ì •ê¸° ìƒíƒœ ì•Œë¦¼ í•„ìš” ì—¬ë¶€ ì²´í¬
        
        Returns:
            bool: ì•Œë¦¼ì´ í•„ìš”í•˜ë©´ True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # ì •ê°(0ë¶„)ì—ë§Œ ì²´í¬ (1ë¶„ ì´ë‚´ ì˜¤ì°¨ í—ˆìš©)
        if current_minute > 1:
            return False
        
        # ì‹œì‘ ì‹œê°„ë¶€í„° ê°„ê²©ì— ë§ëŠ” ì‹œê°„ì¸ì§€ ì²´í¬
        if current_hour < self.status_notification_start_hour:
            return False
        
        # ê°„ê²© ê³„ì‚°: (í˜„ì¬ì‹œê°„ - ì‹œì‘ì‹œê°„) % ê°„ê²© == 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # ì´ë¯¸ ì´ ì‹œê°„ì— ì•Œë¦¼ì„ ë³´ëƒˆëŠ”ì§€ ì²´í¬
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
#_ê°„ê²©_ê³„ì‚°:_(í˜„ì¬ì‹œê°„_-_ì‹œì‘ì‹œê°„)_%_ê°„ê²© = = 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # ì´ë¯¸ ì´ ì‹œê°„ì— ì•Œë¦¼ì„ ë³´ëƒˆëŠ”ì§€ ì²´í¬
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
    def should_send_hourly_check(self):
        """
        ë§¤ì‹œê°„ ì •ê° ìƒíƒœ ì²´í¬ í•„ìš” ì—¬ë¶€ ì²´í¬
        
        Returns:
            bool: ì²´í¬ê°€ í•„ìš”í•˜ë©´ True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # ì •ê°(0ë¶„)ì—ë§Œ ì²´í¬ (1ë¶„ ì´ë‚´ ì˜¤ì°¨ í—ˆìš©)
        if current_minute > 1:
            return False
        
        # ì´ë¯¸ ì´ ì‹œê°„ì— ì²´í¬í–ˆëŠ”ì§€ í™•ì¸
        if self.last_hourly_check_hour != current_hour:
            return True
        
        return False
    
    def check_fixed_time_tasks(self):
        """
        ê³ ì • ì‹œê°„ ì‘ì—…ë“¤ ì²´í¬ ë° ì‹¤í–‰ - ì›Œì¹˜í–„ìŠ¤í„°ëŠ” ë‰´ìŠ¤ ê´€ë ¨ ê³ ì • ì‘ì—… ì—†ìŒ
        """
        # ì›Œì¹˜í–„ìŠ¤í„°ëŠ” ìˆœìˆ˜ ì‹œìŠ¤í…œ ê´€ë¦¬ë§Œ ë‹´ë‹¹
        # ë‰´ìŠ¤ ê´€ë ¨ ê³ ì • ì‹œê°„ ì‘ì—…ì€ realtime_news_monitor.pyì™€ integrated_report_scheduler.pyì—ì„œ ì²˜ë¦¬
        pass
    
    def is_quiet_hours_old(self):
        """
        ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì—¬ë¶€ ì²´í¬ (18:00~05:59) - ì‚¬ìš© ì¤‘ë‹¨
        
        Returns:
            bool: ì¡°ìš©í•œ ì‹œê°„ëŒ€ë©´ True
        """
        current_hour = datetime.now().hour
return_current_hour_> =  18 or current_hour < 6
    
    def send_status_notification(self):
        """
        ì ˆëŒ€ì‹œê°„ ê¸°ì¤€ ì •ê¸° ìƒíƒœ ì•Œë¦¼ ì „ì†¡ (7, 9, 11, 13, 15, 17, 19, 21, 23ì‹œ)
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        
        try:
            # ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì²´í¬
            monitor_running = self.is_monitor_running()
            monitor_status = "ğŸŸ¢ ì •ìƒ ì‘ë™" if monitor_running else "ğŸ”´ ì¤‘ë‹¨ë¨"
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì •ë³´
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                resource_info = (
                    f"ğŸ’» CPU: {cpu_percent:.1f}% | "
                    f"ğŸ§  ë©”ëª¨ë¦¬: {memory.percent:.1f}% | "
                    f"ğŸ’¾ ë””ìŠ¤í¬: {disk.percent:.1f}%"
                )
                resource_normal = cpu_percent < 80 and memory.percent < 85 and disk.percent < 90
            except:
                resource_info = "ğŸ“Š ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ì‹¤íŒ¨"
                resource_normal = True
            
            # ë‹¤ìŒ ì•Œë¦¼ ì‹œê°„ ê³„ì‚°
            next_hour = None
            for hour in range(current_hour + 1, 24):
                if hour >= self.status_notification_start_hour:
                    hour_diff = hour - self.status_notification_start_hour
                    if hour_diff % self.status_notification_interval_hours == 0:
                        next_hour = hour
                        break
            
            if next_hour is None:
                next_hour = self.status_notification_start_hour
            
            # ì¡°ìš©í•œ ì‹œê°„ëŒ€ êµ¬ë¶„í•˜ì—¬ ì•Œë¦¼ ì „ì†¡
            if self.is_quiet_hours():
                # ì¡°ìš©í•œ ì‹œê°„ëŒ€: ì¤‘ìš”í•œ ë¬¸ì œê°€ ìˆì„ ë•Œë§Œ ìƒì„¸ ì•Œë¦¼
                has_problem = not monitor_running or not resource_normal
                
                if has_problem:
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨")
                    if not resource_normal:
                        problem_details.append("âŒ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì„ê³„ê°’ ì´ˆê³¼")
                    
                    self.send_notification(
                        f"ğŸš¨ POSCO ì›Œì¹˜í–„ìŠ¤í„° ì •ê¸° ë³´ê³  - ì¤‘ìš” ë¬¸ì œ ê°ì§€\n\n"
                        f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"ğŸš¨ ê°ì§€ëœ ë¬¸ì œ:\n" + "\n".join(f"   â€¢ {problem}" for problem in problem_details) + "\n\n"
                        f"ğŸ” ìƒì„¸ ìƒíƒœ:\n"
                        f"   â€¢ ëª¨ë‹ˆí„°ë§: {monitor_status}\n"
                        f"   â€¢ {resource_info}\n\n"
                        f"â° ë‹¤ìŒ ë³´ê³ : {next_hour:02d}:00\n"
                        f"ğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘...",
                        is_error=True
                    )
                    self.log(f"ğŸš¨ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì •ê¸° ë³´ê³  ì¤‘ìš” ë¬¸ì œ ì•Œë¦¼ ì „ì†¡ ({current_hour}ì‹œ)")
                else:
                    # ì •ìƒ ìƒíƒœ: ê°„ë‹¨í•œ ì•Œë¦¼
                    self.send_notification(
                        f"ğŸŒ™ POSCO ì›Œì¹˜í–„ìŠ¤í„° ì •ê¸° ë³´ê³  (ì¡°ìš©í•œ ì‹œê°„)\n\n"
                        f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"ğŸ” ëª¨ë‹ˆí„°ë§: {monitor_status}\n"
                        f"ğŸ“Š {resource_info}\n"
                        f"â° ë‹¤ìŒ ë³´ê³ : {next_hour:02d}:00"
                    )
                    self.log(f"ğŸŒ™ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì •ê¸° ë³´ê³  ì „ì†¡ ({current_hour}ì‹œ)")
            else:
                # ì¼ë°˜ ì‹œê°„ëŒ€: v2 í–¥ìƒëœ ìƒíƒœ ë³´ê³  ì‚¬ìš©
                self.send_status_report_v2()
                self.log(f"ğŸ¹ ì •ê¸° ìƒíƒœ ë³´ê³  ì „ì†¡ ì™„ë£Œ ({current_hour}ì‹œ)")
                
        except Exception as e:
            self.log(f"âŒ ì •ê¸° ìƒíƒœ ë³´ê³  ì‹¤íŒ¨: {e}")
            self.send_notification(
                f"âŒ POSCO ì›Œì¹˜í–„ìŠ¤í„° ì •ê¸° ë³´ê³  ì˜¤ë¥˜\n\n"
                f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"âŒ ì˜¤ë¥˜: {str(e)}\n"
                f"ğŸ”§ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                is_error=True
            )
    
    def check_scheduled_tasks(self):
        """
        ê¸°ì¡´ ìŠ¤ì¼€ì¤„ëœ ì‘ì—…ë“¤ ì²´í¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
        """
        # ê¸°ì¡´ ìŠ¤ì¼€ì¤„ ì‘ì—… ë¡œì§ì´ ìˆë‹¤ë©´ ì—¬ê¸°ì— ìœ ì§€
        # í˜„ì¬ëŠ” ì ˆëŒ€ì‹œê°„ ê¸°ì¤€ ì‹œìŠ¤í…œìœ¼ë¡œ ëŒ€ì²´ë˜ì—ˆìœ¼ë¯€ë¡œ ë¹ˆ í•¨ìˆ˜ë¡œ ìœ ì§€
        pass

    def send_notification(self, message, is_error=False):
        """
        Dooray ì•Œë¦¼ ì „ì†¡ - v2 í†µí•© ì•„í‚¤í…ì²˜
        
        v2 NotificationManager ì‚¬ìš© ê°€ëŠ¥ ì‹œ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•˜ê³ ,
        ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±í•©ë‹ˆë‹¤.
        
        Args:
            message (str): ì „ì†¡í•  ë©”ì‹œì§€
            is_error (bool): ì˜¤ë¥˜ ì•Œë¦¼ ì—¬ë¶€ (ìƒ‰ìƒê³¼ ë´‡ëª… ë³€ê²½)
        """
        try:
            # v2 NotificationManager ì‚¬ìš© ì‹œë„
            if self.v2_enabled and self.v2_components['notification_manager']:
                success = self.v2_components['notification_manager'].send_notification(message, is_error)
                if success:
                    return
                else:
                    self.log("âš ï¸ v2 NotificationManager ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
            color = "#ff4444" if is_error else "#28a745"
            bot_name = "POSCO ì›Œì¹˜í–„ìŠ¤í„° âŒ" if is_error else "POSCO ì›Œì¹˜í–„ìŠ¤í„° ğŸ¹ğŸ›¡ï¸"
            
            payload = {
                "botName": bot_name,
                "botIconImage": BOT_PROFILE_IMAGE_URL,
                "text": message.split('\n')[0],
                "attachments": [{
                    "color": color,
                    "text": message
                }]
            }
            
            response = requests.post(
                WATCHHAMSTER_WEBHOOK_URL,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                self.log(f"âœ… ì•Œë¦¼ ì „ì†¡ ì„±ê³µ: {message.split(chr(10))[0]}")
            else:
                self.log(f"âŒ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {response.status_code}")
                
        except Exception as e:
            self.log(f"âŒ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def send_startup_notification_v3_0(self):
        """
        v2 ì‹œì‘ ì•Œë¦¼ ì „ì†¡ - ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´í•˜ë©´ì„œ v2 ì»´í¬ë„ŒíŠ¸ ì •ë³´ í¬í•¨
        
        Requirements: 4.1, 4.2
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ì‹œì‘ ì•Œë¦¼ ì‚¬ìš©
                success = self.v3_0_components['notification_manager'].send_startup_notification(
                    self.managed_processes
                )
                if success:
                    self.log("âœ… v2 ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ì‹œì‘ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ì™„ì „ ë³´ì¡´)
            current_time = datetime.now()
            message = f"ğŸ¹ POSCO WatchHamster v3.0 ì‹œì‘/n/n"
            message += f"ğŸ“… ì‹œì‘ ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"ğŸ›¡ï¸ ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤: {len(self.managed_processes)}ê°œ/n/n"
            
            message += f"ğŸ“Š ê´€ë¦¬ ì¤‘ì¸ ëª¨ë“ˆ:/n"
            for process in self.managed_processes:
                descriptions = {
                    'POSCO News 250808 ì•Œë¦¼',
                    'realtime_news_monitor': 'ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§',
                    'integrated_report_scheduler': 'ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬',
                    'historical_data_collector': 'ë°ì´í„° ìˆ˜ì§‘ê¸°'
                }
                desc = descriptions.get(process, process)
                message += f"  âœ… {process} ({desc})/n"
            
            # v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ì¶”ê°€ (v2 í™œì„±í™” ì‹œì—ë§Œ)
            if self.v3_0_enabled:
                message += f"/nğŸ”§ v2 ì•„í‚¤í…ì²˜ ìƒíƒœ:/n"
                for component_name, component in self.v3_0_components.items():
                    status = "âœ… í™œì„±í™”" if component else "âŒ ë¹„í™œì„±í™”"
                    message += f"  â€¢ {component_name}: {status}/n"
            
            message += f"/nğŸ”„ ëª¨ë‹ˆí„°ë§ ì„¤ì •:/n"
            message += f"  â€¢ í—¬ìŠ¤ì²´í¬: 5ë¶„ ê°„ê²©/n"
            message += f"  â€¢ ìƒíƒœ ë³´ê³ : 2ì‹œê°„ ê°„ê²©/n"
            message += f"  â€¢ ìë™ ë³µêµ¬: í™œì„±í™”/n"
            message += f"  â€¢ Git ì—…ë°ì´íŠ¸: 60ë¶„ ê°„ê²©/n/n"
            message += f"ğŸš€ ì „ì²´ ì‹œìŠ¤í…œì´ ì •ìƒì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"âŒ ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def send_status_report_v3_0(self):
        """
        v2 ì •ê¸° ìƒíƒœ ë³´ê³  - v2 ì»´í¬ë„ŒíŠ¸ ì •ë³´ë¥¼ í¬í•¨í•œ í–¥ìƒëœ ìƒíƒœ ë³´ê³ 
        
        Requirements: 4.2, 4.3
        """
        try:
            current_time = datetime.now()
            
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘
                system_status = self._collect_v2_system_status()
                
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ìƒíƒœ ë³´ê³  ì‚¬ìš©
                success = self.v3_0_components['notification_manager'].send_status_report(system_status)
                if success:
                    self.log("âœ… v2 ìƒíƒœ ë³´ê³  ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ìƒíƒœ ë³´ê³  ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´í•˜ë©´ì„œ v2 ì •ë³´ ì¶”ê°€)
            message = f"ğŸ“Š POSCO WatchHamster v3.0 ì •ê¸° ìƒíƒœ ë³´ê³ /n/n"
            message += f"ğŸ“… ë³´ê³  ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            
            # ê°€ë™ ì‹œê°„ ê³„ì‚°
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
hours,_remainder =  divmod(int(uptime.total_seconds()), 3600)
minutes,__ =  divmod(remainder, 60)
                message += f"â±ï¸ ê°€ë™ ì‹œê°„: {hours}ì‹œê°„ {minutes}ë¶„/n/n"
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            running_processes = []
            failed_processes = []
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    running_processes.append(process_name)
                else:
                    failed_processes.append(process_name)
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ë³´ê³ 
            if not failed_processes:
                message += f"ğŸŸ¢ ì •ìƒ í”„ë¡œì„¸ìŠ¤ ({len(running_processes)}/{len(self.managed_processes)}):/n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  âœ… {process} - ì •ìƒ (PID: {pid})/n"
            else:
                message += f"ğŸŸ¢ ì •ìƒ í”„ë¡œì„¸ìŠ¤ ({len(running_processes)}/{len(self.managed_processes)}):/n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  âœ… {process} - ì •ìƒ (PID: {pid})/n"
                
                message += f"/nğŸŸ¡ ë¬¸ì œ í”„ë¡œì„¸ìŠ¤ ({len(failed_processes)}/{len(self.managed_processes)}):/n"
                for process in failed_processes:
                    message += f"  âŒ {process} - ì¤‘ì§€ë¨/n"
            
            # v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ì¶”ê°€
            if self.v3_0_enabled:
                message += f"/nğŸ”§ v2 ì•„í‚¤í…ì²˜ ìƒíƒœ:/n"
                for component_name, component in self.v3_0_components.items():
                    if component:
                        # ì»´í¬ë„ŒíŠ¸ë³„ ìƒíƒœ ì •ë³´
                        if component_name == 'notification_manager':
                            stats = component.get_notification_stats()
                            message += f"  âœ… {component_name}: í™œì„±í™” (ì•Œë¦¼: {stats.get('total_notifications', 0)}íšŒ)/n"
                        elif component_name == 'module_registry':
                            modules = component.list_modules()
                            message += f"  âœ… {component_name}: í™œì„±í™” (ëª¨ë“ˆ: {len(modules)}ê°œ)/n"
                        else:
                            message += f"  âœ… {component_name}: í™œì„±í™”/n"
                    else:
                        message += f"  âŒ {component_name}: ë¹„í™œì„±í™”/n"
            
            # ì‹œìŠ¤í…œ ì„±ëŠ¥ ì •ë³´
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_percent = psutil.virtual_memory().percent
                disk_percent = psutil.disk_usage('/').percent
                
                message += f"/nğŸ“ˆ ì‹œìŠ¤í…œ ì„±ëŠ¥:/n"
                message += f"  â€¢ CPU ì‚¬ìš©ë¥ : {cpu_percent:.0f}%/n"
                message += f"  â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {memory_percent:.0f}%/n"
                message += f"  â€¢ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ : {disk_percent:.0f}%/n"
            except ImportError:
                message += f"/nğŸ“ˆ ì‹œìŠ¤í…œ ì„±ëŠ¥: ì •ë³´ ìˆ˜ì§‘ ë¶ˆê°€ (psutil í•„ìš”)/n"
            
            # ë‹¤ìŒ ë³´ê³  ì‹œê°„
            next_report_time = current_time + timedelta(hours=self.status_notification_interval_hours)
            message += f"/nğŸ”„ ë‹¤ìŒ ìƒíƒœ ë³´ê³ : {next_report_time.strftime('%H:%M')}"
            
            # ìƒ‰ìƒ ê²°ì • (ë¬¸ì œê°€ ìˆìœ¼ë©´ ì£¼í™©ìƒ‰, ì—†ìœ¼ë©´ ë…¹ìƒ‰)
            is_error = len(failed_processes) > 0
            self.send_notification(message, is_error)
            
        except Exception as e:
            self.log(f"âŒ ìƒíƒœ ë³´ê³  ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def send_process_error_v3_0(self, process_name, error_details):
        """
        v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ - êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ ì •ë³´ í¬í•¨
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            error_details (dict): ì˜¤ë¥˜ ìƒì„¸ ì •ë³´
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ ì•Œë¦¼ ì‚¬ìš©
                success = self.v3_0_components['notification_manager'].send_process_error(
                    process_name, error_details
                )
                if success:
                    self.log(f"âœ… v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ: {process_name}")
                    return
                else:
                    self.log("âš ï¸ v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´)
            current_time = datetime.now()
            message = f"âŒ POSCO WatchHamster v3.0 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜/n/n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"ğŸ”§ ë¬¸ì œ í”„ë¡œì„¸ìŠ¤: {process_name}/n/n"
            
            # ì˜¤ë¥˜ ì •ë³´
            error_msg = error_details.get('error_message', 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜')
            message += f"âŒ ì˜¤ë¥˜ ë‚´ìš©: {error_msg}/n"
            
            # ì¬ì‹œì‘ ì‹œë„ ì •ë³´
            restart_count = error_details.get('restart_count', 0)
            max_attempts = error_details.get('max_attempts', 3)
            
            if restart_count > 0:
                message += f"ğŸ”„ ì¬ì‹œì‘ ì‹œë„: {restart_count}/{max_attempts}íšŒ/n"
            
            # ìë™ ë³µêµ¬ ìƒíƒœ
            auto_recovery = error_details.get('auto_recovery_enabled', True)
            if auto_recovery and restart_count < max_attempts:
                message += f"/nğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘..."
            elif restart_count >= max_attempts:
                message += f"/nğŸš¨ ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ ì´ˆê³¼ - ìˆ˜ë™ ê°œì… í•„ìš”"
            else:
                message += f"/nâš ï¸ ìë™ ë³µêµ¬ ë¹„í™œì„±í™” - ìˆ˜ë™ í™•ì¸ í•„ìš”"
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"âŒ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def send_recovery_success_v3_0(self, process_name, recovery_details):
        """
        v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ - ë³µêµ¬ ë‹¨ê³„ì™€ ìƒì„¸ ì •ë³´ í¬í•¨
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            recovery_details (dict): ë³µêµ¬ ìƒì„¸ ì •ë³´
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ë³µêµ¬ ì•Œë¦¼ ì‚¬ìš©
                success = self.v3_0_components['notification_manager'].send_recovery_success(
                    process_name, recovery_details
                )
                if success:
                    self.log(f"âœ… v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ: {process_name}")
                    return
                else:
                    self.log("âš ï¸ v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´)
            current_time = datetime.now()
            message = f"âœ… POSCO WatchHamster v3.0 í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì™„ë£Œ/n/n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"ğŸ”§ ë³µêµ¬ëœ í”„ë¡œì„¸ìŠ¤: {process_name}/n/n"
            
            # ë³µêµ¬ ì •ë³´
            recovery_stage = recovery_details.get('recovery_stage', 'ì•Œ ìˆ˜ ì—†ìŒ')
            recovery_time = recovery_details.get('recovery_time', 0)
            
            message += f"ğŸ”„ ë³µêµ¬ ë‹¨ê³„: {recovery_stage}/n"
            if recovery_time > 0:
                message += f"â±ï¸ ë³µêµ¬ ì†Œìš” ì‹œê°„: {recovery_time}ì´ˆ/n"
            
            # ìƒˆ í”„ë¡œì„¸ìŠ¤ ì •ë³´
            new_pid = recovery_details.get('new_pid')
            if new_pid:
                message += f"ğŸ†” ìƒˆ í”„ë¡œì„¸ìŠ¤ ID: {new_pid}/n"
            
            message += f"/nğŸš€ í”„ë¡œì„¸ìŠ¤ê°€ ì •ìƒì ìœ¼ë¡œ ë³µêµ¬ë˜ì–´ ëª¨ë‹ˆí„°ë§ì„ ì¬ê°œí•©ë‹ˆë‹¤."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"âŒ ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def send_critical_alert_v3_0(self, alert_message, additional_info=None):
        """
        v2 ê¸´ê¸‰ ì•Œë¦¼ - êµ¬ì¡°í™”ëœ ê¸´ê¸‰ ìƒí™© ì•Œë¦¼
        
        Requirements: 4.4
        
        Args:
            alert_message (str): ê¸´ê¸‰ ì•Œë¦¼ ë©”ì‹œì§€
            additional_info (dict): ì¶”ê°€ ì •ë³´
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ê¸´ê¸‰ ì•Œë¦¼ ì‚¬ìš©
                success = self.v3_0_components['notification_manager'].send_critical_alert(
                    alert_message, additional_info or {}
                )
                if success:
                    self.log("âœ… v2 ê¸´ê¸‰ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ê¸´ê¸‰ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
            current_time = datetime.now()
            message = f"ğŸš¨ POSCO WatchHamster v3.0 ê¸´ê¸‰ ì•Œë¦¼/n/n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"ğŸš¨ ê¸´ê¸‰ ìƒí™©: {alert_message}/n/n"
            
            if additional_info:
                message += f"ğŸ“‹ ì¶”ê°€ ì •ë³´:/n"
                for key, value in additional_info.items():
                    message += f"  â€¢ {key}: {value}/n"
                message += "/n"
            
            message += f"ğŸ”§ ì¦‰ì‹œ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"âŒ ê¸´ê¸‰ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def _collect_v2_system_status(self):
        """
        v2 ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘
        
        Returns:
            SystemStatus: v2 NotificationManagerìš© ì‹œìŠ¤í…œ ìƒíƒœ ê°ì²´
        """
        try:
            # v2 NotificationManagerì˜ SystemStatus í´ë˜ìŠ¤ import
            import importlib.util
            v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/notification_manager.py')
            spec = importlib.util.spec_from_file_location("notification_manager", module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            SystemStatus = getattr(module, 'SystemStatus')
            
            current_time = datetime.now()
            
            # ê°€ë™ ì‹œê°„ ê³„ì‚°
            uptime = timedelta(0)
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ìˆ˜ì§‘
            process_details = {}
            running_count = 0
            failed_count = 0
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    process_details[process_name] = {
                        'status': 'running',
                        'pid': self._get_process_pid(process_name),
                        'restart_count': 0
                    }
running_count_+ =  1
                else:
                    process_details[process_name] = {
                        'status': 'stopped',
                        'pid': None,
                        'restart_count': 0
                    }
failed_count_+ =  1
            
            # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
            system_metrics = {}
            try:
                import psutil
                system_metrics = {
'cpu_percent':_psutil.cpu_percent(interval = 1),
                    'memory_percent': psutil.virtual_memory().percent,
                    'disk_percent': psutil.disk_usage('/').percent
                }
            except ImportError:
                system_metrics = {
                    'cpu_percent': 0,
                    'memory_percent': 0,
                    'disk_percent': 0
                }
            
            # ë‹¤ìŒ ìƒíƒœ ë³´ê³  ì‹œê°„
            next_status_report = current_time + timedelta(hours=self.status_notification_interval_hours)
            
            return SystemStatus(
                timestamp=current_time,
                uptime=uptime,
                total_processes=len(self.managed_processes),
                running_processes=running_count,
                failed_processes=failed_count,
                process_details=process_details,
                system_metrics=system_metrics,
                last_git_update=getattr(self, 'last_git_check', None),
                next_status_report=next_status_report
            )
            
        except Exception as e:
            self.log(f"âŒ v2 ì‹œìŠ¤í…œ ìƒíƒœ ìˆ˜ì§‘ ì˜¤ë¥˜: {e}")
            return None
    
    def _is_process_running(self, process_name):
        """
        í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ìƒíƒœ í™•ì¸
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ì‹¤í–‰ ì¤‘ì´ë©´ True
        """
        try:
            import psutil
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info['cmdline'] or [])
                    if process_name in cmdline:
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return False
        except ImportError:
            # psutilì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ë°©ì‹ ì‚¬ìš©
            try:
                result = subprocess.run(['pgrep', '-f', process_name], 
                                      capture_output=True, text=True)
return_result.returncode = = 0
            except:
                return False
    
    def _get_process_pid(self, process_name):
        """
        í”„ë¡œì„¸ìŠ¤ PID ì¡°íšŒ
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            int or str: PID ë˜ëŠ” 'N/A'
        """
        try:
            import psutil
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info['cmdline'] or [])
                    if process_name in cmdline:
                        return proc.info['pid']
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return 'N/A'
        except ImportError:
            # psutilì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ë°©ì‹ ì‚¬ìš©
            try:
                result = subprocess.run(['pgrep', '-f', process_name], 
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip().split('/n')[0]
                return 'N/A'
            except:
                return 'N/A'
    
    def check_git_updates(self):
        """
        Git ì €ì¥ì†Œ ì—…ë°ì´íŠ¸ ì²´í¬
        
        ì›ê²© ì €ì¥ì†Œì™€ ë¡œì»¬ ì €ì¥ì†Œë¥¼ ë¹„êµí•˜ì—¬ ì—…ë°ì´íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        
        Returns:
            bool: ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ True, ì—†ìœ¼ë©´ False
        """
        try:
            # ì›ê²© ì €ì¥ì†Œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            result = subprocess.run(
                ['git', 'fetch', 'origin'],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode != 0:
                self.log(f"âš ï¸ Git fetch ì‹¤íŒ¨: {result.stderr}")
                return False
            
            # ë¡œì»¬ê³¼ ì›ê²© ë¹„êµ
            result = subprocess.run(
                ['git', 'rev-list', 'HEAD..origin/main', '--count'],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                commit_count = int(result.stdout.strip())
                if commit_count > 0:
                    self.log(f"ğŸ”„ Git ì—…ë°ì´íŠ¸ ë°œê²¬: {commit_count}ê°œ ì»¤ë°‹")
                    return True
                else:
                    self.log("ğŸ“‹ Git ì—…ë°ì´íŠ¸ ì—†ìŒ")
                    return False
            else:
                self.log(f"âš ï¸ Git ë¹„êµ ì‹¤íŒ¨: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            self.log("âš ï¸ Git ì²´í¬ íƒ€ì„ì•„ì›ƒ")
            return False
        except Exception as e:
            self.log(f"âŒ Git ì²´í¬ ì˜¤ë¥˜: {e}")
            return False
    
    def apply_git_update(self):
        """Git ì—…ë°ì´íŠ¸ ì ìš© - ì„±ëŠ¥ ìµœì í™”"""
        try:
            self.log("ğŸ”„ Git ì—…ë°ì´íŠ¸ ì ìš© ì¤‘...")
            
            # í˜„ì¬ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€
            self.stop_monitor_process()
            
            # ë¡œì»¬ ë³€ê²½ì‚¬í•­ì´ ìˆëŠ”ì§€ í™•ì¸
            status_result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if status_result.stdout.strip():
                # ë¡œì»¬ ë³€ê²½ì‚¬í•­ì´ ìˆìœ¼ë©´ stash
                subprocess.run(
                    ["git", "stash", "push", "-m", "WatchHamster auto stash"],
                    cwd=self.script_dir,
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                self.log("ğŸ“¦ ë¡œì»¬ ë³€ê²½ì‚¬í•­ ì„ì‹œ ì €ì¥")
            
            # Git pull ì‹¤í–‰ (ì•ˆì „í•œ ë°©ì‹)
            result = subprocess.run(
                ["git", "pull", "origin", "main", "--allow-unrelated-histories"],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                self.log("âœ… Git ì—…ë°ì´íŠ¸ ì„±ê³µ")
                self.send_notification(
                    f"ğŸ”„ POSCO ëª¨ë‹ˆí„° Git ì—…ë°ì´íŠ¸ ì™„ë£Œ/n/n"
                    f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                    f"ğŸ“ ë³€ê²½ì‚¬í•­: {result.stdout.strip()}/n"
                    f"ğŸš€ ëª¨ë‹ˆí„°ë§ ì¬ì‹œì‘ ì¤‘..."
                )
                
                # ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
                time.sleep(3)
                if self.start_monitor_process():
                    self.send_notification(
                        f"âœ… POSCO ëª¨ë‹ˆí„° ì—…ë°ì´íŠ¸ í›„ ì¬ì‹œì‘ ì™„ë£Œ/n/n"
                        f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"ğŸ”„ ìµœì‹  ì½”ë“œë¡œ ëª¨ë‹ˆí„°ë§ ì¬ê°œë¨"
                    )
                else:
                    self.send_notification(
                        f"âŒ POSCO ëª¨ë‹ˆí„° ì—…ë°ì´íŠ¸ í›„ ì¬ì‹œì‘ ì‹¤íŒ¨/n/n"
                        f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"ğŸ”§ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                        is_error=True
                    )
            else:
                self.log(f"âŒ Git ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {result.stderr}")
                self.send_notification(
                    f"âŒ POSCO ëª¨ë‹ˆí„° Git ì—…ë°ì´íŠ¸ ì‹¤íŒ¨/n/n"
                    f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                    f"âŒ ì˜¤ë¥˜: {result.stderr.strip()}/n"
                    f"ğŸ”§ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                    is_error=True
                )
                
                # ì‹¤íŒ¨ ì‹œ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
                self.start_monitor_process()
                
        except subprocess.TimeoutExpired:
            self.log("âŒ Git ì—…ë°ì´íŠ¸ íƒ€ì„ì•„ì›ƒ")
            self.start_monitor_process()
        except Exception as e:
            self.log(f"âŒ Git ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
            self.start_monitor_process()
    
    def is_monitor_running(self):
        """ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ìƒíƒœ í™•ì¸ - v2 í†µí•© ì•„í‚¤í…ì²˜"""
        try:
            if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                # v2 ì•„í‚¤í…ì²˜ ì‚¬ìš©
                running_count = 0
                total_count = 0
                
                for process_name in self.managed_processes:
                    module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                    if module_config and module_config.auto_start:
total_count_+ =  1
                        if self.v3_0_components['process_manager'].is_process_running(process_name):
running_count_+ =  1
                
                # ëª¨ë“  ìë™ ì‹œì‘ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ ì •ìƒ
return_running_count = = total_count and total_count > 0
            else:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                # í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ í™•ì¸
                scheduler_running = False
                if self.monitor_process and self.monitor_process.poll() is None:
                    scheduler_running = True
                else:
                    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                        try:
                            if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                                cmdline = proc.info['cmdline']
                                if cmdline and 'integrated_report_scheduler.py' in ' '.join(cmdline):
                                    scheduler_running = True
                                    break
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            continue
                
                # ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° í™•ì¸
                realtime_running = False
                if self.realtime_process and self.realtime_process.poll() is None:
                    realtime_running = True
                else:
                    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                        try:
                            if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                                cmdline = proc.info['cmdline']
                                if cmdline and 'realtime_news_monitor.py' in ' '.join(cmdline):
                                    realtime_running = True
                                    break
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            continue
                
                # ë‘˜ ë‹¤ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ ì •ìƒ
                return scheduler_running and realtime_running
            
        except Exception as e:
            self.log(f"âŒ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    # ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ë©”ì„œë“œë“¤
    def start_all_processes(self) -> bool:
        """
        ëª¨ë“  ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ - v2 í†µí•© ì•„í‚¤í…ì²˜
        
        v2 ì»´í¬ë„ŒíŠ¸ ì‚¬ìš© ê°€ëŠ¥ ì‹œ ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì˜ ì‹œì‘ ìˆœì„œì— ë”°ë¼ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œì‘í•˜ê³ ,
        ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±í•©ë‹ˆë‹¤.
        
        Returns:
            bool: ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        # ì„±ëŠ¥ ì¸¡ì • ì‹œì‘
        with self.measure_operation_performance("start_all_processes"):
            try:
                self.log("ğŸš€ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì¤‘...")
                
                if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                    # v2 ì•„í‚¤í…ì²˜ ì‚¬ìš©
                    return self._start_processes_v2()
                else:
                    # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                    self.log("ğŸ“‹ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
                    return self.start_monitor_process()
                    
            except Exception as e:
                self.log(f"âŒ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì˜¤ë¥˜: {e}")
                return False
    
    def _start_processes_v3_0(self) -> bool:
        """
        v2 ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        
        v2 ProcessManagerì™€ ModuleRegistryë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ì¡´ì„± ìˆœì„œì— ë”°ë¼
        í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œì‘í•˜ê³  ìƒëª…ì£¼ê¸°ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
        
        êµ¬í˜„ ë‚´ìš©:
        - ModuleRegistryì—ì„œ ì˜ì¡´ì„± ìˆœì„œ ì¡°íšŒ
        - ProcessManagerë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        - í”„ë¡œì„¸ìŠ¤ë³„ ìƒíƒœ ì¶”ì  ë° ê²€ì¦
        - ì‹œì‘ ì‹¤íŒ¨ ì‹œ ìë™ ë³µêµ¬ ì‹œë„
        
        Returns:
            bool: ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        try:
            success_count = 0
            failed_processes = []
            startup_start_time = datetime.now()
            
            self.log("ğŸš€ v2 ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹œì‘")
            
            # ì˜ì¡´ì„± ìˆœì„œì— ë”°ë¼ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            startup_order = self.v3_0_components['module_registry'].get_modules_by_dependency_order()
            total_count = len([p for p in startup_order if p in self.managed_processes])
            
            self.log(f"ğŸ“‹ ì‹œì‘ ìˆœì„œ: {' â†’ '.join(startup_order)}")
            self.log(f"ğŸ¯ ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤: {total_count}ê°œ")
            
            for process_name in startup_order:
                if process_name not in self.managed_processes:
                    continue
                
                # ëª¨ë“ˆ ì„¤ì • ì¡°íšŒ
                module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                if not module_config:
                    self.log(f"âŒ {process_name}: ëª¨ë“ˆ ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                    failed_processes.append(process_name)
                    continue
                
                if not module_config.auto_start:
                    self.log(f"â­ï¸ {process_name}: ìë™ ì‹œì‘ ë¹„í™œì„±í™”, ê±´ë„ˆëœ€")
                    continue
                
                self.log(f"ğŸ”„ {process_name} ì‹œì‘ ì¤‘... (ìš°ì„ ìˆœìœ„: {module_config.priority})")
                
                # v2 ProcessManagerë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
                process_start_time = datetime.now()
                
                start_success = self.v3_0_components['process_manager'].start_process(
                    process_name, 
                    module_config.script_path, 
                    getattr(module_config, 'args', []),
                    module_config.working_directory
                )
                
                process_start_duration = (datetime.now() - process_start_time).total_seconds()
                
                if start_success:
                    # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì„±ê³µ
                    process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
success_count_+ =  1
                    
                    self.log(f"âœ… {process_name} ì‹œì‘ ì„±ê³µ (PID: {process_info.pid if process_info else 'N/A'}, ì†Œìš”ì‹œê°„: {process_start_duration:.1f}ì´ˆ)")
                    
                    # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
                    try:
            pass  # REMOVED
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.ACTIVE)
                        self.log(f"ğŸ“‹ {process_name} ëª¨ë“ˆ ìƒíƒœë¥¼ ACTIVEë¡œ ì—…ë°ì´íŠ¸")
                    except Exception as e:
                        self.log(f"âš ï¸ {process_name} ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
                    
                    # í”„ë¡œì„¸ìŠ¤ ì´ˆê¸°í™” ëŒ€ê¸° (ì˜ì¡´ì„± ê³ ë ¤)
                    if hasattr(module_config, 'startup_delay'):
                        startup_delay = module_config.startup_delay
                    else:
                        startup_delay = 3  # ê¸°ë³¸ 3ì´ˆ ëŒ€ê¸°
                    
                    self.log(f"â³ {process_name} ì´ˆê¸°í™” ëŒ€ê¸° ì¤‘... ({startup_delay}ì´ˆ)")
                    time.sleep(startup_delay)
                    
                    # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¬í™•ì¸
                    if not self.v3_0_components['process_manager'].is_process_running(process_name):
                        self.log(f"âš ï¸ {process_name} ì‹œì‘ í›„ ì¦‰ì‹œ ì¢…ë£Œë¨, ë³µêµ¬ ì‹œë„")
                        # ì¦‰ì‹œ ë³µêµ¬ ì‹œë„
                        recovery_success = self.v3_0_components['process_manager'].restart_process(process_name)
                        if not recovery_success:
                            failed_processes.append(process_name)
success_count_- =  1
                            self.log(f"âŒ {process_name} ë³µêµ¬ ì‹¤íŒ¨")
                
                else:
                    # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨
                    failed_processes.append(process_name)
                    self.log(f"âŒ {process_name} ì‹œì‘ ì‹¤íŒ¨ (ì†Œìš”ì‹œê°„: {process_start_duration:.1f}ì´ˆ)")
                    
                    # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
                    try:
            pass  # REMOVED
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.FAILED)
                        self.log(f"ğŸ“‹ {process_name} ëª¨ë“ˆ ìƒíƒœë¥¼ FAILEDë¡œ ì—…ë°ì´íŠ¸")
                    except Exception as e:
                        self.log(f"âš ï¸ {process_name} ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
                
                # í”„ë¡œì„¸ìŠ¤ ê°„ ì‹œì‘ ê°„ê²© (ì˜ì¡´ì„± ê³ ë ¤)
                time.sleep(1)
            
            # ì „ì²´ ì‹œì‘ ì™„ë£Œ ì‹œê°„ ê³„ì‚°
            total_startup_time = (datetime.now() - startup_start_time).total_seconds()
            
            # ê²°ê³¼ ë³´ê³  ë° ì•Œë¦¼
            if success_count == total_count:
                self.log(f"ğŸ‰ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì™„ë£Œ! ({success_count}/{total_count}, ì´ ì†Œìš”ì‹œê°„: {total_startup_time:.1f}ì´ˆ)")
                
                # v2 NotificationManagerë¥¼ ì‚¬ìš©í•œ ì‹œì‘ ì•Œë¦¼ ì „ì†¡
                # v2 í–¥ìƒëœ ì‹œì‘ ì•Œë¦¼ ì‚¬ìš©
                self.send_startup_notification_v2()
                
                return True
                
            elif success_count > 0:
                self.log(f"âš ï¸ ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ë§Œ ì‹œì‘ë¨ ({success_count}/{total_count}, ì‹¤íŒ¨: {len(failed_processes)}ê°œ)")
                
                # ë¶€ë¶„ ì„±ê³µ ì‹œì—ë„ v2 í–¥ìƒëœ ì‹œì‘ ì•Œë¦¼ ì‚¬ìš© (ì‹¤íŒ¨ ì •ë³´ í¬í•¨)
                self.send_startup_notification_v2()
                
                return True  # ì¼ë¶€ë¼ë„ ì„±ê³µí•˜ë©´ True ë°˜í™˜
                
            else:
                self.log(f"âŒ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨ ({success_count}/{total_count})")
                
                # ì „ì²´ ì‹¤íŒ¨ ì•Œë¦¼
                if self.v3_0_components['notification_manager']:
                    self.v3_0_components['notification_manager'].send_critical_alert(
                        "POSCO WatchHamster v3.0 ì‹œì‘ ì‹¤íŒ¨",
                        {
                            'ì´_í”„ë¡œì„¸ìŠ¤': f'{total_count}ê°œ',
                            'ì‹¤íŒ¨í•œ_í”„ë¡œì„¸ìŠ¤': ', '.join(failed_processes),
                            'ì†Œìš”ì‹œê°„': f'{total_startup_time:.1f}ì´ˆ',
                            'í•„ìš”_ì¡°ì¹˜': 'ìˆ˜ë™ í™•ì¸ ë° ì¬ì‹œì‘'
                        }
                    )
                else:
                    # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                    self.send_notification(
                        f"ğŸš¨ POSCO WatchHamster v3.0 ì‹œì‘ ì‹¤íŒ¨/n/n"
                        f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"âŒ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨ ({total_count}ê°œ)/n"
                        f"ğŸ” ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤: {', '.join(failed_processes)}/n"
                        f"â±ï¸ ì†Œìš”ì‹œê°„: {total_startup_time:.1f}ì´ˆ/n"
                        f"ğŸ› ï¸ ìˆ˜ë™ í™•ì¸ ë° ì¬ì‹œì‘ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                        is_error=True
                    )
                
                return False
                
        except Exception as e:
            self.log(f"âŒ v2 í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì˜¤ë¥˜: {e}")
            import traceback
            self.log(f"âŒ ìƒì„¸ ì˜¤ë¥˜: {traceback.format_exc()}")
            return False
    
    def stop_all_processes(self) -> bool:
        """
        ëª¨ë“  ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ - v2 í†µí•© ì•„í‚¤í…ì²˜
        
        v2 ì»´í¬ë„ŒíŠ¸ ì‚¬ìš© ê°€ëŠ¥ ì‹œ ì˜ì¡´ì„± ìˆœì„œë¥¼ ê³ ë ¤í•˜ì—¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ì§€í•˜ê³ ,
        ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±í•©ë‹ˆë‹¤.
        
        Returns:
            bool: ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì„±ê³µ ì—¬ë¶€
        """
        try:
            self.log("ğŸ›‘ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì¤‘...")
            
            if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                # v2 ì•„í‚¤í…ì²˜ ì‚¬ìš©
                return self._stop_processes_v2()
            else:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                self.log("ğŸ“‹ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€")
                self.stop_monitor_process()
                return True
                
        except Exception as e:
            self.log(f"âŒ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì˜¤ë¥˜: {e}")
            return False
    
    def _stop_processes_v3_0(self) -> bool:
        """
        v2 ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€
        
        Returns:
            bool: ì¤‘ì§€ ì„±ê³µ ì—¬ë¶€
        """
        try:
            success_count = 0
            total_count = len(self.managed_processes)
            stopped_processes = []
            
            # ì—­ìˆœìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ (ì˜ì¡´ì„± ê³ ë ¤)
            shutdown_order = list(reversed(self.v3_0_components['module_registry'].get_modules_by_dependency_order()))
            
            for process_name in shutdown_order:
                if process_name not in self.managed_processes:
                    continue
                
                if self.v3_0_components['process_manager'].is_process_running(process_name):
                    self.log(f"â¹ï¸ {process_name} ì¤‘ì§€ ì¤‘...")
                    
                    if self.v3_0_components['process_manager'].stop_process(process_name):
success_count_+ =  1
                        stopped_processes.append(process_name)
                        self.log(f"âœ… {process_name} ì¤‘ì§€ ì„±ê³µ")
                        
                        # ëª¨ë“ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
                        try:
            pass  # REMOVED
                            self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.INACTIVE)
                        except ImportError:
                            pass  # ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
                    else:
                        self.log(f"âŒ {process_name} ì¤‘ì§€ ì‹¤íŒ¨")
                else:
success_count_+ =  1  # ì´ë¯¸ ì¤‘ì§€ëœ í”„ë¡œì„¸ìŠ¤
                    stopped_processes.append(process_name)
                    self.log(f"ğŸ“‹ {process_name}: ì´ë¯¸ ì¤‘ì§€ë¨")
                
                # í”„ë¡œì„¸ìŠ¤ ê°„ ì¤‘ì§€ ê°„ê²©
                time.sleep(1)
            
            # ê²°ê³¼ ë³´ê³ 
            if success_count == total_count:
                self.log(f"ğŸ‰ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì™„ë£Œ! ({success_count}/{total_count})")
                
                # v2 NotificationManagerë¥¼ ì‚¬ìš©í•œ ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡
                if self.v3_0_components['notification_manager']:
                    shutdown_status = {
                        'uptime': datetime.now() - datetime.now(),  # ì‹¤ì œë¡œëŠ” ì‹œì‘ ì‹œê°„ì„ ì¶”ì í•´ì•¼ í•¨
                        'stopped_processes': stopped_processes,
                        'total_restarts': getattr(self.v3_0_components['process_manager'], 'total_restarts', 0)
                    }
                    self.v3_0_components['notification_manager'].send_shutdown_notification(shutdown_status)
                
                return True
            else:
                self.log(f"âš ï¸ ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ë§Œ ì¤‘ì§€ë¨ ({success_count}/{total_count})")
                return success_count > 0
                
        except Exception as e:
            self.log(f"âŒ v2 í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì˜¤ë¥˜: {e}")
            return False
    
    def restart_process(self, process_name: str) -> bool:
        """
        ê°œë³„ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
        
        Args:
            process_name (str): ì¬ì‹œì‘í•  í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            bool: ì¬ì‹œì‘ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if process_name not in self.managed_processes:
                self.log(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤: {process_name}")
                return False
            
            self.log(f"ğŸ”„ {process_name} ì¬ì‹œì‘ ì¤‘...")
            
            if not self.module_registry:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                if process_name == 'integrated_report_scheduler':
                    self.stop_monitor_process()
                    time.sleep(3)
                    return self.start_monitor_process()
                else:
                    self.log(f"âš ï¸ ê¸°ì¡´ ë°©ì‹ì—ì„œëŠ” {process_name} ê°œë³„ ì¬ì‹œì‘ ë¶ˆê°€")
                    return False
            
            # Enhanced ProcessManager ì‚¬ìš©
            success = self.process_manager.restart_process(process_name)
            
            if success:
                self.log(f"âœ… {process_name} ì¬ì‹œì‘ ì„±ê³µ")
                
                # ë³µêµ¬ ì•Œë¦¼ ì „ì†¡
                if self.notification_manager:
                    recovery_details = {
                        'recovery_stage': 'ê°œë³„ ì¬ì‹œì‘',
                        'recovery_time': 5,  # ëŒ€ëµì ì¸ ì‹œê°„
                        'new_pid': self.process_manager.get_process_info(process_name).pid if self.process_manager.get_process_info(process_name) else None
                    }
                    self.notification_manager.send_recovery_success(process_name, recovery_details)
            else:
                self.log(f"âŒ {process_name} ì¬ì‹œì‘ ì‹¤íŒ¨")
                
                # ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡
                if self.notification_manager:
                    process_info = self.process_manager.get_process_info(process_name)
                    error_details = {
                        'error_message': process_info.last_error if process_info else 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
                        'restart_count': process_info.restart_count if process_info else 0,
                        'max_attempts': 3,
                        'auto_recovery_enabled': True
                    }
                    self.notification_manager.send_process_error(process_name, error_details)
            
            return success
            
        except Exception as e:
            self.log(f"âŒ {process_name} ì¬ì‹œì‘ ì˜¤ë¥˜: {e}")
            return False
    
    def get_process_status(self, process_name: str) -> dict:
        """
        ê°œë³„ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¡°íšŒ
        
        Args:
            process_name (str): ì¡°íšŒí•  í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            
        Returns:
            dict: í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì •ë³´
        """
        try:
            if process_name not in self.managed_processes:
                return {
                    'error': f'ì•Œ ìˆ˜ ì—†ëŠ” í”„ë¡œì„¸ìŠ¤: {process_name}',
                    'status': 'unknown'
                }
            
            if not self.module_registry:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                is_running = self.is_monitor_running() if process_name in ['integrated_report_scheduler', 'realtime_news_monitor'] else False
                return {
                    'name': process_name,
                    'status': 'running' if is_running else 'stopped',
                    'pid': None,
                    'restart_count': 0,
                    'last_error': None
                }
            
            # Enhanced ProcessManager ì‚¬ìš©
            process_info = self.process_manager.get_process_info(process_name)
            
            if process_info:
                return {
                    'name': process_info.name,
                    'status': process_info.status.value,
                    'pid': process_info.pid,
                    'start_time': process_info.start_time.isoformat() if process_info.start_time else None,
                    'last_health_check': process_info.last_health_check.isoformat(),
                    'restart_count': process_info.restart_count,
                    'last_error': process_info.last_error,
                    'cpu_usage': process_info.cpu_usage,
                    'memory_usage': process_info.memory_usage
                }
            else:
                return {
                    'name': process_name,
                    'status': 'not_found',
                    'error': 'í”„ë¡œì„¸ìŠ¤ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
                }
                
        except Exception as e:
            return {
                'name': process_name,
                'status': 'error',
                'error': str(e)
            }
    
    def get_all_process_status(self) -> dict:
        """
        ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¡°íšŒ
        
        Returns:
            dict: ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´
        """
        try:
            if not self.module_registry:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                monitor_running = self.is_monitor_running()
                return {
                    'timestamp': datetime.now().isoformat(),
                    'total_processes': len(self.managed_processes),
                    'running_processes': 2 if monitor_running else 0,
                    'failed_processes': 0 if monitor_running else len(self.managed_processes),
                    'processes': {
                        name: self.get_process_status(name) for name in self.managed_processes
                    }
                }
            
            # Enhanced ProcessManager ì‚¬ìš©
            system_status = self.process_manager.get_system_status()
            
            # í”„ë¡œì„¸ìŠ¤ë³„ ìƒì„¸ ì •ë³´ ì¶”ê°€
            process_details = {}
            for process_name in self.managed_processes:
                process_details[process_name] = self.get_process_status(process_name)
            
            system_status['processes'] = process_details
            return system_status
            
        except Exception as e:
            return {
                'timestamp': datetime.now().isoformat(),
                'error': str(e),
                'total_processes': len(self.managed_processes),
                'running_processes': 0,
                'failed_processes': len(self.managed_processes)
            }
    
    # ê¸°ì¡´ ë©”ì„œë“œë“¤ê³¼ì˜ í†µí•©
    def start_monitor_process(self):
        """ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ (í†µí•© ë¦¬í¬íŠ¸ + ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°)"""
        try:
            if self.is_monitor_running():
                self.log("âœ… ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.")
                return True
            
            self.log("ğŸš€ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì¤‘...")
            
            success_count = 0
            
            # 1. í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰
            try:
                if os.name == 'nt':  # Windows
                    self.monitor_process = subprocess.Popen(
                        [sys.executable, self.monitor_script],
                        cwd=self.script_dir,
                        creationflags=subprocess.CREATE_NEW_CONSOLE
                    )
                else:  # macOS/Linux
                    self.monitor_process = subprocess.Popen(
                        [sys.executable, self.monitor_script],
                        cwd=self.script_dir
                    )
                
                time.sleep(3)  # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ëŒ€ê¸°
                
                if self.monitor_process.poll() is None:
                    self.log("âœ… í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ ì„±ê³µ")
success_count_+ =  1
                else:
                    self.log("âŒ í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ ì‹¤íŒ¨")
                    
            except Exception as e:
                self.log(f"âŒ í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ ì˜¤ë¥˜: {e}")
            
            # 2. ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° ì‹¤í–‰
            try:
                if os.name == 'nt':  # Windows
                    self.realtime_process = subprocess.Popen(
                        [sys.executable, self.realtime_script],
                        cwd=self.script_dir,
                        creationflags=subprocess.CREATE_NEW_CONSOLE
                    )
                else:  # macOS/Linux
                    self.realtime_process = subprocess.Popen(
                        [sys.executable, self.realtime_script],
                        cwd=self.script_dir
                    )
                
                time.sleep(3)  # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ëŒ€ê¸°
                
                if self.realtime_process.poll() is None:
                    self.log("âœ… ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° ì‹œì‘ ì„±ê³µ")
success_count_+ =  1
                else:
                    self.log("âŒ ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° ì‹œì‘ ì‹¤íŒ¨")
                    
            except Exception as e:
                self.log(f"âŒ ì‹¤ì‹œê°„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° ì‹œì‘ ì˜¤ë¥˜: {e}")
            
            # ê²°ê³¼ í™•ì¸
            if success_count == 2:
                self.log("ğŸ‰ ëª¨ë“  ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì™„ë£Œ!")
                return True
            elif success_count == 1:
                self.log("âš ï¸ ì¼ë¶€ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ë§Œ ì‹œì‘ë¨")
                return True
            else:
                self.log("âŒ ëª¨ë“  ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            self.log(f"âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì˜¤ë¥˜: {e}")
            return False
    
    def stop_monitor_process(self):
        """ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ (í†µí•© ë¦¬í¬íŠ¸ + ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°)"""
        try:
            # ì‹¤í–‰ ì¤‘ì¸ ëª¨ë“  ê´€ë ¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                        cmdline = proc.info['cmdline']
                        if cmdline and ('integrated_report_scheduler.py' in ' '.join(cmdline) or 
                                       'realtime_news_monitor.py' in ' '.join(cmdline)):
                            proc.terminate()
                            script_name = "í†µí•© ë¦¬í¬íŠ¸" if 'integrated_report_scheduler.py' in ' '.join(cmdline) else "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°"
                            self.log(f"â¹ï¸ {script_name} í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ: PID {proc.info['pid']}")
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # í”„ë¡œì„¸ìŠ¤ ê°ì²´ ì´ˆê¸°í™”
            if self.monitor_process:
                self.monitor_process = None
            if self.realtime_process:
                self.realtime_process = None
                
            time.sleep(2)
            self.log("âœ… ëª¨ë“  ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì™„ë£Œ")
            
        except Exception as e:
            self.log(f"âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€ ì˜¤ë¥˜: {e}")
    
    # ë‰´ìŠ¤ ê´€ë ¨ ìŠ¤ì¼€ì¤„ ì‘ì—… ì œê±° - ì›Œì¹˜í–„ìŠ¤í„°ëŠ” ìˆœìˆ˜ ì‹œìŠ¤í…œ ê´€ë¦¬ë§Œ ë‹´ë‹¹
    # ë‰´ìŠ¤ ê´€ë ¨ ê¸°ëŠ¥ì€ realtime_news_monitor.pyì™€ integrated_report_scheduler.pyì—ì„œ ì²˜ë¦¬
    
    # ë‰´ìŠ¤ ê´€ë ¨ ì‹¤í–‰ í•¨ìˆ˜ë“¤ ì œê±° - ì›Œì¹˜í–„ìŠ¤í„°ëŠ” ìˆœìˆ˜ ì‹œìŠ¤í…œ ê´€ë¦¬ë§Œ ë‹´ë‹¹
    # ë‰´ìŠ¤ ê´€ë ¨ ê¸°ëŠ¥ì€ realtime_news_monitor.pyì™€ integrated_report_scheduler.pyì—ì„œ ì²˜ë¦¬
    
    def execute_integrated_report_generation(self):
        """í†µí•© ë¦¬í¬íŠ¸ ìƒì„± ì‹¤í–‰ (17:59)"""
        try:
            self.log("ğŸ“Š í†µí•© ë¦¬í¬íŠ¸ ìƒì„± ì‹œì‘")
            
            if self.integrated_scheduler_enabled:
                success = self.integrated_scheduler.generate_daily_report()
                if success:
    def execute_integrated_report_notification(self):
        """í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì‹¤í–‰ (18:00)"""
        try:
            # ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì²´í¬
            if self.is_quiet_hours():
                self.log("ğŸŒ™ ì¡°ìš©í•œ ì‹œê°„ëŒ€ - í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ìƒëµ")
                return
            
            self.log("ğŸ“¨ í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì‹œì‘")
            
            if self.integrated_scheduler_enabled:
                success = self.integrated_scheduler.send_daily_report_notification()
                if success:
                    self.log("âœ… í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì™„ë£Œ")
                else:
                    self.log("âŒ í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì‹¤íŒ¨")
            else:
                self.log("âš ï¸ í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ë¹„í™œì„±í™”ë¨")
                
        except Exception as e:
            self.log(f"âŒ í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì˜¤ë¥˜: {e}")
    
                    self.log("âœ… í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì™„ë£Œ")
                else:
                    self.log("âŒ í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì‹¤íŒ¨")
            else:
                self.log("âš ï¸ í†µí•© ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ ë¹„í™œì„±í™”ë¨")
                
        except Exception as e:
            self.log(f"âŒ í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡ ì˜¤ë¥˜: {e}")
    
    def check_scheduled_tasks(self):
        """ìŠ¤ì¼€ì¤„ëœ ì‘ì—… ì²´í¬ ë° ì‹¤í–‰"""
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        today_key = current_time.strftime('%Y-%m-%d')
        
        # ë§¤ì¼ 06:00 - í˜„ì¬ ìƒíƒœ ì²´í¬
        if current_hour == 6 and current_minute == 0:
            if self.last_scheduled_tasks['morning_status_check'] != today_key:
                self.execute_scheduled_task("1", "ì•„ì¹¨ í˜„ì¬ ìƒíƒœ ì²´í¬")
                self.last_scheduled_tasks['morning_status_check'] = today_key
        
        # ë§¤ì¼ 06:10 - ì˜ì—…ì¼ ë¹„êµ ë¶„ì„
        if current_hour == 6 and current_minute == 10:
            if self.last_scheduled_tasks['morning_comparison'] != today_key:
                self.execute_scheduled_task("2", "ì•„ì¹¨ ì˜ì—…ì¼ ë¹„êµ ë¶„ì„")
                self.last_scheduled_tasks['morning_comparison'] = today_key
        
        # ë§¤ì¼ 17:59 - í†µí•© ë¦¬í¬íŠ¸ ìƒì„±
        if current_hour == 17 and current_minute == 59:
            if self.last_scheduled_tasks['integrated_report_generation'] != today_key:
                self.execute_integrated_report_generation()
                self.last_scheduled_tasks['integrated_report_generation'] = today_key
        
        # ë§¤ì¼ 18:00 - í†µí•© ë¦¬í¬íŠ¸ ì•Œë¦¼ ë°œì†¡
        if current_hour == 18 and current_minute == 0:
            if self.last_scheduled_tasks['integrated_report_notification'] != today_key:
                self.execute_integrated_report_notification()
                self.last_scheduled_tasks['integrated_report_notification'] = today_key
            # ê¸°ì¡´ ì¼ì¼ ìš”ì•½ ë¦¬í¬íŠ¸ë„ ìœ ì§€
            if self.last_scheduled_tasks['evening_daily_summary'] != today_key:
                self.execute_scheduled_task("5", "ì €ë… ì¼ì¼ ìš”ì•½ ë¦¬í¬íŠ¸")
                self.last_scheduled_tasks['evening_daily_summary'] = today_key
        
        # ë§¤ì¼ 18:10 - ìƒì„¸ ì¼ì¼ ìš”ì•½
        if current_hour == 18 and current_minute == 10:
            if self.last_scheduled_tasks['evening_detailed_summary'] != today_key:
                self.execute_scheduled_task("7", "ì €ë… ìƒì„¸ ì¼ì¼ ìš”ì•½")
                self.last_scheduled_tasks['evening_detailed_summary'] = today_key
        
        # ë§¤ì¼ 18:20 - ê³ ê¸‰ ë¶„ì„
        if current_hour == 18 and current_minute == 20:
            if self.last_scheduled_tasks['evening_advanced_analysis'] != today_key:
                self.execute_scheduled_task("8", "ì €ë… ê³ ê¸‰ ë¶„ì„")
                self.last_scheduled_tasks['evening_advanced_analysis'] = today_key
        
        # ë§¤ì‹œê°„ ì •ê° - í˜„ì¬ ìƒíƒœ ì²´í¬ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì œì™¸)
        if current_minute == 0 and not self.is_quiet_hours():
            hourly_key = f"{today_key}-{current_hour:02d}"
            if self.last_scheduled_tasks['hourly_status_check'] != hourly_key:
                self.execute_scheduled_task("1", f"ì •ì‹œ ìƒíƒœ ì²´í¬ ({current_hour}ì‹œ)")
                self.last_scheduled_tasks['hourly_status_check'] = hourly_key
    
    def is_quiet_hours(self):
        """ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì²´í¬ (19:01~05:59)"""
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # 19:01~23:59 ë˜ëŠ” 00:00~05:59
        if (current_hour == 19 and current_minute >= 1) or current_hour >= 20 or current_hour <= 5:
            return True
        return False
    
    def should_send_status_notification(self):
        """
        ì ˆëŒ€ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì •ê¸° ìƒíƒœ ì•Œë¦¼ì„ ë³´ë‚¼ ì‹œê°„ì¸ì§€ ì²´í¬
        
        ì˜ˆ: 7ì‹œ ì‹œì‘, 2ì‹œê°„ ê°„ê²© â†’ 7, 9, 11, 13, 15, 17ì‹œì— ì•Œë¦¼
        ì›Œì¹˜í–„ìŠ¤í„° ì‹œì‘ ì‹œê°„ê³¼ ë¬´ê´€í•˜ê²Œ ì ˆëŒ€ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ë™ì‘
        
        Returns:
            bool: ì•Œë¦¼ì„ ë³´ë‚¼ ì‹œê°„ì´ë©´ True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # ì •ê°(0ë¶„)ì—ë§Œ ì²´í¬ (1ë¶„ ì´ë‚´ ì˜¤ì°¨ í—ˆìš©)
        if current_minute > 1:
            return False
        
        # ì‹œì‘ ì‹œê°„ë¶€í„° ê°„ê²©ì— ë§ëŠ” ì‹œê°„ì¸ì§€ ì²´í¬
        if current_hour < self.status_notification_start_hour:
            return False
        
#_ê°„ê²©_ê³„ì‚°:_(í˜„ì¬ì‹œê°„_-_ì‹œì‘ì‹œê°„)_%_ê°„ê²© = = 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # ì´ë¯¸ ì´ ì‹œê°„ì— ì•Œë¦¼ì„ ë³´ëƒˆëŠ”ì§€ ì²´í¬
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
    def send_status_notification(self):
        """ì •ê¸° ìƒíƒœ ì•Œë¦¼ ì „ì†¡ (2ì‹œê°„ë§ˆë‹¤, 18ì‹œ ì´í›„ëŠ” ì¡°ìš©í•œ ëª¨ë“œ) - ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì ìš©"""
        try:
            current_time = datetime.now()
            is_quiet = self.is_quiet_hours()
            
            # ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            monitor_running = self.is_monitor_running()
            monitor_status = "ğŸŸ¢ ì •ìƒ ì‘ë™" if monitor_running else "ğŸ”´ ì¤‘ë‹¨ë¨"
            
            # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì‹œìŠ¤í…œ ì‚¬ìš©
            smart_status_info = None
            current_data = None
            
            if self.smart_enabled and monitor_running:
                try:
                    # í˜„ì¬ ë‰´ìŠ¤ ë°ì´í„° ì¡°íšŒ
                    current_data = self.api_client.get_news_data()
                    if current_data:
                        # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„
                        smart_status_info = self.data_processor.get_status_info(current_data)
                        self.log(f"ğŸ§  ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„ ì™„ë£Œ: {smart_status_info.get('status_text', 'ì•Œ ìˆ˜ ì—†ìŒ')}")
                    else:
                        self.log("âš ï¸ ë‰´ìŠ¤ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨")
                except Exception as e:
                    self.log(f"âš ï¸ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„ ì‹¤íŒ¨: {e}")
            
            # API ìƒíƒœ ì²´í¬ ê°œì„  - ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ APIë„ ì •ìƒìœ¼ë¡œ ê°„ì£¼
            api_normal = True
            api_status = "ğŸŸ¢ API ì •ìƒ"
            
            # ìµœì í™”ëœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œìœ¼ë¡œ API ìƒíƒœ ì²´í¬
            if not monitor_running:
                try:
                    # ê¸°ì¡´ run_monitor.py ëŒ€ì‹  ìµœì í™”ëœ ê°œë³„ ëª¨ë‹ˆí„° ì‚¬ìš©
                    if self.individual_monitors_enabled:
                        # ê°œë³„ ëª¨ë‹ˆí„°ë¡œ API ìƒíƒœ í™•ì¸
                        api_checks = []
                        
                        # ë‰´ìš•ë§ˆì¼“ì›Œì¹˜ API ì²´í¬
                        try:
                            ny_data = self.newyork_monitor.get_current_news_data()
                            api_checks.append(ny_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # ì¦ì‹œë§ˆê° API ì²´í¬  
                        try:
                            kospi_data = self.kospi_monitor.get_current_news_data()
                            api_checks.append(kospi_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # ì„œí™˜ë§ˆê° API ì²´í¬
                        try:
                            exchange_data = self.exchange_monitor.get_current_news_data()
                            api_checks.append(exchange_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # API ìƒíƒœ ì¢…í•© íŒë‹¨
                        successful_checks = sum(api_checks)
                        total_checks = len(api_checks)
                        
                        if successful_checks == total_checks:
                            api_normal = True
                            api_status = "ğŸŸ¢ API ì •ìƒ (ìµœì í™” ëª¨ë‹ˆí„° ê¸°ë°˜)"
                        elif successful_checks > 0:
                            api_normal = True
                            api_status = f"ğŸŸ¡ API ë¶€ë¶„ ì •ìƒ ({successful_checks}/{total_checks})"
                        else:
                            api_normal = False
                            api_status = "ğŸ”´ API ì—°ê²° ì‹¤íŒ¨"
                        
                        self.log(f"ğŸ“¡ ìµœì í™”ëœ ëª¨ë‹ˆí„°ë¡œ API ìƒíƒœ ì²´í¬: {api_status}")
                    else:
                        # ê°œë³„ ëª¨ë‹ˆí„° ë¹„í™œì„±í™” ì‹œ ê¸°ë³¸ API ì²´í¬
                        api_normal = self.api_client.test_connection() if hasattr(self, 'api_client') else False
                        api_status = "ğŸŸ¢ API ì •ìƒ (ê¸°ë³¸ ì²´í¬)" if api_normal else "ğŸŸ¡ API í™•ì¸ í•„ìš”"
                except Exception as e:
                    api_normal = False
                    api_status = f"ğŸŸ¡ API í™•ì¸ ë¶ˆê°€: {str(e)[:30]}"
                    self.log(f"âš ï¸ API ìƒíƒœ ì²´í¬ ì˜¤ë¥˜: {e}")
            else:
                # ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ APIë„ ì •ìƒìœ¼ë¡œ ê°„ì£¼
                self.log("ğŸ“¡ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ì¤‘ - API ìƒíƒœ ì •ìƒìœ¼ë¡œ ê°„ì£¼")
                api_normal = True
                api_status = "ğŸŸ¢ API ì •ìƒ (ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ê¸°ë°˜)"
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì •ë³´ ìˆ˜ì§‘
            resource_normal = True
            try:
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('.')
                
                # ë¦¬ì†ŒìŠ¤ ì„ê³„ê°’ ì²´í¬ (CPU 90%, ë©”ëª¨ë¦¬ 90%, ë””ìŠ¤í¬ 95%)
                resource_normal = (cpu_percent < 90 and 
                                 memory.percent < 90 and 
                                 disk.percent < 95)
                
                resource_info = (
                    f"ğŸ’» CPU ì‚¬ìš©ë¥ : {cpu_percent:.1f}%/n"
                    f"ğŸ§  ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {memory.percent:.1f}%/n"
                    f"ğŸ’¾ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ : {disk.percent:.1f}%"
                )
            except:
                resource_normal = False
                resource_info = "ğŸ“Š ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ì‹¤íŒ¨"
            
            # ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì²´í¬ (19:01~05:59)
            if is_quiet:
                # ì¡°ìš©í•œ ì‹œê°„ëŒ€: ì¤‘ìš”í•œ ë¬¸ì œê°€ ìˆì„ ë•Œë§Œ ì•Œë¦¼
                # í•µì‹¬ ë¬¸ì œ: ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨, ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì„ê³„ê°’ ì´ˆê³¼
                has_problem = not monitor_running or not resource_normal
                
                if has_problem:
                    # ì¤‘ìš”í•œ ë¬¸ì œ ë°œìƒ ì‹œì—ë§Œ ì•Œë¦¼ ì „ì†¡
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨")
                        if not api_normal:
                            problem_details.append("âŒ API ì—°ê²° ë¬¸ì œ")
                    if not resource_normal:
                        problem_details.append("âŒ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì„ê³„ê°’ ì´ˆê³¼")
                    
                    self.send_notification(
                        f"ğŸš¨ POSCO WatchHamster v3.0 ì¤‘ìš” ë¬¸ì œ ê°ì§€/n/n"
                        f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"ğŸš¨ ê°ì§€ëœ ë¬¸ì œ:/n" + "/n".join(f"   â€¢ {problem}" for problem in problem_details) + "/n/n"
                        f"ğŸ” ìƒì„¸ ìƒíƒœ:/n"
                        f"   â€¢ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤: {monitor_status}/n"
                        f"   â€¢ API ì—°ê²°: {api_status}/n"
                        f"{resource_info}/n/n"
                        f"ğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘...",
                        is_error=True
                    )
                    self.log("ğŸš¨ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì¤‘ìš” ë¬¸ì œ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                else:
                    # ì •ìƒ ìƒíƒœ: ë¡œê·¸ë§Œ ê¸°ë¡, ì•Œë¦¼ ì—†ìŒ
                    self.log(f"ğŸŒ™ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì •ìƒ ìƒíƒœ í™•ì¸ (ì•Œë¦¼ ì—†ìŒ) - {current_time.strftime('%H:%M:%S')}")
            else:
                # ì¼ë°˜ ì‹œê°„ëŒ€ (06:00~19:00): ì •ìƒì ì¸ ìƒíƒœ ì•Œë¦¼ ì „ì†¡
                if self.smart_enabled and smart_status_info and current_data:
                    # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼ ì „ì†¡
                    try:
                        self.smart_notifier.send_smart_status_notification(current_data, smart_status_info)
                        self.log("ğŸ§  ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    except Exception as e:
                        self.log(f"âš ï¸ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ë³¸ ì•Œë¦¼ìœ¼ë¡œ ëŒ€ì²´: {e}")
                        # ìŠ¤ë§ˆíŠ¸ ì•Œë¦¼ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì•Œë¦¼ìœ¼ë¡œ ëŒ€ì²´
                        self._send_basic_status_notification(current_time, monitor_status, api_status, resource_info)
                else:
                    # ìŠ¤ë§ˆíŠ¸ ì‹œìŠ¤í…œ ë¹„í™œì„±í™” ë˜ëŠ” ë°ì´í„° ì—†ìŒ ì‹œ ê¸°ë³¸ ì•Œë¦¼
                    self._send_basic_status_notification(current_time, monitor_status, api_status, resource_info)
                
                # ê°œë³„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ìƒíƒœ ì¶”ê°€ ì²´í¬
                if self.individual_monitors_enabled:
                    self._check_individual_monitors_status()
                
                self.log("ğŸ“Š ì •ê¸° ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
            
        except Exception as e:
            self.log(f"âŒ ì •ê¸° ìƒíƒœ ì•Œë¦¼ ì‹¤íŒ¨: {e}")
    def _send_basic_status_notification(self, current_time, monitor_status, api_status, resource_info):
        """
        ê¸°ë³¸ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ (ìŠ¤ë§ˆíŠ¸ ì‹œìŠ¤í…œ ë¹„í™œì„±í™” ì‹œ ì‚¬ìš©)
        
        Args:
            current_time (datetime): í˜„ì¬ ì‹œê°„
            monitor_status (str): ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ
            api_status (str): API ì—°ê²° ìƒíƒœ
            resource_info (str): ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì •ë³´
        """
        # ë‹¤ìŒ ì•Œë¦¼ ì‹œê°„ ê³„ì‚° (ì ˆëŒ€ ì‹œê°„ ê¸°ì¤€)
        current_hour = current_time.hour
        next_notification_hour = None
        
        # í˜„ì¬ ì‹œê°„ ì´í›„ì˜ ë‹¤ìŒ ì•Œë¦¼ ì‹œê°„ ì°¾ê¸°
        for hour in range(current_hour + 1, 24):
            if hour >= self.status_notification_start_hour:
                hour_diff = hour - self.status_notification_start_hour
                if hour_diff % self.status_notification_interval_hours == 0:
                    next_notification_hour = hour
                    break
        
        # ì˜¤ëŠ˜ ì¤‘ì— ë‹¤ìŒ ì•Œë¦¼ ì‹œê°„ì´ ì—†ìœ¼ë©´ ë‚´ì¼ ì²« ì•Œë¦¼ ì‹œê°„
        if next_notification_hour is None:
            next_notification_hour = self.status_notification_start_hour
        
        next_notification_time = f"{next_notification_hour:02d}:00"
        
        # ê°œë³„ ë‰´ìŠ¤ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘
        news_status_info = self._get_detailed_news_status()
        
        # ì‚¬ìš©ìê°€ ë³´ì—¬ì¤€ ìº¡ì²˜ì™€ ì •í™•íˆ ê°™ì€ í˜•íƒœë¡œ ì•Œë¦¼ ì „ì†¡
        self.send_notification(f"ë°ì´í„° ê°±ì‹  ì—†ìŒ\n\n{news_status_info}")
    
    def _send_hourly_status_notification(self, task_name):
        """
        ë§¤ì‹œê°„ ì •ê° ìƒíƒœ ì²´í¬ ì•Œë¦¼ ì „ì†¡ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ì—ë„ ëª…ì‹œì  ì•Œë¦¼)
        
        Args:
            task_name (str): ì‘ì—…ëª…
        """
        try:
            current_time = datetime.now()
            current_hour = current_time.hour
            is_quiet = self.is_quiet_hours()
            
            # ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            monitor_running = self.is_monitor_running()
            monitor_status = "ğŸŸ¢ ì •ìƒ ì‘ë™" if monitor_running else "ğŸ”´ ì¤‘ë‹¨ë¨"
            
            # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ íŒë‹¨ ì‹œìŠ¤í…œ ì‚¬ìš©
            smart_status_info = None
            current_data = None
            
            if self.smart_enabled and monitor_running:
                try:
                    # í˜„ì¬ ë‰´ìŠ¤ ë°ì´í„° ì¡°íšŒ
                    current_data = self.api_client.get_news_data()
                    if current_data:
                        # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„
                        smart_status_info = self.data_processor.get_status_info(current_data)
                        self.log(f"ğŸ§  ë§¤ì‹œê°„ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„ ì™„ë£Œ: {smart_status_info.get('status_text', 'ì•Œ ìˆ˜ ì—†ìŒ')}")
                    else:
                        self.log("âš ï¸ ë§¤ì‹œê°„ ë‰´ìŠ¤ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨")
                except Exception as e:
                    self.log(f"âš ï¸ ë§¤ì‹œê°„ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ë¶„ì„ ì‹¤íŒ¨: {e}")
            
            # API ìƒíƒœ ì²´í¬
            api_normal = True
            api_status = "ğŸŸ¢ API ì •ìƒ"
            
            if not monitor_running and self.individual_monitors_enabled:
                # ê°œë³„ ëª¨ë‹ˆí„°ë¡œ API ìƒíƒœ í™•ì¸
                api_checks = []
                
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    api_checks.append(ny_data is not None)
                except:
                    api_checks.append(False)
                
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    api_checks.append(kospi_data is not None)
                except:
                    api_checks.append(False)
                
                try:
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    api_checks.append(exchange_data is not None)
                except:
                    api_checks.append(False)
                
                successful_checks = sum(api_checks)
                total_checks = len(api_checks)
                
                if successful_checks == total_checks:
                    api_normal = True
                    api_status = "ğŸŸ¢ API ì •ìƒ"
                elif successful_checks > 0:
                    api_normal = True
                    api_status = f"ğŸŸ¡ API ë¶€ë¶„ ì •ìƒ ({successful_checks}/{total_checks})"
                else:
                    api_normal = False
                    api_status = "ğŸ”´ API ì—°ê²° ì‹¤íŒ¨"
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì •ë³´
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                resource_info = (
                    f"ğŸ’» CPU: {cpu_percent:.1f}% | "
                    f"ğŸ§  ë©”ëª¨ë¦¬: {memory.percent:.1f}% | "
                    f"ğŸ’¾ ë””ìŠ¤í¬: {disk.percent:.1f}%"
                )
            except:
                resource_info = "ğŸ“Š ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ì‹¤íŒ¨"
            
            # ì¡°ìš©í•œ ì‹œê°„ëŒ€ êµ¬ë¶„í•˜ì—¬ ì•Œë¦¼ ì „ì†¡ (19:01~05:59)
            if is_quiet:
                # ì¡°ìš©í•œ ì‹œê°„ëŒ€: ì¤‘ìš”í•œ ë¬¸ì œê°€ ìˆì„ ë•Œë§Œ ì•Œë¦¼
                has_problem = not monitor_running or not api_normal
                
                if has_problem:
                    # ì¤‘ìš”í•œ ë¬¸ì œ ë°œìƒ ì‹œì—ë§Œ ì•Œë¦¼ ì „ì†¡
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨")
                    if not api_normal:
                        problem_details.append("âŒ API ì—°ê²° ë¬¸ì œ")
                    
                    self.send_notification(
                        f"ğŸš¨ POSCO ì›Œì¹˜í–„ìŠ¤í„° ë§¤ì‹œê°„ ì²´í¬ - ì¤‘ìš” ë¬¸ì œ ê°ì§€\n\n"
                        f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"ğŸš¨ ê°ì§€ëœ ë¬¸ì œ:\n" + "\n".join(f"   â€¢ {problem}" for problem in problem_details) + "\n\n"
                        f"ğŸ” ìƒì„¸ ìƒíƒœ:\n"
                        f"   â€¢ ëª¨ë‹ˆí„°ë§: {monitor_status}\n"
                        f"   â€¢ API: {api_status}\n"
                        f"   â€¢ {resource_info}\n"
                        f"â° ë‹¤ìŒ ì²´í¬: {(current_hour + 1) % 24:02d}:00\n"
                        f"ğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘...",
                        is_error=True
                    )
                    self.log(f"ğŸš¨ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ë§¤ì‹œê°„ ì²´í¬ ì¤‘ìš” ë¬¸ì œ ì•Œë¦¼ ì „ì†¡ ({current_hour}ì‹œ)")
                else:
                    # ì •ìƒ ìƒíƒœ: ë¡œê·¸ë§Œ ê¸°ë¡, ì•Œë¦¼ ì—†ìŒ
                    self.log(f"ğŸŒ™ ì¡°ìš©í•œ ì‹œê°„ëŒ€ ë§¤ì‹œê°„ ì²´í¬ ì •ìƒ ìƒíƒœ (ì•Œë¦¼ ì—†ìŒ) - {current_hour}ì‹œ")
            else:
                # ì£¼ê°„: ìƒì„¸í•œ ì•Œë¦¼
                if self.smart_enabled and smart_status_info and current_data:
                    # ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼
                    try:
                        self.smart_notifier.send_smart_status_notification(
                            current_data, 
                            smart_status_info,
                            notification_type="hourly_check"
                        )
                        self.log("ğŸ§  ë§¤ì‹œê°„ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    except Exception as e:
                        self.log(f"âš ï¸ ë§¤ì‹œê°„ ìŠ¤ë§ˆíŠ¸ ìƒíƒœ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ë³¸ ì•Œë¦¼ìœ¼ë¡œ ëŒ€ì²´: {e}")
                        # ê¸°ë³¸ ì•Œë¦¼ìœ¼ë¡œ ëŒ€ì²´
                        self.send_notification(
                            f"ğŸ• POSCO ì›Œì¹˜í–„ìŠ¤í„° ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬\n\n"
                            f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                            f"ğŸ” ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤: {monitor_status}\n"
                            f"ğŸŒ API ì—°ê²°: {api_status}\n"
                            f"ğŸ“Š {resource_info}\n"
                            f"â° ë‹¤ìŒ ì²´í¬: {(current_hour + 1) % 24:02d}:00\n"
                            f"ğŸš€ ìë™ ë³µêµ¬ ê¸°ëŠ¥: í™œì„±í™”"
                        )
                else:
                    # ê¸°ë³¸ ì•Œë¦¼
                    self.send_notification(
                        f"ğŸ• POSCO ì›Œì¹˜í–„ìŠ¤í„° ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬\n\n"
                        f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"ğŸ” ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤: {monitor_status}\n"
                        f"ğŸŒ API ì—°ê²°: {api_status}\n"
                        f"ğŸ“Š {resource_info}\n"
                        f"â° ë‹¤ìŒ ì²´í¬: {(current_hour + 1) % 24:02d}:00\n"
                        f"ğŸš€ ìë™ ë³µêµ¬ ê¸°ëŠ¥: í™œì„±í™”"
                    )
            
            self.log(f"ğŸ“Š ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ ({current_hour}ì‹œ)")
            
        except Exception as e:
            self.log(f"âŒ ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬ ì•Œë¦¼ ì‹¤íŒ¨: {e}")
            # ì˜¤ë¥˜ ë°œìƒ ì‹œì—ëŠ” ê°„ë‹¨í•œ ì•Œë¦¼
            self.send_notification(
                f"âŒ POSCO ì›Œì¹˜í–„ìŠ¤í„° ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬ ì˜¤ë¥˜\n\n"
                f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"âŒ ì˜¤ë¥˜: {str(e)}\n"
                f"ğŸ”§ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                is_error=True
            )
    
            # ì˜¤ë¥˜ ë°œìƒ ì‹œì—ëŠ” ê°„ë‹¨í•œ ì•Œë¦¼
            self.send_notification(
                f"âŒ POSCO WatchHamster v3.0 ë§¤ì‹œê°„ ìƒíƒœ ì²´í¬ ì˜¤ë¥˜/n/n"
                f"ğŸ“… ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"âŒ ì˜¤ë¥˜: {str(e)}/n"
                f"ğŸ”§ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                is_error=True
            )
    
    def _check_individual_monitors_status(self):
        """
        ê°œë³„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ë° ë³´ê³ 
        
        ìµœì í™”ëœ ê°œë³„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œë“¤ì˜ ìƒíƒœë¥¼ í™•ì¸í•˜ê³ 
        í•„ìš”ì‹œ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
        """
        try:
            current_time = datetime.now()
            individual_status = {}
            
            # ë‰´ìš•ë§ˆì¼“ì›Œì¹˜ ìƒíƒœ ì²´í¬
            if hasattr(self, 'newyork_monitor'):
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    ny_analysis = self.newyork_monitor.analyze_publish_pattern(ny_data)
                    individual_status['newyork'] = {
                        'published': ny_analysis.get('is_published_today', False),
                        'status': ny_analysis.get('analysis', 'ìƒíƒœ ë¶ˆëª…')
                    }
                except Exception as e:
                    individual_status['newyork'] = {'error': str(e)}
            
            # ì¦ì‹œë§ˆê° ìƒíƒœ ì²´í¬
            if hasattr(self, 'kospi_monitor'):
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    kospi_analysis = self.kospi_monitor.analyze_publish_pattern(kospi_data)
                    individual_status['kospi'] = {
                        'published': kospi_analysis.get('is_published_today', False),
                        'status': kospi_analysis.get('analysis', 'ìƒíƒœ ë¶ˆëª…')
                    }
                except Exception as e:
                    individual_status['kospi'] = {'error': str(e)}
            
            # ì„œí™˜ë§ˆê° ìƒíƒœ ì²´í¬
            if hasattr(self, 'exchange_monitor'):
                try:
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    exchange_analysis = self.exchange_monitor.analyze_publish_pattern(exchange_data)
                    individual_status['exchange'] = {
                        'published': exchange_analysis.get('is_published_today', False),
                        'status': exchange_analysis.get('analysis', 'ìƒíƒœ ë¶ˆëª…')
                    }
                except Exception as e:
                    individual_status['exchange'] = {'error': str(e)}
            
            # ìƒíƒœ ìš”ì•½ ë¡œê·¸
            published_count = sum(1 for status in individual_status.values() 
                                if status.get('published', False))
            total_count = len(individual_status)
            
            if total_count > 0:
                self.log(f"ğŸ“Š ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ: {published_count}/{total_count} ë°œí–‰ ì™„ë£Œ")
                
                # ê° ë‰´ìŠ¤ë³„ ìƒíƒœ ë¡œê·¸
                news_names = {'newyork': 'ğŸŒ†ë‰´ìš•ë§ˆì¼“ì›Œì¹˜', 'kospi': 'ğŸ“ˆì¦ì‹œë§ˆê°', 'exchange': 'ğŸ’±ì„œí™˜ë§ˆê°'}
                for news_type, status in individual_status.items():
                    name = news_names.get(news_type, news_type)
                    if 'error' in status:
                        self.log(f"   {name}: âŒ ì˜¤ë¥˜ - {status['error']}")
                    elif status.get('published', False):
                        self.log(f"   {name}: âœ… {status.get('status', 'ë°œí–‰ ì™„ë£Œ')}")
                    else:
                        self.log(f"   {name}: â³ {status.get('status', 'ëŒ€ê¸° ì¤‘')}")
            
        except Exception as e:
            self.log(f"âš ï¸ ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ ì²´í¬ ì‹¤íŒ¨: {e}")
    
    def get_enhanced_status_report(self):
        """
        í–¥ìƒëœ ìƒíƒœ ë³´ê³ ì„œ ìƒì„± (ê°œë³„ ëª¨ë‹ˆí„° ì •ë³´ í¬í•¨)
        
        Returns:
            dict: í–¥ìƒëœ ìƒíƒœ ì •ë³´
        """
        try:
            # ê¸°ë³¸ ìƒíƒœ ì •ë³´
            basic_status = {
                'timestamp': datetime.now().isoformat(),
                'monitor_running': self.is_monitor_running(),
                'api_status': 'normal',  # ê¸°ë³¸ê°’
                'individual_monitors': {}
            }
            
            # ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ ì¶”ê°€
            if self.individual_monitors_enabled:
                if hasattr(self, 'newyork_monitor'):
                    ny_data = self.newyork_monitor.get_current_news_data()
                    ny_analysis = self.newyork_monitor.analyze_publish_pattern(ny_data)
                    basic_status['individual_monitors']['newyork'] = {
                        'name': 'ë‰´ìš•ë§ˆì¼“ì›Œì¹˜',
                        'published_today': ny_analysis.get('is_published_today', False),
                        'status': ny_analysis.get('status', 'unknown'),
                        'analysis': ny_analysis.get('analysis', 'ë¶„ì„ ë¶ˆê°€')
                    }
                
                if hasattr(self, 'kospi_monitor'):
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    kospi_analysis = self.kospi_monitor.analyze_publish_pattern(kospi_data)
                    basic_status['individual_monitors']['kospi'] = {
                        'name': 'ì¦ì‹œë§ˆê°',
                        'published_today': kospi_analysis.get('is_published_today', False),
                        'status': kospi_analysis.get('status', 'unknown'),
                        'analysis': kospi_analysis.get('analysis', 'ë¶„ì„ ë¶ˆê°€')
                    }
                
                if hasattr(self, 'exchange_monitor'):
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    exchange_analysis = self.exchange_monitor.analyze_publish_pattern(exchange_data)
                    basic_status['individual_monitors']['exchange'] = {
                        'name': 'ì„œí™˜ë§ˆê°',
                        'published_today': exchange_analysis.get('is_published_today', False),
                        'status': exchange_analysis.get('status', 'unknown'),
                        'analysis': exchange_analysis.get('analysis', 'ë¶„ì„ ë¶ˆê°€')
                    }
            
            return basic_status
            
        except Exception as e:
            self.log(f"âš ï¸ í–¥ìƒëœ ìƒíƒœ ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨: {e}")
            return {'error': str(e), 'timestamp': datetime.now().isoformat()}
    
    def _check_master_monitor_integration(self):
        """
        ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œê³¼ì˜ í†µí•© ìƒíƒœ ì²´í¬
        
        WatchHamster v3.0 ìƒíƒœë¥¼ í™•ì¸í•˜ê³ 
        í•„ìš”ì‹œ ì¡°ì •í•©ë‹ˆë‹¤.
        """
        try:
            current_time = datetime.now()
            
            # ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ì˜ í˜„ì¬ ì „ëµ í™•ì¸
            if hasattr(self.master_monitor, 'get_current_monitoring_strategy'):
                strategy = self.master_monitor.get_current_monitoring_strategy()
                
                # ì „ëµ ë³€ê²½ ì‹œ ë¡œê·¸ ê¸°ë¡
                if not hasattr(self, '_last_master_strategy') or self._last_master_strategy != strategy['mode']:
                    self.log(f"ğŸ›ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì „ëµ ë³€ê²½: {strategy['description']}")
                    self._last_master_strategy = strategy['mode']
                
                # ì§‘ì¤‘ ëª¨ë‹ˆí„°ë§ ì‹œê°„ëŒ€ì—ëŠ” ì›Œì¹˜í–„ìŠ¤í„° ì²´í¬ ê°„ê²© ì¡°ì •
                if strategy['interval'] <= 60:  # 1ë¶„ ê°„ê²© ì§‘ì¤‘ ëª¨ë‹ˆí„°ë§
                    # ì›Œì¹˜í–„ìŠ¤í„°ë„ ë” ìì£¼ ì²´í¬í•˜ë„ë¡ ì¡°ì • (í•˜ì§€ë§Œ ë„ˆë¬´ ìì£¼ëŠ” ì•ˆ ë¨)
                    if not hasattr(self, '_intensive_mode') or not self._intensive_mode:
                        self.log("ğŸ”¥ ì§‘ì¤‘ ëª¨ë‹ˆí„°ë§ ëª¨ë“œ ê°ì§€ - ì›Œì¹˜í–„ìŠ¤í„° ì²´í¬ ë¹ˆë„ ì¦ê°€")
                        self._intensive_mode = True
                else:
                    if hasattr(self, '_intensive_mode') and self._intensive_mode:
                        self.log("ğŸ“‹ ì¼ë°˜ ëª¨ë‹ˆí„°ë§ ëª¨ë“œ ë³µê·€ - ì›Œì¹˜í–„ìŠ¤í„° ì²´í¬ ë¹ˆë„ ì •ìƒí™”")
                        self._intensive_mode = False
            
        except Exception as e:
            self.log(f"âš ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„° í†µí•© ì²´í¬ ì‹¤íŒ¨: {e}")
    
    def send_enhanced_status_notification(self):
        """
        í–¥ìƒëœ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ (ê°œë³„ ëª¨ë‹ˆí„° ì •ë³´ í¬í•¨)
        
        ê¸°ì¡´ ìƒíƒœ ì•Œë¦¼ì— ê°œë³„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ ìƒíƒœ ì •ë³´ë¥¼ ì¶”ê°€í•˜ì—¬
        ë” ìƒì„¸í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
        """
        try:
            enhanced_status = self.get_enhanced_status_report()
            current_time = datetime.now()
            
            # ê¸°ë³¸ ìƒíƒœ ì •ë³´
            monitor_status = "ğŸŸ¢ ì •ìƒ ì‘ë™" if enhanced_status.get('monitor_running', False) else "ğŸ”´ ì¤‘ë‹¨ë¨"
            
            message = f"ğŸ›¡ï¸ POSCO ì›Œì¹˜í–„ìŠ¤í„° í–¥ìƒëœ ìƒíƒœ ë³´ê³ \n\n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"ğŸ” ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤: {monitor_status}\n\n"
            
            # ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ ì¶”ê°€
            individual_monitors = enhanced_status.get('individual_monitors', {})
            if individual_monitors:
                message += f"ğŸ“Š ê°œë³„ ë‰´ìŠ¤ ëª¨ë‹ˆí„° ìƒíƒœ:\n"
                
                for news_type, info in individual_monitors.items():
                    name = info.get('name', news_type)
                    published = info.get('published_today', False)
                    analysis = info.get('analysis', 'ë¶„ì„ ë¶ˆê°€')
                    
                    status_emoji = "âœ…" if published else "â³"
                    message += f"   {status_emoji} {name}: {analysis}\n"
                
                # ì „ì²´ ë°œí–‰ í˜„í™©
                published_count = sum(1 for info in individual_monitors.values() 
                                    if info.get('published_today', False))
                total_count = len(individual_monitors)
                message += f"\nğŸ“ˆ ì „ì²´ ë°œí–‰ í˜„í™©: {published_count}/{total_count} ì™„ë£Œ\n"
            
            # ì‹œìŠ¤í…œ í†µí•© ìƒíƒœ
            if self.master_monitor_enabled:
                message += f"\nğŸ›ï¸ ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§: ì—°ë™ í™œì„±í™”"
            if self.individual_monitors_enabled:
                message += f"\nğŸ”§ ê°œë³„ ëª¨ë‹ˆí„°ë§: ì—°ë™ í™œì„±í™”"
            
            message += f"\nâ° ë‹¤ìŒ ë³´ê³ : {(current_time + timedelta(hours=2)).strftime('%H:%M')}"
            
            payload = {
                "botName": "POSCO ì›Œì¹˜í–„ìŠ¤í„° ğŸ›¡ï¸",
                "botIconImage": BOT_PROFILE_IMAGE_URL,
                "text": "í–¥ìƒëœ ìƒíƒœ ë³´ê³ ",
                "attachments": [{
                    "color": "#17a2b8",
                    "text": message
                }]
            }
            
            response = requests.post(
                WATCHHAMSTER_WEBHOOK_URL,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                self.log("âœ… í–¥ìƒëœ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ")
                return True
            else:
                self.log(f"âŒ í–¥ìƒëœ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {response.status_code}")
                return False
                
        except Exception as e:
            self.log(f"âŒ í–¥ìƒëœ ìƒíƒœ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
            return False
    
    def manage_log_file(self):
        """ë¡œê·¸ íŒŒì¼ í¬ê¸° ê´€ë¦¬ - 10MB ì´ˆê³¼ ì‹œ ë°±ì—… í›„ ìƒˆë¡œ ì‹œì‘"""
        try:
            if os.path.exists(self.log_file):
                file_size = os.path.getsize(self.log_file)
                max_size = 10 * 1024 * 1024  # 10MB
                
                if file_size > max_size:
                    # ë°±ì—… íŒŒì¼ëª… ìƒì„±
                    backup_name = f".naming_backup/config_data_backup/watchhamster.log"
                    backup_path = os.path.join(self.script_dir, backup_name)
                    
                    # ê¸°ì¡´ ë¡œê·¸ íŒŒì¼ì„ ë°±ì—…ìœ¼ë¡œ ì´ë™
                    os.rename(self.log_file, backup_path)
                    
                    self.log(f"ğŸ“ ë¡œê·¸ íŒŒì¼ ë°±ì—… ì™„ë£Œ: {backup_name}")
                    
        except Exception as e:
            print(f"[ERROR] ë¡œê·¸ íŒŒì¼ ê´€ë¦¬ ì‹¤íŒ¨: {e}")
    
    def save_status(self):
        """í˜„ì¬ ìƒíƒœ ì €ì¥ - StateManager ì‚¬ìš©ìœ¼ë¡œ ì•ˆì •ì„± ê°œì„ """
        try:
            # ë¡œê·¸ íŒŒì¼ í¬ê¸° ê´€ë¦¬
            self.manage_log_file()
            
            # StateManagerë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ ìƒíƒœ ì €ì¥
            status = {
                "last_check": datetime.now(),
                "monitor_running": self.is_monitor_running(),
                "last_git_check": self.last_git_check,
                "last_status_notification": self.last_status_notification,
                "last_status_notification_hour": self.last_status_notification_hour,
                "watchhamster_pid": os.getpid(),
                "last_scheduled_tasks": getattr(self, 'last_scheduled_tasks', {}),
                "individual_monitors": self._get_individual_monitors_status(),
                "error_count": getattr(self, 'error_count', 0),
                "recovery_attempts": getattr(self, 'recovery_attempts', 0)
            }
            
            # StateManagerë¥¼ í†µí•œ ì•ˆì „í•œ ì €ì¥
            if self.state_manager.save_state(status):
                self.log("âœ… ìƒíƒœ ì €ì¥ ì™„ë£Œ")
            else:
                self.log("âš ï¸ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨")
                
        except Exception as e:
            self.log(f"âŒ ìƒíƒœ ì €ì¥ ì˜¤ë¥˜: {e}")
    
    def _get_individual_monitors_status(self):
        """ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ ì •ë³´ ìˆ˜ì§‘"""
        try:
            monitors_status = {}
            
            # ë‰´ìš•ë§ˆì¼“ì›Œì¹˜ ìƒíƒœ
            if hasattr(self, 'newyork_monitor'):
                monitors_status['newyork'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.newyork_monitor else 'inactive'
                }
            
            # ì¦ì‹œë§ˆê° ìƒíƒœ
            if hasattr(self, 'kospi_monitor'):
                monitors_status['kospi'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.kospi_monitor else 'inactive'
                }
            
            # ì„œí™˜ë§ˆê° ìƒíƒœ
            if hasattr(self, 'exchange_monitor'):
                monitors_status['exchange'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.exchange_monitor else 'inactive'
                }
            
            return monitors_status
            
        except Exception as e:
            self.log(f"âš ï¸ ê°œë³„ ëª¨ë‹ˆí„° ìƒíƒœ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    def _get_detailed_news_status(self):
        """
        ì‚¬ìš©ìê°€ ë³´ì—¬ì¤€ ìº¡ì²˜ì™€ ì •í™•íˆ ê°™ì€ ë°•ìŠ¤ í˜•íƒœì˜ ë‰´ìŠ¤ ìƒíƒœ ì •ë³´ ìƒì„±
        
        Returns:
            str: ë°•ìŠ¤ í˜•íƒœë¡œ í¬ë§·ëœ ë‰´ìŠ¤ ìƒíƒœ ì •ë³´
        """
        try:
            status_lines = []
            
            # EXCHANGE RATE ìƒíƒœ
            if hasattr(self, 'exchange_monitor'):
                try:
                    ex_data = self.exchange_monitor.get_current_news_data()
                    if ex_data and 'exchange-rate' in ex_data:
                        ex_news = ex_data['exchange-rate']
                        ex_time = ex_news.get('time', 'ë°ì´í„° ì—†ìŒ')
                        ex_title = ex_news.get('title', '')
                        
                        # ì‹œê°„ í¬ë§·íŒ… (ì „ì²´ datetime í˜•ì‹ìœ¼ë¡œ)
                        if ex_time != 'ë°ì´í„° ì—†ìŒ' and len(ex_time) >= 6:
                            ex_date = ex_news.get('date', '')
                            if len(ex_date) == 8:  # YYYYMMDD
                                formatted_time = f"{ex_date[:4]}-{ex_date[4:6]}-{ex_date[6:8]} {ex_time[:2]}:{ex_time[2:4]}:{ex_time[4:6]}"
                            else:
                                formatted_time = ex_time
                        else:
                            formatted_time = "ë°ì´í„° ì—†ìŒ"
                        
                        # ì˜¤ëŠ˜ ë°œí–‰ ì—¬ë¶€ í™•ì¸
                        today = datetime.now().strftime('%Y%m%d')
                        ex_date = ex_news.get('date', '')
                        is_today = (ex_date == today)
                        
                        status_emoji = "ğŸŸ¢" if is_today else "ğŸ”´"
                        status_text = "ìµœì‹ " if is_today else "ë°ì´í„° ì—†ìŒ"
                        
                        status_lines.append("â”Œ  EXCHANGE RATE")
                        status_lines.append(f"â”œ ìƒíƒœ: {status_emoji} {status_text}")
                        status_lines.append(f"â”œ ì‹œê°„: {formatted_time}")
                        status_lines.append(f"â”” ì œëª©: {ex_title}")
                    else:
                        status_lines.append("â”Œ  EXCHANGE RATE")
                        status_lines.append("â”œ ìƒíƒœ: ğŸ”´ ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”” ì œëª©:")
                except Exception as e:
                    status_lines.append("â”Œ  EXCHANGE RATE")
                    status_lines.append("â”œ ìƒíƒœ: âŒ ì˜¤ë¥˜")
                    status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                    status_lines.append("â”” ì œëª©:")
            
            status_lines.append("")  # ë¹ˆ ì¤„
            
            # NEWYORK MARKET WATCH ìƒíƒœ
            if hasattr(self, 'newyork_monitor'):
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    if ny_data and 'newyork-market-watch' in ny_data:
                        ny_news = ny_data['newyork-market-watch']
                        ny_time = ny_news.get('time', 'ë°ì´í„° ì—†ìŒ')
                        ny_title = ny_news.get('title', '')
                        
                        # ì‹œê°„ í¬ë§·íŒ… (ì „ì²´ datetime í˜•ì‹ìœ¼ë¡œ)
                        if ny_time != 'ë°ì´í„° ì—†ìŒ' and len(ny_time) >= 6:
                            ny_date = ny_news.get('date', '')
                            if len(ny_date) == 8:  # YYYYMMDD
                                formatted_time = f"{ny_date[:4]}-{ny_date[4:6]}-{ny_date[6:8]} {ny_time[:2]}:{ny_time[2:4]}:{ny_time[4:6]}"
                            else:
                                formatted_time = ny_time
                        else:
                            formatted_time = "ë°ì´í„° ì—†ìŒ"
                        
                        # ì˜¤ëŠ˜ ë°œí–‰ ì—¬ë¶€ í™•ì¸
                        today = datetime.now().strftime('%Y%m%d')
                        ny_date = ny_news.get('date', '')
                        is_today = (ny_date == today)
                        
                        status_emoji = "ğŸŸ¢" if is_today else "ğŸ”´"
                        status_text = "ìµœì‹ " if is_today else "ë°ì´í„° ì—†ìŒ"
                        
                        status_lines.append("â”Œ  NEWYORK MARKET WATCH")
                        status_lines.append(f"â”œ ìƒíƒœ: {status_emoji} {status_text}")
                        status_lines.append(f"â”œ ì‹œê°„: {formatted_time}")
                        status_lines.append(f"â”” ì œëª©: {ny_title}")
                    else:
                        status_lines.append("â”Œ  NEWYORK MARKET WATCH")
                        status_lines.append("â”œ ìƒíƒœ: ğŸ”´ ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”” ì œëª©:")
                except Exception as e:
                    status_lines.append("â”Œ  NEWYORK MARKET WATCH")
                    status_lines.append("â”œ ìƒíƒœ: âŒ ì˜¤ë¥˜")
                    status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                    status_lines.append("â”” ì œëª©:")
            
            status_lines.append("")  # ë¹ˆ ì¤„
            
            # KOSPI CLOSE ìƒíƒœ
            if hasattr(self, 'kospi_monitor'):
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    if kospi_data and 'kospi-close' in kospi_data:
                        kospi_news = kospi_data['kospi-close']
                        kospi_time = kospi_news.get('time', 'ë°ì´í„° ì—†ìŒ')
                        kospi_title = kospi_news.get('title', '')
                        
                        # ì‹œê°„ í¬ë§·íŒ… (ì „ì²´ datetime í˜•ì‹ìœ¼ë¡œ)
                        if kospi_time != 'ë°ì´í„° ì—†ìŒ' and len(kospi_time) >= 6:
                            kospi_date = kospi_news.get('date', '')
                            if len(kospi_date) == 8:  # YYYYMMDD
                                formatted_time = f"{kospi_date[:4]}-{kospi_date[4:6]}-{kospi_date[6:8]} {kospi_time[:2]}:{kospi_time[2:4]}:{kospi_time[4:6]}"
                            else:
                                formatted_time = kospi_time
                        else:
                            formatted_time = "ë°ì´í„° ì—†ìŒ"
                        
                        # ì˜¤ëŠ˜ ë°œí–‰ ì—¬ë¶€ í™•ì¸
                        today = datetime.now().strftime('%Y%m%d')
                        kospi_date = kospi_news.get('date', '')
                        is_today = (kospi_date == today)
                        
                        status_emoji = "ğŸŸ¢" if is_today else "ğŸ”´"
                        status_text = "ìµœì‹ " if is_today else "ë°ì´í„° ì—†ìŒ"
                        
                        status_lines.append("â”Œ  KOSPI CLOSE")
                        status_lines.append(f"â”œ ìƒíƒœ: {status_emoji} {status_text}")
                        status_lines.append(f"â”œ ì‹œê°„: {formatted_time}")
                        status_lines.append(f"â”” ì œëª©: {kospi_title}")
                    else:
                        status_lines.append("â”Œ  KOSPI CLOSE")
                        status_lines.append("â”œ ìƒíƒœ: ğŸ”´ ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                        status_lines.append("â”” ì œëª©:")
                except Exception as e:
                    status_lines.append("â”Œ  KOSPI CLOSE")
                    status_lines.append("â”œ ìƒíƒœ: âŒ ì˜¤ë¥˜")
                    status_lines.append("â”œ ì‹œê°„: ë°ì´í„° ì—†ìŒ")
                    status_lines.append("â”” ì œëª©:")
            
            # ìµœì¢… í™•ì¸ ì‹œê°„ ì¶”ê°€
            status_lines.append("")
            status_lines.append(f"ìµœì¢… í™•ì¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            return "/n".join(status_lines)
            
        except Exception as e:
            return f"âŒ ë‰´ìŠ¤ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘ ì˜¤ë¥˜: {str(e)}"
    
    def load_previous_state(self):
        """ì´ì „ ìƒíƒœ ë¡œë“œ - StateManager ë° ModuleRegistry ì—°ë™"""
        try:
            previous_state = self.state_manager.load_state()
            
            # ì´ì „ ìƒíƒœì—ì„œ ë³µì› ê°€ëŠ¥í•œ ì •ë³´ë“¤
            if previous_state.get('last_status_notification_hour'):
                self.last_status_notification_hour = previous_state['last_status_notification_hour']
            
            # ì´ì „ ìŠ¤ì¼€ì¤„ ì‘ì—… ì •ë³´ ë³µì›
            if previous_state.get('last_scheduled_tasks'):
                self.last_scheduled_tasks = previous_state['last_scheduled_tasks']
            
            # ì˜¤ë¥˜ ì¹´ìš´íŠ¸ ë³µì›
            self.error_count = previous_state.get('error_count', 0)
            self.recovery_attempts = previous_state.get('recovery_attempts', 0)
            
            # ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ê°€ ìˆëŠ” ê²½ìš° ëª¨ë“ˆ ìƒíƒœ ë™ê¸°í™”
            if self.module_registry:
                try:
                    # ì´ì „ì— ì‹¤í–‰ ì¤‘ì´ë˜ í”„ë¡œì„¸ìŠ¤ ì •ë³´ ë³µì›
                    previous_processes = previous_state.get('running_processes', [])
                    for process_name in previous_processes:
                        if process_name in self.managed_processes:
                            # í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤ì œë¡œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
                            if self.process_manager.is_process_running(process_name):
                                self.log(f"ğŸ“‹ ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ë°œê²¬: {process_name}")
                            else:
                                self.log(f"âš ï¸ ì´ì „ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œë¨: {process_name}")
                    
                    self.log("ğŸ”„ ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒíƒœ ë™ê¸°í™” ì™„ë£Œ")
                except Exception as e:
                    self.log(f"âš ï¸ ëª¨ë“ˆ ìƒíƒœ ë™ê¸°í™” ì‹¤íŒ¨: {e}")
            
            self.log("ğŸ“‹ ì´ì „ ìƒíƒœ ë¡œë“œ ì™„ë£Œ")
            
        except Exception as e:
            self.log(f"âš ï¸ ì´ì „ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
            self.error_count = 0
            self.recovery_attempts = 0
    
    def is_monitor_running(self) -> bool:
        """
        ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹¤í–‰ ìƒíƒœ í™•ì¸
        
        Returns:
            bool: ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹¤í–‰ ì—¬ë¶€
        """
        try:
            # ProcessManagerë¥¼ í†µí•œ í—¬ìŠ¤ ì²´í¬
healthy_count,_total_count =  self.process_manager.perform_health_checks()
            
            # 50% ì´ìƒì˜ ëª¨ë‹ˆí„°ê°€ ì •ìƒì´ë©´ ì‹¤í–‰ ì¤‘ìœ¼ë¡œ ê°„ì£¼
return_healthy_count_> =  (total_count * 0.5)
            
        except Exception as e:
            self.log(f"âŒ ëª¨ë‹ˆí„° ì‹¤í–‰ ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    def run(self):
        """ì›Œì¹˜í–„ìŠ¤í„° ğŸ›¡ï¸ ë©”ì¸ ì‹¤í–‰ ë£¨í”„"""
        # ì»¬ëŸ¬í’€í•œ ì‹œì‘ ë°°ë„ˆ ì¶œë ¥ (UIê°€ ìˆëŠ” ê²½ìš°ë§Œ)
        if self.ui:
            self.ui.print_startup_banner()
        else:
            print("ğŸ¹ POSCO WatchHamster v3.0 ì‹œì‘")
        
        self.log("POSCO WatchHamster v3.0 ì‹œì‘")
        
        # v2 í†µí•© ìƒíƒœ ë¡œê·¸
        if self.v3_0_enabled:
            self.log("ğŸ‰ v2 ì•„í‚¤í…ì²˜ í™œì„±í™” - í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œë¡œ ë™ì‘")
        else:
            self.log(f"ğŸ“‹ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë™ì‘ - í´ë°± ì‚¬ìœ : {self.fallback_reason}")
        
        # ì‹œì‘ ì•Œë¦¼ ì „ì†¡ (v2 NotificationManager ìš°ì„  ì‚¬ìš©)
        if self.v3_0_enabled and self.v3_0_components['notification_manager']:
            # v2 ì‹œì‘ ì•Œë¦¼ì€ start_all_processesì—ì„œ ì „ì†¡ë¨
            pass
        else:
            # ê¸°ì¡´ ë°©ì‹ ì‹œì‘ ì•Œë¦¼
            self.send_notification(
                f"POSCO WatchHamster v3.0 ì‹œì‘/n/n"
                f"ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"ëª¨ë‹ˆí„°ë§ ê°„ê²©: {self.process_check_interval/60}ë¶„/n"
                f"ìƒíƒœ ì•Œë¦¼: {self.status_notification_interval_hours}ì‹œê°„ ê°„ê²©/n"
                f"ì•„í‚¤í…ì²˜: {'v2 í•˜ì´ë¸Œë¦¬ë“œ' if self.v3_0_enabled else 'ê¸°ì¡´ ë°©ì‹'}"
            )
        
        # ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ë¡œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        if self.ui:
            self.ui.print_info_message("ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...", "process")
        else:
            self.log("ğŸ”„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...")
        
        # v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•©
        if self.v3_0_enabled:
            self.log("ğŸ”„ v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•© ì¤‘...")
            integration_success = self.integrate_v2_process_lifecycle_management()
            if integration_success:
                self.log("âœ… v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•© ì™„ë£Œ")
            else:
                self.log("âš ï¸ v2 í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í†µí•© ë¶€ë¶„ ì‹¤íŒ¨")
        
        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        if self.start_all_processes():
            if self.ui:
                self.ui.print_success_message("ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì„±ê³µ")
                
                # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í‘œì‹œ
                if self.v3_0_enabled and self.v3_0_components['module_registry']:
                    system_status = self.get_all_process_status()
                    if self.ui and hasattr(self.ui, 'print_process_status'):
                        self.ui.print_process_status(system_status)
            else:
                self.log("âœ… ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì„±ê³µ")
        else:
            if self.ui:
                self.ui.print_warning_message("ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ë¶€ë¶„ ì´ˆê¸°í™”", "ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨")
            else:
                self.log("âš ï¸ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ë¶€ë¶„ ì´ˆê¸°í™” - ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨")
        
        try:
            while True:
                current_time = datetime.now()
                
                # v2 í†µí•© ì•„í‚¤í…ì²˜ í—¬ìŠ¤ì²´í¬ ë° 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ
                if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                    # v2 Enhanced ProcessManagerë¥¼ í†µí•œ ì¢…í•©ì  í—¬ìŠ¤ì²´í¬
                    health_results = self.v3_0_components['process_manager'].perform_health_check()
                    
                    healthy_count = sum(1 for is_healthy in health_results.values() if is_healthy)
                    total_count = len(health_results)
                    failed_processes = [name for name, is_healthy in health_results.items() if not is_healthy]
                    
                    # í—¬ìŠ¤ì²´í¬ ê²°ê³¼ ìƒì„¸ ë¡œê¹…
                    if total_count > 0:
                        health_percentage = (healthy_count / total_count) * 100
                        self.log(f"ğŸ” v2 í”„ë¡œì„¸ìŠ¤ í—¬ìŠ¤ì²´í¬ ì™„ë£Œ: {healthy_count}/{total_count} ì •ìƒ ({health_percentage:.1f}%)")
                        
                        if failed_processes:
                            self.log(f"âš ï¸ ë¬¸ì œ ê°ì§€ëœ í”„ë¡œì„¸ìŠ¤: {', '.join(failed_processes)}")
                    
                    # ëª¨ë“ˆ ìƒíƒœ ì¶”ì  ì—…ë°ì´íŠ¸
                    self._update_module_status_from_health_check(health_results)
                    
                    if healthy_count < total_count:
                        # í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ê°ì§€ - v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”
                        self.log(f"ğŸš¨ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ê°ì§€ - v2 3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ í™œì„±í™”")
                        
                        recovery_start_time = datetime.now()
                        recovery_results = {}
                        
                        # ì‹¤íŒ¨í•œ í”„ë¡œì„¸ìŠ¤ë“¤ì— ëŒ€í•´ v2 ìë™ ë³µêµ¬ ì‹œë„
                        for process_name in failed_processes:
                            self.log(f"ğŸ”§ {process_name} 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œì‘")
                            
                            # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì¡°íšŒ (ë³µêµ¬ ì „ ìƒíƒœ)
                            process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                            pre_recovery_restart_count = process_info.restart_count if process_info else 0
                            
                            # v2 ProcessManagerì˜ 3ë‹¨ê³„ ìë™ ë³µêµ¬ ì‹¤í–‰
                            recovery_success = self.handle_process_failure_v2(process_name)
                            
                            # ë³µêµ¬ ê²°ê³¼ ê¸°ë¡
                            post_recovery_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                            recovery_results[process_name] = {
                                'success': recovery_success,
                                'pre_restart_count': pre_recovery_restart_count,
                                'post_restart_count': post_recovery_info.restart_count if post_recovery_info else pre_recovery_restart_count,
                                'final_status': post_recovery_info.status.value if post_recovery_info else 'unknown'
                            }
                        
                        recovery_end_time = datetime.now()
                        total_recovery_time = (recovery_end_time - recovery_start_time).total_seconds()
                        
                        # ë³µêµ¬ ê²°ê³¼ ì¢…í•© ë¶„ì„
                        successful_recoveries = sum(1 for result in recovery_results.values() if result['success'])
                        failed_recoveries = len(recovery_results) - successful_recoveries
                        
                        self.log(f"ğŸ“Š v2 ë³µêµ¬ ì‹œìŠ¤í…œ ê²°ê³¼: ì„±ê³µ {successful_recoveries}ê°œ, ì‹¤íŒ¨ {failed_recoveries}ê°œ (ì†Œìš”ì‹œê°„: {total_recovery_time:.1f}ì´ˆ)")
                        
                        # ë³µêµ¬ ê²°ê³¼ë³„ ìƒì„¸ ë¡œê¹…
                        for process_name, result in recovery_results.items():
                            if result['success']:
                                self.log(f"âœ… {process_name}: ë³µêµ¬ ì„±ê³µ (ì¬ì‹œì‘ íšŸìˆ˜: {result['pre_restart_count']} â†’ {result['post_restart_count']})")
                            else:
                                self.log(f"âŒ {process_name}: ë³µêµ¬ ì‹¤íŒ¨ (ìµœì¢… ìƒíƒœ: {result['final_status']})")
                        
                        # ì „ì²´ ìƒíƒœ ë¶ˆëŸ‰ ì‹œ ì•Œë¦¼ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ ê³ ë ¤)
                        if not self.is_quiet_hours() or healthy_count == 0:
                            if self.v3_0_components['notification_manager']:
                                # v2 ì•Œë¦¼ ì‹œìŠ¤í…œ ì‚¬ìš© - ë³µêµ¬ ê²°ê³¼ í¬í•¨
                                system_status_obj = self._create_system_status_object_v2(current_time, health_results)
                                
                                # ë³µêµ¬ ì •ë³´ ì¶”ê°€
                                recovery_summary = {
                                    'total_failed': len(failed_processes),
                                    'recovery_attempted': len(recovery_results),
                                    'recovery_successful': successful_recoveries,
                                    'recovery_failed': failed_recoveries,
                                    'recovery_time': total_recovery_time,
                                    'recovery_details': recovery_results
                                }
                                
                                self.v3_0_components['notification_manager'].send_status_report(system_status_obj, recovery_summary)
                            else:
                                # ê¸°ì¡´ ì•Œë¦¼ ì‹œìŠ¤í…œ í´ë°±
                                recovery_status = f"ë³µêµ¬ ì‹œë„: {successful_recoveries}ì„±ê³µ/{failed_recoveries}ì‹¤íŒ¨"
                                self.send_notification(
                                    f"ğŸš¨ POSCO WatchHamster v3.0.0 í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ë¶ˆëŸ‰/n/n"
                                    f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                    f"ğŸ“Š ì •ìƒ í”„ë¡œì„¸ìŠ¤: {healthy_count}/{total_count}/n"
                                    f"âš ï¸ ë¬¸ì œ í”„ë¡œì„¸ìŠ¤: {', '.join(failed_processes)}/n"
                                    f"ğŸ”§ {recovery_status}/n"
                                    f"â±ï¸ ë³µêµ¬ ì†Œìš”ì‹œê°„: {total_recovery_time:.1f}ì´ˆ/n"
                                    f"ğŸ›¡ï¸ v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ ì‘ë™ë¨",
                                    is_error=True
                                )
                    else:
                        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì •ìƒ
                        if hasattr(self, 'last_health_warning') and self.last_health_warning:
                            # ì´ì „ì— ë¬¸ì œê°€ ìˆì—ˆë‹¤ë©´ ë³µêµ¬ ì™„ë£Œ ì•Œë¦¼
                            self.log("âœ… ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì •ìƒ ë³µêµ¬ ì™„ë£Œ - v2 ì‹œìŠ¤í…œ ì•ˆì •í™”ë¨")
                            
                            if self.v3_0_components['notification_manager']:
                                # v2 ë³µêµ¬ ì™„ë£Œ ì•Œë¦¼
                                system_status_obj = self._create_system_status_object_v2(current_time, health_results)
                                self.v3_0_components['notification_manager'].send_recovery_complete_notification(system_status_obj)
                            else:
                                # ê¸°ì¡´ ë°©ì‹ ë³µêµ¬ ì™„ë£Œ ì•Œë¦¼
                                self.send_notification(
                                    f"âœ… POSCO WatchHamster v3.0.0 ì‹œìŠ¤í…œ ë³µêµ¬ ì™„ë£Œ/n/n"
                                    f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                    f"ğŸ¯ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì •ìƒ ë™ì‘ ì¤‘ ({total_count}ê°œ)/n"
                                    f"ğŸ›¡ï¸ v2 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‘ë™í–ˆìŠµë‹ˆë‹¤."
                                )
                            
                            self.last_health_warning = False
                        
                    # í—¬ìŠ¤ì²´í¬ ê²°ê³¼ ê¸°ë¡ ë° í†µê³„ ì—…ë°ì´íŠ¸
                    self.last_health_warning = (healthy_count < total_count)
                    
                    # v2 ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                    if hasattr(self, 'v2_system_metrics'):
                        self.v2_system_metrics['last_health_check'] = current_time
                        self.v2_system_metrics['health_check_count'] = self.v2_system_metrics.get('health_check_count', 0) + 1
                        self.v2_system_metrics['healthy_processes'] = healthy_count
                        self.v2_system_metrics['total_processes'] = total_count
                    else:
                        self.v2_system_metrics = {
                            'last_health_check': current_time,
                            'health_check_count': 1,
                            'healthy_processes': healthy_count,
                            'total_processes': total_count
                        }
                else:
                    # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                    monitor_running = self.is_monitor_running()
                    if not monitor_running:
                        self.log("âš ï¸ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨ ê°ì§€, ì¬ì‹œì‘ ì‹œë„")
                        if self.start_monitor_process():
                            self.log("âœ… ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì„±ê³µ")
                        else:
                            self.log("âŒ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹¤íŒ¨")
                            self.send_notification(
                                f"POSCO ëª¨ë‹ˆí„° ì¬ì‹œì‘ ì‹¤íŒ¨/n/n"
                                f"ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                f"ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                                is_error=True
                            )

                
                # Git ì—…ë°ì´íŠ¸ ì²´í¬ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì œì™¸)
                if not self.is_quiet_hours() and (current_time - self.last_git_check).total_seconds() >= (self.git_check_interval):
                    self.log("ğŸ” Git ì—…ë°ì´íŠ¸ ì²´í¬ ì¤‘...")
                    if self.check_git_updates():
                        self.apply_git_update()
                    self.last_git_check = current_time
                
                # ìŠ¤ì¼€ì¤„ëœ ì‘ì—… ì²´í¬ ë° ì‹¤í–‰
                self.check_scheduled_tasks()
                
                # ì ˆëŒ€ì‹œê°„ ê¸°ì¤€ ì•Œë¦¼ ì‹œìŠ¤í…œ
                
                # 1. ì •ê¸° ìƒíƒœ ì•Œë¦¼ (ì¡°ìš©í•œ ì‹œê°„ëŒ€ ì œì™¸: 7, 9, 11, 13, 15, 17ì‹œë§Œ)
                if self.should_send_status_notification() and not self.is_quiet_hours():
                    self.send_status_notification()
                    self.last_status_notification_hour = current_time.hour
                
                # 2. ë§¤ì‹œê°„ ì •ê° ìƒíƒœ ì²´í¬ (0~23ì‹œ)
                if self.should_send_hourly_check():
                    if self.is_quiet_hours():
                        self.execute_scheduled_task("1", f"ì •ì‹œ ìƒíƒœ ì²´í¬ ({current_time.hour}ì‹œ) - ì¡°ìš©í•œ ëª¨ë“œ")
                    else:
                        self.execute_scheduled_task("1", f"ì •ì‹œ ìƒíƒœ ì²´í¬ ({current_time.hour}ì‹œ)")
                    self.last_hourly_check_hour = current_time.hour
                
                # 3. ê³ ì • ì‹œê°„ ì‘ì—…ë“¤ (06:00, 06:10, 18:00, 18:10, 18:20)
                self.check_fixed_time_tasks()
                
                # ë§ˆìŠ¤í„° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ (í•„ìš”ì‹œ)
                if self.master_monitor_enabled and hasattr(self, 'master_monitor'):
                    self._check_master_monitor_integration()
                
                # v2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™” ì²´í¬ (10ë¶„ë§ˆë‹¤)
                if (self.performance_monitor and 
                    hasattr(self, '_last_performance_check') and 
                    (current_time - self._last_performance_check).total_seconds() >= 600):
                    self._perform_performance_analysis()
                    self._last_performance_check = current_time
                elif self.performance_monitor and not hasattr(self, '_last_performance_check'):
                    self._last_performance_check = current_time
                
                # ìƒíƒœ ì €ì¥ (ë©”ëª¨ë¦¬ ìµœì í™”)
                self.save_status()
                
                # ë©”ëª¨ë¦¬ ì •ë¦¬ (ê°€ë¹„ì§€ ì»¬ë ‰ì…˜)
                import gc
                gc.collect()
                
                # ëŒ€ê¸° (CPU ì‚¬ìš©ë¥  ìµœì í™”)
                time.sleep(self.process_check_interval)
                
        except KeyboardInterrupt:
            self.log("ğŸ›‘ ì›Œì¹˜í–„ìŠ¤í„° ğŸ›¡ï¸ ì¤‘ë‹¨ ìš”ì²­ ë°›ìŒ")
            self.send_notification(
                f"POSCO WatchHamster v3.0 ì¤‘ë‹¨/n/n"
                f"ì¤‘ë‹¨ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
        except Exception as e:
            self.log(f"âŒ WatchHamster v3.0 ì˜¤ë¥˜: {e}")
            self.send_notification(
                f"POSCO WatchHamster v3.0 ì˜¤ë¥˜/n/n"
                f"ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"ì˜¤ë¥˜: {str(e)}",
                is_error=True
            )


    def send_startup_notification_v2(self):
        """
        v2 ì‹œì‘ ì•Œë¦¼ ì „ì†¡ - ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´í•˜ë©´ì„œ v2 ì»´í¬ë„ŒíŠ¸ ì •ë³´ í¬í•¨
        
        Requirements: 4.1, 4.2
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ì‹œì‘ ì•Œë¦¼ ì‚¬ìš©
                success = self.v2_components['notification_manager'].send_startup_notification(
                    self.managed_processes
                )
                if success:
                    self.log("âœ… v2 ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ì‹œì‘ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ì™„ì „ ë³´ì¡´)
            current_time = datetime.now()
            message = f"ğŸ¹ POSCO ì›Œì¹˜í–„ìŠ¤í„° ì‹œìŠ¤í…œ ì‹œì‘\n\n"
            message += f"ğŸ“… ì‹œì‘ ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"ğŸ›¡ï¸ ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤: {len(self.managed_processes)}ê°œ\n\n"
            
            message += f"ğŸ“Š ê´€ë¦¬ ì¤‘ì¸ ëª¨ë“ˆ:\n"
            for process in self.managed_processes:
                descriptions = {
                    'posco_main_notifier': 'ë©”ì¸ ë‰´ìŠ¤ ì•Œë¦¼',
                    'realtime_news_monitor': 'ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§',
                    'integrated_report_scheduler': 'ë¦¬í¬íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬',
                    'historical_data_collector': 'ë°ì´í„° ìˆ˜ì§‘ê¸°'
                }
                desc = descriptions.get(process, process)
                message += f"  âœ… {process} ({desc})\n"
            
            # v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ì¶”ê°€ (v2 í™œì„±í™” ì‹œì—ë§Œ)
            if self.v2_enabled:
                message += f"\nğŸ”§ v2 ì•„í‚¤í…ì²˜ ìƒíƒœ:\n"
                for component_name, component in self.v2_components.items():
                    status = "âœ… í™œì„±í™”" if component else "âŒ ë¹„í™œì„±í™”"
                    message += f"  â€¢ {component_name}: {status}\n"
            
            message += f"\nğŸ”„ ëª¨ë‹ˆí„°ë§ ì„¤ì •:\n"
            message += f"  â€¢ í—¬ìŠ¤ì²´í¬: 5ë¶„ ê°„ê²©\n"
            message += f"  â€¢ ìƒíƒœ ë³´ê³ : 2ì‹œê°„ ê°„ê²©\n"
            message += f"  â€¢ ìë™ ë³µêµ¬: í™œì„±í™”\n"
            message += f"  â€¢ Git ì—…ë°ì´íŠ¸: 60ë¶„ ê°„ê²©\n\n"
            message += f"ğŸš€ ì „ì²´ ì‹œìŠ¤í…œì´ ì •ìƒì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"âŒ ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    

    def send_status_report_v2(self):
        """
        v2 ì •ê¸° ìƒíƒœ ë³´ê³  - v2 ì»´í¬ë„ŒíŠ¸ ì •ë³´ë¥¼ í¬í•¨í•œ í–¥ìƒëœ ìƒíƒœ ë³´ê³ 
        
        Requirements: 4.2, 4.3
        """
        try:
            current_time = datetime.now()
            
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 ì‹œìŠ¤í…œ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘
                system_status = self._collect_v2_system_status()
                
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ìƒíƒœ ë³´ê³  ì‚¬ìš©
                success = self.v2_components['notification_manager'].send_status_report(system_status)
                if success:
                    self.log("âœ… v2 ìƒíƒœ ë³´ê³  ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ìƒíƒœ ë³´ê³  ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´í•˜ë©´ì„œ v2 ì •ë³´ ì¶”ê°€)
            message = f"ğŸ“Š POSCO ì›Œì¹˜í–„ìŠ¤í„° ì •ê¸° ìƒíƒœ ë³´ê³ \n\n"
            message += f"ğŸ“… ë³´ê³  ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            
            # ê°€ë™ ì‹œê°„ ê³„ì‚°
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
                hours, remainder = divmod(int(uptime.total_seconds()), 3600)
                minutes, _ = divmod(remainder, 60)
                message += f"â±ï¸ ê°€ë™ ì‹œê°„: {hours}ì‹œê°„ {minutes}ë¶„\n\n"
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ í™•ì¸
            running_processes = []
            failed_processes = []
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    running_processes.append(process_name)
                else:
                    failed_processes.append(process_name)
            
            # í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ë³´ê³ 
            if not failed_processes:
                message += f"ğŸŸ¢ ì •ìƒ í”„ë¡œì„¸ìŠ¤ ({len(running_processes)}/{len(self.managed_processes)}):\n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  âœ… {process} - ì •ìƒ (PID: {pid})\n"
            else:
                message += f"ğŸŸ¢ ì •ìƒ í”„ë¡œì„¸ìŠ¤ ({len(running_processes)}/{len(self.managed_processes)}):\n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  âœ… {process} - ì •ìƒ (PID: {pid})\n"
                
                message += f"\nğŸŸ¡ ë¬¸ì œ í”„ë¡œì„¸ìŠ¤ ({len(failed_processes)}/{len(self.managed_processes)}):\n"
                for process in failed_processes:
                    message += f"  âŒ {process} - ì¤‘ì§€ë¨\n"
            
            # v2 ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ì¶”ê°€
            if self.v2_enabled:
                message += f"\nğŸ”§ v2 ì•„í‚¤í…ì²˜ ìƒíƒœ:\n"
                for component_name, component in self.v2_components.items():
                    if component:
                        # ì»´í¬ë„ŒíŠ¸ë³„ ìƒíƒœ ì •ë³´
                        if component_name == 'notification_manager':
                            stats = component.get_notification_stats()
                            message += f"  âœ… {component_name}: í™œì„±í™” (ì•Œë¦¼: {stats.get('total_notifications', 0)}íšŒ)\n"
                        elif component_name == 'module_registry':
                            modules = component.list_modules()
                            message += f"  âœ… {component_name}: í™œì„±í™” (ëª¨ë“ˆ: {len(modules)}ê°œ)\n"
                        else:
                            message += f"  âœ… {component_name}: í™œì„±í™”\n"
                    else:
                        message += f"  âŒ {component_name}: ë¹„í™œì„±í™”\n"
            
            # ì‹œìŠ¤í…œ ì„±ëŠ¥ ì •ë³´
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_percent = psutil.virtual_memory().percent
                disk_percent = psutil.disk_usage('/').percent
                
                message += f"\nğŸ“ˆ ì‹œìŠ¤í…œ ì„±ëŠ¥:\n"
                message += f"  â€¢ CPU ì‚¬ìš©ë¥ : {cpu_percent:.0f}%\n"
                message += f"  â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {memory_percent:.0f}%\n"
                message += f"  â€¢ ë””ìŠ¤í¬ ì‚¬ìš©ë¥ : {disk_percent:.0f}%\n"
            except ImportError:
                message += f"\nğŸ“ˆ ì‹œìŠ¤í…œ ì„±ëŠ¥: ì •ë³´ ìˆ˜ì§‘ ë¶ˆê°€ (psutil í•„ìš”)\n"
            
            # ë‹¤ìŒ ë³´ê³  ì‹œê°„
            next_report_time = current_time + timedelta(hours=self.status_notification_interval_hours)
            message += f"\nğŸ”„ ë‹¤ìŒ ìƒíƒœ ë³´ê³ : {next_report_time.strftime('%H:%M')}"
            
            # ìƒ‰ìƒ ê²°ì • (ë¬¸ì œê°€ ìˆìœ¼ë©´ ì£¼í™©ìƒ‰, ì—†ìœ¼ë©´ ë…¹ìƒ‰)
            is_error = len(failed_processes) > 0
            self.send_notification(message, is_error)
            
        except Exception as e:
            self.log(f"âŒ ìƒíƒœ ë³´ê³  ì „ì†¡ ì˜¤ë¥˜: {e}")
    


    def send_critical_alert_v2(self, alert_message, additional_info=None):
        """
        v2 ê¸´ê¸‰ ì•Œë¦¼ - êµ¬ì¡°í™”ëœ ê¸´ê¸‰ ìƒí™© ì•Œë¦¼
        
        Requirements: 4.4
        
        Args:
            alert_message (str): ê¸´ê¸‰ ì•Œë¦¼ ë©”ì‹œì§€
            additional_info (dict): ì¶”ê°€ ì •ë³´
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ê¸´ê¸‰ ì•Œë¦¼ ì‚¬ìš©
                success = self.v2_components['notification_manager'].send_critical_alert(
                    alert_message, additional_info or {}
                )
                if success:
                    self.log("âœ… v2 ê¸´ê¸‰ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
                    return
                else:
                    self.log("âš ï¸ v2 ê¸´ê¸‰ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
            current_time = datetime.now()
            message = f"ğŸš¨ POSCO ì›Œì¹˜í–„ìŠ¤í„° ê¸´ê¸‰ ì•Œë¦¼\n\n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"ğŸš¨ ê¸´ê¸‰ ìƒí™©: {alert_message}\n\n"
            
            if additional_info:
                message += f"ğŸ“‹ ì¶”ê°€ ì •ë³´:\n"
                for key, value in additional_info.items():
                    message += f"  â€¢ {key}: {value}\n"
                message += "\n"
            
            message += f"ğŸ”§ ì¦‰ì‹œ ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"âŒ ê¸´ê¸‰ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    


    def send_recovery_success_v2(self, process_name, recovery_details):
        """
        v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ - ë³µêµ¬ ë‹¨ê³„ì™€ ìƒì„¸ ì •ë³´ í¬í•¨
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            recovery_details (dict): ë³µêµ¬ ìƒì„¸ ì •ë³´
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ë³µêµ¬ ì•Œë¦¼ ì‚¬ìš©
                success = self.v2_components['notification_manager'].send_recovery_success(
                    process_name, recovery_details
                )
                if success:
                    self.log(f"âœ… v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ: {process_name}")
                    return
                else:
                    self.log("âš ï¸ v2 ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´)
            current_time = datetime.now()
            message = f"âœ… POSCO ì›Œì¹˜í–„ìŠ¤í„° í”„ë¡œì„¸ìŠ¤ ë³µêµ¬ ì™„ë£Œ\n\n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"ğŸ”§ ë³µêµ¬ëœ í”„ë¡œì„¸ìŠ¤: {process_name}\n\n"
            
            # ë³µêµ¬ ì •ë³´
            recovery_stage = recovery_details.get('recovery_stage', 'ì•Œ ìˆ˜ ì—†ìŒ')
            recovery_time = recovery_details.get('recovery_time', 0)
            
            message += f"ğŸ”„ ë³µêµ¬ ë‹¨ê³„: {recovery_stage}\n"
            if recovery_time > 0:
                message += f"â±ï¸ ë³µêµ¬ ì†Œìš” ì‹œê°„: {recovery_time}ì´ˆ\n"
            
            # ìƒˆ í”„ë¡œì„¸ìŠ¤ ì •ë³´
            new_pid = recovery_details.get('new_pid')
            if new_pid:
                message += f"ğŸ†” ìƒˆ í”„ë¡œì„¸ìŠ¤ ID: {new_pid}\n"
            
            message += f"\nğŸš€ í”„ë¡œì„¸ìŠ¤ê°€ ì •ìƒì ìœ¼ë¡œ ë³µêµ¬ë˜ì–´ ëª¨ë‹ˆí„°ë§ì„ ì¬ê°œí•©ë‹ˆë‹¤."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"âŒ ë³µêµ¬ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    


    def send_process_error_v2(self, process_name, error_details):
        """
        v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ - êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ ì •ë³´ í¬í•¨
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            error_details (dict): ì˜¤ë¥˜ ìƒì„¸ ì •ë³´
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManagerì˜ êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ ì•Œë¦¼ ì‚¬ìš©
                success = self.v2_components['notification_manager'].send_process_error(
                    process_name, error_details
                )
                if success:
                    self.log(f"âœ… v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ: {process_name}")
                    return
                else:
                    self.log("âš ï¸ v2 í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±")
            
            # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ê¸°ì¡´ í…ìŠ¤íŠ¸ ë³´ì¡´)
            current_time = datetime.now()
            message = f"âŒ POSCO ì›Œì¹˜í–„ìŠ¤í„° í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜\n\n"
            message += f"ğŸ“… ì‹œê°„: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"ğŸ”§ ë¬¸ì œ í”„ë¡œì„¸ìŠ¤: {process_name}\n\n"
            
            # ì˜¤ë¥˜ ì •ë³´
            error_msg = error_details.get('error_message', 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜')
            message += f"âŒ ì˜¤ë¥˜ ë‚´ìš©: {error_msg}\n"
            
            # ì¬ì‹œì‘ ì‹œë„ ì •ë³´
            restart_count = error_details.get('restart_count', 0)
            max_attempts = error_details.get('max_attempts', 3)
            
            if restart_count > 0:
                message += f"ğŸ”„ ì¬ì‹œì‘ ì‹œë„: {restart_count}/{max_attempts}íšŒ\n"
            
            # ìë™ ë³µêµ¬ ìƒíƒœ
            auto_recovery = error_details.get('auto_recovery_enabled', True)
            if auto_recovery and restart_count < max_attempts:
                message += f"\nğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘..."
            elif restart_count >= max_attempts:
                message += f"\nğŸš¨ ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ ì´ˆê³¼ - ìˆ˜ë™ ê°œì… í•„ìš”"
            else:
                message += f"\nâš ï¸ ìë™ ë³µêµ¬ ë¹„í™œì„±í™” - ìˆ˜ë™ í™•ì¸ í•„ìš”"
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"âŒ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    

if __name__ == "__main__":
    # Windows í™˜ê²½ì—ì„œ UTF-8 ì¶œë ¥ ì„¤ì • ê°œì„ 
    if sys.platform == "win32":
        import codecs
        import locale
        
        # ì½˜ì†” ì½”ë“œí˜ì´ì§€ë¥¼ UTF-8ë¡œ ì„¤ì •
        try:
            import subprocess
subprocess.run(['chcp',_'65001'],_shell = True, capture_output=True)
        except:
            pass
        
        # í‘œì¤€ ì¶œë ¥/ì˜¤ë¥˜ë¥¼ UTF-8ë¡œ ì„¤ì •
        try:
            sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
            sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())
        except:
            # ì´ë¯¸ ì„¤ì •ëœ ê²½ìš° ë¬´ì‹œ
            pass
        
        # í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
        os.environ['PYTHONIOENCODING'] = 'utf-8'
    
    watchhamster = WatchHamster v3.00Monitor()
    watchhamster.run()
    watchhamster.run()