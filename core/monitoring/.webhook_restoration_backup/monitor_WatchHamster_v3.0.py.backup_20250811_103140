#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Monitor Watchhamster V3.0
POSCO 모니터링 시스템

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import subprocess
import os
import sys
import json
import requests
from datetime import datetime, timedelta
import psutil

# 출력 버퍼링 해제 - 실시간 로그 출력을 위해
sys.stdout.reconfigure(line_buffering=True)
sys.stderr.reconfigure(line_buffering=True)

# 환경 변수로도 출력 버퍼링 비활성화
os.environ['PYTHONUNBUFFERED'] = '1'

# 현재 스크립트 디렉토리를 Python 경로에 추가
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

try:
    from config import API_CONFIG, DOORAY_WEBHOOK_URL, BOT_PROFILE_IMAGE_URL
    print("[INFO] Configuration loaded successfully")
except ImportError as e:
    print(f"[WARNING] Configuration import failed: {e}")
    # 기본 설정 사용
    API_CONFIG = {}
    DOORAY_WEBHOOK_URL = "https://infomax.dooray.com/services/3262462484277387103/4121380745073081229/5FbudzTwTki4wCeBszBrAg"
    BOT_PROFILE_IMAGE_URL = "https://raw.githubusercontent.com/shuserker/infomax_api/main/Monitoring/POSCO_News_250808/posco_logo_mini.jpg"

# 핵심 모듈들 import 시도
try:
    from core.process_manager import ProcessManager
except ImportError:
    ProcessManager = None
    print("[WARNING] ProcessManager not available")

try:
    from core.state_manager import StateManager
except ImportError:
    StateManager = None
    print("[WARNING] StateManager not available")

try:
    from core.colorful_ui import ColorfulConsoleUI
except ImportError:
    ColorfulConsoleUI = None
    print("[WARNING] ColorfulConsoleUI not available")

# 추가 모니터링 모듈들
try:
    from backup_archive_20250806.disabled_monitors_20250803.newyork_monitor import NewYorkMarketMonitor
except ImportError:
    NewYorkMarketMonitor = None
    print("[INFO] NewYorkMarketMonitor 비활성화됨 - 통합 리포트 시스템 사용")

try:
    from backup_archive_20250806.disabled_monitors_20250803.kospi_monitor import KospiCloseMonitor
except ImportError:
    KospiCloseMonitor = None
    print("[INFO] KospiCloseMonitor 비활성화됨")
    
try:
    from backup_archive_20250806.disabled_monitors_20250803.exchange_monitor import ExchangeRateMonitor
except ImportError:
    ExchangeRateMonitor = None
    print("[INFO] ExchangeRateMonitor 비활성화됨")

try:
    from backup_archive_20250806.disabled_monitors_20250803.master_news_monitor import MasterNewsMonitor
except ImportError:
    MasterNewsMonitor = None
    print("[INFO] MasterNewsMonitor 비활성화됨")

# 기본 설정 완료
print("[INFO] 모든 모듈 import 완료 - 기본 기능으로 동작합니다.")

class WatchHamsterV3Monitor:
    """
    POSCO WatchHamster v3.0 🛡️ 클래스
    
    모니터링 프로세스의 안정성을 보장하는 자동 복구 시스템입니다.
    
    주요 기능:
    - 모니터링 프로세스 상태 감시 (5분 간격)
    - 자동 Git 업데이트 체크 (1시간 간격)
    - 프로세스 오류 시 자동 재시작
    - Dooray를 통한 상태 알림 전송
    - 로그 파일 관리 및 상태 저장
    
    Attributes:
        script_dir (str): 스크립트 디렉토리 경로
        monitor_script (str): 모니터링 스크립트 경로
        log_file (str): 로그 파일 경로
        status_file (str): 상태 파일 경로
        monitor_process (subprocess.Popen): 모니터링 프로세스 객체
        last_git_check (datetime): 마지막 Git 체크 시간
        git_check_interval (int): Git 체크 간격 (초)
        process_check_interval (int): 프로세스 체크 간격 (초)
    """
    
    def __init__(self):
        """
        WatchHamster v3.0.0 통합 레이어 구현
        
        v2 컴포넌트들을 안전하게 로드하고, 실패 시 기존 방식으로 폴백하는 하이브리드 아키텍처
        """
        self.script_dir = current_dir
        self.log_file = os.path.join(self.script_dir, ".naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster.log")
        self.status_file = os.path.join(self.script_dir, ".naming_backup/config_data_backup/.naming_backup/config_data_backup/Monitoring/Posco_News_mini/WatchHamster_status.json")
        
        # 시작 시간 기록 (가동 시간 계산용)
        self.start_time = datetime.now()
        
        # 기존 프로세스 객체들 (호환성 유지)
        self.monitor_process = None
        self.realtime_process = None
        self.last_git_check = datetime.now() - timedelta(hours=1)  # 초기 체크 강제
        
        # v2 통합 상태 추적
        self.v3_0_enabled = False
        self.v3_0_components = {
            'process_manager': None,
            'module_registry': None,
            'notification_manager': None
        }
        self.fallback_reason = None
        
        # v2 컴포넌트 초기화 시도
        self._initialize_v3_0_components()
        
        # 관리 대상 프로세스 목록 설정
        if self.v3_0_enabled and self.v3_0_components['module_registry']:
            # v2 방식: 모듈 레지스트리에서 자동 로드
            self.managed_processes = self.v3_0_components['module_registry'].get_startup_order()
            self.log(f"📋 v2 모듈 레지스트리에서 관리 대상 프로세스 로드: {len(self.managed_processes)}개")
            for process_name in self.managed_processes:
                self.log(f"  • {process_name}")
            
            # 모듈 상태 추적 초기화
            self._initialize_module_status_tracking()
        else:
            # 기존 방식: 하드코딩된 프로세스 목록
            self.managed_processes = ['POSCO News 250808_monitor', 'integrated_report_scheduler']
            self.log(f"📋 기존 방식으로 관리 대상 프로세스 설정: {len(self.managed_processes)}개")
        
        # StateManager 초기화 (안정성 개선)
        if StateManager:
            self.state_manager = StateManager(self.status_file)
        else:
            self.state_manager = None
            self.log("⚠️ StateManager를 사용할 수 없습니다. 기본 상태 관리를 사용합니다.")
        
        # ColorfulConsoleUI 초기화 (컬러풀한 UI)
        if ColorfulConsoleUI:
            self.ui = ColorfulConsoleUI()
        else:
            self.ui = None
        
        # 이전 상태 로드
        self.load_previous_state()
        
        # 절대시간 기준 알림 설정
        self.status_notification_start_hour = 7  # 시작 시간 (7시)
        self.status_notification_interval_hours = 2  # 간격 (2시간)
        self.last_status_notification_hour = None  # 마지막 알림 시간 (시간만 저장)
        self.last_status_notification = None  # 기존 호환성을 위해 유지
        self.last_hourly_check_hour = None  # 마지막 매시간 체크 시간
        
        # 워치햄스터는 순수 시스템 관리만 담당 - 뉴스 관련 기능 제거
        # 뉴스 관련 기능은 realtime_news_monitor.py와 integrated_report_scheduler.py에서 처리
        self.fixed_time_tasks = {}  # 뉴스 관련 고정 작업 제거
        self.executed_fixed_tasks = set()  # 호환성을 위해 유지
        
        self.git_check_interval = 60 * 60 * 4  # 4시간마다 Git 체크
        self.process_check_interval = 5 * 60  # 5분마다 프로세스 체크 (뉴스 발행 간격 고려)
        
        # 스케줄 작업 추적
        self.last_scheduled_tasks = {
            'morning_status_check': None,
            'morning_comparison': None,
            'evening_daily_summary': None,
            'evening_detailed_summary': None,
            'evening_advanced_analysis': None,
            'hourly_status_check': None,
            'integrated_report_generation': None,
            'integrated_report_notification': None
        }
        
        # 스마트 상태 판단 시스템 초기화
        try:
            self.api_client = POSCONews250808APIClient(API_CONFIG)
            self.data_processor = NewsDataProcessor()
            self.smart_notifier = DoorayNotifier(DOORAY_WEBHOOK_URL, BOT_PROFILE_IMAGE_URL, self.api_client)
            self.smart_enabled = True
            self.log("🧠 스마트 상태 판단 시스템 초기화 완료")
        except Exception as e:
            self.log(f"⚠️ 스마트 상태 판단 시스템 초기화 실패: {e}")
            self.smart_enabled = False
        
        # 개별 모니터링 시스템 비활성화 (통합 리포트로 전환)
        self.individual_monitors_enabled = False
        self.log("🔄 개별 모니터링 비활성화 - 통합 리포트 시스템으로 전환됨")
        
        # 통합 리포트 스케줄러 초기화
        try:
            pass  # REMOVED
            self.integrated_scheduler = IntegratedReportScheduler()
            self.integrated_scheduler_enabled = True
            self.log("📊 통합 리포트 스케줄러 초기화 완료")
        except Exception as e:
            self.log(f"⚠️ 통합 리포트 스케줄러 초기화 실패: {e}")
            self.integrated_scheduler_enabled = False
        
        # 마스터 모니터링 시스템 초기화
        try:
            if MasterNewsMonitor:
                self.master_monitor = MasterNewsMonitor()
                self.master_monitor_enabled = True
                self.log("🎛️ 마스터 모니터링 시스템 연결 완료")
            else:
                self.master_monitor_enabled = False
                self.log("⚠️ 마스터 모니터링 시스템 비활성화 (모듈 없음)")
        except Exception as e:
            self.log(f"⚠️ 마스터 모니터링 시스템 초기화 실패: {e}")
            self.master_monitor_enabled = False
        
        # v2 성능 모니터링 시스템 초기화
        self.performance_monitor = None
        self.performance_optimizer = None
        self.performance_comparator = None
        self._initialize_performance_monitoring()
    
    def _initialize_v3_0_components(self):
        """
        v2 컴포넌트 초기화 시스템 - 동적 import test_performance_monitoring/POSCO_News_250808/📋POSCO_시스템_정리_및_검증_완료_20250806.md 상태 검증
        
        v2 컴포넌트들을 동적으로 로드하고 초기화합니다.
        실패 시 기존 방식으로 안전하게 폴백하는 하이브리드 아키텍처를 구현합니다.
        
        구현 내용:
                        # REMOVED: 원본 코드
        - 컴포넌트별 상태 체크 및 검증 시스템
        - 안전한 폴백 메커니즘
        """
        initialization_start = datetime.now()
        
        try:
            self.log("🔧 v2 아키텍처 컴포넌트 초기화 시작...")
            
            # 1. v2 경로 검증 및 설정
            v2_path = self._setup_v2_paths()
            
            # 2. v2 컴포넌트 동적 import test_performance_monitoring/POSCO_News_250808/📋POSCO_시스템_정리_및_검증_완료_20250806.md 초기화
            self._load_v3_0_components(v2_path)
            
            # 3. 컴포넌트 상태 검증
            self._validate_v3_0_components()
            
            # 4. v2 통합 성공 처리
            self.v3_0_enabled = True
            initialization_time = (datetime.now() - initialization_start).total_seconds()
            
            self.log(f"🎉 v2 아키텍처 활성화 성공! (초기화 시간: {initialization_time:.2f}초)")
            self.log("🔄 하이브리드 모드로 동작합니다 - v2 기능 우선, 실패 시 v1 폴백")
            
            # 초기화 성공 통계 기록
            self._record_initialization_success(initialization_time)
            
        except Exception as e:
            # v2 초기화 실패 - 안전한 폴백 처리
            self._handle_v2_initialization_failure(e, initialization_start)
    
    def _setup_v2_paths(self):
        """
        v2 경로 설정 및 검증
        
        Returns:
            str: v2 디렉토리 경로
            
        Raises:
            FileNotFoundError: 필수 파일/디렉토리가 없는 경우
        """
        # v2 디렉토리 경로 설정
        v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
        
        # 필수 경로 검증
        required_paths = {
            'v2_directory': v2_path,
            'core_directory': os.path.join(v2_path, 'core'),
            'modules_config': os.path.join(v2_path, 'modules.json')
        }
        
        for path_name, path in required_paths.items():
            if not os.path.exists(path):
                raise FileNotFoundError(f"{path_name}을 찾을 수 없습니다: {path}")
        
        # v2 core 모듈 파일 검증
        core_modules = [
            'Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py',
            'Monitoring/WatchHamster_v3.0/core/module_registry.py', 
            'Monitoring/WatchHamster_v3.0/core/notification_manager.py'
        ]
        
        for module_file in core_modules:
            module_path = os.path.join(required_paths['core_directory'], module_file)
            if not os.path.exists(module_path):
                raise FileNotFoundError(f"v2 핵심 모듈을 찾을 수 없습니다: {module_path}")
        
        self.log(f"✅ v2 경로 검증 완료: {v2_path}")
        
        # Python 경로에 v2 디렉토리 추가
        if v2_path not in sys.path:
            sys.path.insert(0, v2_path)
            self.log(f"📁 Python 경로에 v2 디렉토리 추가: {v2_path}")
        
        return v2_path
    
    def _load_v3_0_components(self, v2_path):
        """
        v2 컴포넌트 동적 import test_performance_monitoring/POSCO_News_250808/📋POSCO_시스템_정리_및_검증_완료_20250806.md 초기화
        
        Args:
            v2_path (str): v2 디렉토리 경로
        """
        # 1. Enhanced ProcessManager 동적 로드
        try:
            self.log("🔧 Enhanced ProcessManager 로드 중...")
            
            # importlib를 사용한 동적 import
            import importlib.util
            
            # 모듈 파일 경로
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/enhanced_process_manager.py')
            
            # 모듈 스펙 생성
            spec = importlib.util.spec_from_file_location("enhanced_process_manager", module_path)
            if spec is None:
                raise ImportError(f"모듈 스펙 생성 실패: {module_path}")
            
            # 모듈 로드
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # ProcessManager 클래스 추출
            EnhancedProcessManager = getattr(module, 'ProcessManager')
            
            self.v3_0_components['process_manager'] = EnhancedProcessManager(self.script_dir)
            self.log("✅ Enhanced ProcessManager 초기화 완료")
            
        except ImportError as e:
            # REMOVED: raise ImportError(f"Enhanced ProcessManager import 실패: {e}")
            pass
        except Exception as e:
            raise Exception(f"Enhanced ProcessManager 초기화 실패: {e}")
        
        # 2. ModuleRegistry 동적 로드
        try:
            self.log("🔧 ModuleRegistry 로드 중...")
            
            # importlib를 사용한 동적 import
            import importlib.util
            
            # 모듈 파일 경로
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
            
            # 모듈 스펙 생성
            spec = importlib.util.spec_from_file_location("module_registry", module_path)
            if spec is None:
                raise ImportError(f"모듈 스펙 생성 실패: {module_path}")
            
            # 모듈 로드
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # ModuleRegistry 클래스 추출
            ModuleRegistry = getattr(module, 'ModuleRegistry')
            
            # 메인 시스템의 modules.json 사용 (현재 디렉토리)
            modules_json_path = os.path.join(self.script_dir, 'modules.json')
            self.v3_0_components['module_registry'] = ModuleRegistry(modules_json_path)
            self.log("✅ ModuleRegistry 초기화 완료")
            
        except ImportError as e:
            pass  # REMOVED
        except Exception as e:
            raise Exception(f"ModuleRegistry 초기화 실패: {e}")
        
        # 3. NotificationManager 동적 로드
        try:
            self.log("🔧 NotificationManager 로드 중...")
            
            # importlib를 사용한 동적 import
            import importlib.util
            
            # 모듈 파일 경로
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/notification_manager.py')
            
            # 모듈 스펙 생성
            spec = importlib.util.spec_from_file_location("notification_manager", module_path)
            if spec is None:
                raise ImportError(f"모듈 스펙 생성 실패: {module_path}")
            
            # 모듈 로드
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # NotificationManager 클래스 추출
            NotificationManager = getattr(module, 'NotificationManager')
            
            self.v3_0_components['notification_manager'] = NotificationManager(
                DOORAY_WEBHOOK_URL, 
                BOT_PROFILE_IMAGE_URL
            )
            self.log("✅ NotificationManager 초기화 완료")
            
        except ImportError as e:
            pass  # REMOVED
        except Exception as e:
            raise Exception(f"NotificationManager 초기화 실패: {e}")
    
    def _validate_v3_0_components(self):
        """
        v2 컴포넌트 상태 검증 시스템
        
        초기화된 v2 컴포넌트들이 올바르게 동작하는지 검증합니다.
        각 컴포넌트별로 기본 기능을 테스트하여 상태를 확인합니다.
        """
        validation_results = {}
        
        try:
            self.log("🔍 v2 컴포넌트 상태 검증 시작...")
            
            # 1. Enhanced ProcessManager 검증
            if self.v3_0_components['process_manager']:
                try:
                    # 시스템 상태 조회 테스트
                    status = self.v3_0_components['process_manager'].get_system_status()
                    
                    if isinstance(status, dict) and 'timestamp' in status:
                        validation_results['process_manager'] = {
                            'status': 'valid',
                            'details': f"시스템 상태 조회 성공, 프로세스 수: {len(status.get('process_details', {}))}"
                        }
                        self.log("✅ Enhanced ProcessManager 상태 검증 완료")
                    else:
                        raise ValueError("ProcessManager 상태 조회 결과가 올바르지 않습니다")
                        
                except Exception as e:
                    validation_results['process_manager'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"❌ Enhanced ProcessManager 검증 실패: {e}")
            
            # 2. ModuleRegistry 검증
            if self.v3_0_components['module_registry']:
                try:
                    # 모듈 목록 조회 테스트
                    modules = self.v3_0_components['module_registry'].list_modules()
                    startup_order = self.v3_0_components['module_registry'].get_startup_order()
                    
                    if isinstance(modules, dict) and isinstance(startup_order, list):
                        validation_results['module_registry'] = {
                            'status': 'valid',
                            'details': f"모듈 {len(modules)}개 등록됨, 시작 순서 {len(startup_order)}개"
                        }
                        self.log(f"✅ ModuleRegistry 검증 완료 ({len(modules)}개 모듈)")
                        
                        # 등록된 모듈 목록 로그
                        for module_name in modules.keys():
                            self.log(f"  📋 등록된 모듈: {module_name}")
                    else:
                        raise ValueError("ModuleRegistry 모듈 목록 조회 결과가 올바르지 않습니다")
                        
                except Exception as e:
                    validation_results['module_registry'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"❌ ModuleRegistry 검증 실패: {e}")
            
            # 3. NotificationManager 검증
            if self.v3_0_components['notification_manager']:
                try:
                    # 알림 통계 조회 테스트
                    stats = self.v3_0_components['notification_manager'].get_notification_stats()
                    
                    if isinstance(stats, dict) and 'total_notifications' in stats:
                        validation_results['notification_manager'] = {
                            'status': 'valid',
                            'details': f"알림 통계 조회 성공, 총 알림: {stats.get('total_notifications', 0)}"
                        }
                        self.log("✅ NotificationManager 검증 완료")
                    else:
                        raise ValueError("NotificationManager 통계 조회 결과가 올바르지 않습니다")
                        
                except Exception as e:
                    validation_results['notification_manager'] = {
                        'status': 'invalid',
                        'error': str(e)
                    }
                    self.log(f"❌ NotificationManager 검증 실패: {e}")
            
            # 검증 결과 요약
            valid_components = sum(1 for result in validation_results.values() if result['status'] == 'valid')
            total_components = len(validation_results)
            
            if valid_components == total_components:
                self.log(f"🔍 모든 v2 컴포넌트 검증 완료 ({valid_components}/{total_components})")
            else:
                self.log(f"⚠️ 일부 v2 컴포넌트 검증 실패 ({valid_components}/{total_components})")
                
                # 실패한 컴포넌트 상세 로그
                for component, result in validation_results.items():
                    if result['status'] == 'invalid':
                        self.log(f"  ❌ {component}: {result['error']}")
            
            # 검증 결과를 인스턴스 변수에 저장
            self.v2_validation_results = validation_results
            self.log(f"📋 검증 결과 저장 완료: {len(validation_results)}개 컴포넌트")
            
        except Exception as e:
            self.log(f"❌ v2 컴포넌트 검증 중 예외 발생: {e}")
            # 예외 발생 시에도 빈 결과라도 저장
            self.v2_validation_results = {}
            import traceback
            self.log(f"❌ 검증 예외 상세: {traceback.format_exc()}")
            # 검증 실패해도 v2_enabled는 유지 (기본 기능은 동작할 수 있음)
    
    def _initialize_performance_monitoring(self):
        """
        v2 성능 모니터링 시스템 초기화
        
        성능 모니터링, 최적화, 비교 시스템을 초기화합니다.
        v2 컴포넌트가 활성화된 경우에만 동작합니다.
        
        Requirements: 7.1, 7.2, 7.3, 7.4
        """
        try:
            if not self.v3_0_enabled:
                self.log("⚠️ v2 아키텍처가 비활성화되어 성능 모니터링을 건너뜁니다")
                return
            
            self.log("📊 v2 성능 모니터링 시스템 초기화 시작...")
            
            # v2 성능 모니터링 모듈 동적 import
            v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
            
            if v2_path not in sys.path:
                sys.path.insert(0, v2_path)
            
            # 성능 모니터링 모듈 import
            import importlib.util
            
            # PerformanceMonitor 로드
            monitor_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/performance_monitor.py')
            spec = importlib.util.spec_from_file_location("performance_monitor", monitor_path)
            monitor_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(monitor_module)
            
            PerformanceMonitor = getattr(monitor_module, 'PerformanceMonitor')
            PerformanceComparator = getattr(monitor_module, 'PerformanceComparator')
            
            # PerformanceOptimizer 로드
            optimizer_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/performance_optimizer.py')
            spec = importlib.util.spec_from_file_location("performance_optimizer", optimizer_path)
            optimizer_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(optimizer_module)
            
            PerformanceOptimizer = getattr(optimizer_module, 'PerformanceOptimizer')
            
            # 성능 모니터링 시스템 초기화
            self.performance_monitor = PerformanceMonitor(
                script_dir=self.script_dir,
                monitoring_interval=300  # 5분 간격
            )
            
            self.performance_optimizer = PerformanceOptimizer(self.script_dir)
            self.performance_comparator = PerformanceComparator(self.script_dir)
            
            # 성능 모니터링 시작
            self.performance_monitor.start_monitoring()
            
            # v1 기준선 수집 및 설정 (백그라운드에서)
            try:
                v1_baseline = self.performance_comparator.collect_v1_baseline()
                if v1_baseline:
                    self.performance_monitor.set_v1_baseline(v1_baseline)
                    self.log("📊 v1 시스템 기준선 설정 완료")
            except Exception as e:
                self.log(f"⚠️ v1 기준선 수집 실패: {e}")
            
            self.log("✅ v2 성능 모니터링 시스템 초기화 완료")
            
            # 성능 모니터링 상태를 알림으로 전송
            if self.v3_0_components.get('notification_manager'):
                try:
                    self.v3_0_components['notification_manager'].send_notification(
                        "🎯 POSCO WatchHamster v3.0.0 성능 모니터링 시스템이 활성화되었습니다./n"
                        "• CPU 및 메모리 사용량 실시간 추적/n"
                        "• 프로세스 관리 응답시간 모니터링/n"
                        "• v1/v2 성능 비교 분석/n"
                        "• 자동 최적화 권장사항 생성"
                    )
                except Exception as e:
                    self.log(f"⚠️ 성능 모니터링 시작 알림 전송 실패: {e}")
            
        except ImportError as e:
            pass  # REMOVED
            self.performance_monitor = None
            self.performance_optimizer = None
            self.performance_comparator = None
        except Exception as e:
            self.log(f"❌ 성능 모니터링 시스템 초기화 실패: {e}")
            self.performance_monitor = None
            self.performance_optimizer = None
            self.performance_comparator = None
    
    def _perform_performance_analysis(self):
        """
        성능 분석 및 최적화 권장사항 생성
        
        10분마다 실행되어 시스템 성능을 분석하고 필요시 최적화 권장사항을 생성합니다.
        """
        try:
            if not self.performance_monitor or not self.performance_optimizer:
                return
            
            # 성능 요약 조회
            performance_summary = self.performance_monitor.get_performance_summary()
            
            if 'error' in performance_summary:
                self.log(f"⚠️ 성능 요약 조회 실패: {performance_summary['error']}")
                return
            
            # 성능 수준 평가
            performance_level = performance_summary.get('performance_level', 'unknown')
            
            # 성능 이슈 분석
            issues = self.performance_optimizer.analyze_system_performance(performance_summary)
            
            if issues:
                self.log(f"🔍 성능 이슈 {len(issues)}개 감지됨")
                
                # 최적화 권장사항 생성
                recommendations = self.performance_optimizer.generate_optimization_recommendations(issues)
                
                if recommendations:
                    self.log(f"💡 최적화 권장사항 {len(recommendations)}개 생성됨")
                    
                    # 높은 우선순위 권장사항이 있으면 알림 전송
                    high_priority_recs = [
                        rec for rec in recommendations 
                        if rec.priority.value in ['critical', 'high']
                    ]
                    
                    if high_priority_recs and not self.is_quiet_hours():
                        self._send_performance_alert(performance_summary, high_priority_recs)
            
            # v1/v2 성능 비교 (1시간마다)
            if (hasattr(self, '_last_performance_comparison') and 
                (datetime.now() - self._last_performance_comparison).total_seconds() >= 3600):
                self._perform_v1_v2_comparison()
                self._last_performance_comparison = datetime.now()
            elif not hasattr(self, '_last_performance_comparison'):
                self._last_performance_comparison = datetime.now()
            
            # 성능 로그 (디버그용)
            current_cpu = performance_summary.get('current', {}).get('cpu_percent', 0)
            current_memory = performance_summary.get('current', {}).get('memory_percent', 0)
            
            self.log(f"📊 성능 상태: CPU {current_cpu:.1f}%, 메모리 {current_memory:.1f}%, 수준: {performance_level}")
            
        except Exception as e:
            self.log(f"❌ 성능 분석 중 오류 발생: {e}")
    
    def _send_performance_alert(self, performance_summary: dict, recommendations: list):
        """
        성능 알림 전송
        
        Args:
            performance_summary (dict): 성능 요약 정보
            recommendations (list): 높은 우선순위 권장사항 목록
        """
        try:
            current_stats = performance_summary.get('current', {})
            
            # 알림 메시지 구성
            alert_message = (
                f"⚠️ POSCO WatchHamster v3.0.0 성능 알림/n/n"
                f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"📊 현재 상태:/n"
                f"  • CPU 사용률: {current_stats.get('cpu_percent', 0):.1f}%/n"
                f"  • 메모리 사용률: {current_stats.get('memory_percent', 0):.1f}%/n"
                f"  • 프로세스 수: {current_stats.get('process_count', 0)}개/n"
                f"  • 성능 수준: {performance_summary.get('performance_level', 'unknown')}/n/n"
                f"🔧 권장사항 ({len(recommendations)}개):/n"
            )
            
            for i, rec in enumerate(recommendations[:3], 1):  # 최대 3개만 표시
                priority_emoji = {"critical": "🚨", "high": "⚠️"}.get(rec.priority.value, "📋")
                alert_message += f"  {i}. {priority_emoji} {rec.title}/n"
                alert_message += f"     예상 효과: {rec.estimated_improvement}/n"
            
            if len(recommendations) > 3:
                alert_message += f"  ... 외 {len(recommendations) - 3}개 추가 권장사항/n"
            
            alert_message += f"/n💡 자세한 내용은 성능 모니터링 로그를 확인하세요."
            
            # 알림 전송
            if self.v3_0_components.get('notification_manager'):
                self.v3_0_components['notification_manager'].send_notification(alert_message, is_error=True)
            else:
                self.send_notification(alert_message, is_error=True)
            
            self.log("📤 성능 알림 전송 완료")
            
        except Exception as e:
            self.log(f"❌ 성능 알림 전송 실패: {e}")
    
    def _perform_v1_v2_comparison(self):
        """
        v1과 v2 시스템 성능 비교 수행
        """
        try:
            if not self.performance_monitor:
                return
            
            # v1/v2 성능 비교 수행
            comparison = self.performance_monitor.get_v1_v2_comparison()
            
            if comparison:
                # 비교 보고서 생성
                if self.performance_comparator:
                    report = self.performance_comparator.generate_comparison_report(
                        comparison.v1_metrics, 
                        comparison.v2_metrics
                    )
                    
                    # 보고서 저장
                    report_file = self.performance_comparator.save_comparison_report(report)
                    
                    if report_file:
                        self.log(f"📊 v1/v2 성능 비교 보고서 생성: {os.path.basename(report_file)}")
                        
                        # 주요 개선사항이 있으면 알림 전송 (조용한 시간대 제외)
                        significant_improvements = [
                            metric for metric, improvement in comparison.improvement_percentage.items()
                            if improvement > 15  # 15% 이상 개선
                        ]
                        
                        if significant_improvements and not self.is_quiet_hours():
                            improvement_summary = "/n".join([
                                f"  • {metric}: {comparison.improvement_percentage[metric]:+.1f}% 개선"
                                for metric in significant_improvements
                            ])
                            
                            comparison_message = (
                                f"📈 POSCO WatchHamster v3.0.0 성능 개선 보고/n/n"
                                f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                                f"🎯 주요 개선사항:/n{improvement_summary}/n/n"
                                f"📋 상세 보고서: {os.path.basename(report_file)}"
                            )
                            
                            if self.v3_0_components.get('notification_manager'):
                                self.v3_0_components['notification_manager'].send_notification(comparison_message)
                            else:
                                self.send_notification(comparison_message)
            
        except Exception as e:
            self.log(f"❌ v1/v2 성능 비교 실패: {e}")
    
    def get_performance_status(self):
        """
        성능 모니터링 상태 조회
        
        Returns:
            dict: 성능 모니터링 상태 정보
        """
        try:
            if not self.performance_monitor:
                return {'error': '성능 모니터링이 비활성화되어 있습니다'}
            
            # 성능 요약 조회
            performance_summary = self.performance_monitor.get_performance_summary()
            
            # 최적화 요약 조회
            optimization_summary = {}
            if self.performance_optimizer:
                optimization_summary = self.performance_optimizer.get_optimization_summary()
            
            return {
                'performance_monitoring_enabled': True,
                'performance_summary': performance_summary,
                'optimization_summary': optimization_summary,
                'last_performance_check': getattr(self, '_last_performance_check', None),
                'last_performance_comparison': getattr(self, '_last_performance_comparison', None)
            }
            
        except Exception as e:
            return {'error': f'성능 상태 조회 실패: {e}'}
    
    def measure_operation_performance(self, operation_name: str):
        """
        작업 성능 측정을 위한 컨텍스트 매니저 반환
        
        Args:
            operation_name (str): 측정할 작업 이름
            
        Returns:
            OperationTimer: 작업 시간 측정 컨텍스트 매니저
        """
        if self.performance_monitor:
            return self.performance_monitor.measure_operation_time(operation_name)
        else:
            # 성능 모니터링이 비활성화된 경우 더미 컨텍스트 매니저 반환
            class DummyTimer:
                def __enter__(self):
                    return self
                def __exit__(self, exc_type, exc_val, exc_tb):
                    pass
            return DummyTimer()
    
    def _record_initialization_success(self, initialization_time):
        """
        초기화 성공 통계 기록
        
        Args:
            initialization_time (float): 초기화 소요 시간 (초)
        """
        try:
            # 초기화 통계 정보
            self.v2_initialization_stats = {
                'success': True,
                'initialization_time': initialization_time,
                'timestamp': datetime.now(),
                'components_loaded': len([c for c in self.v3_0_components.values() if c is not None]),
                'validation_results': getattr(self, 'v2_validation_results', {})
            }
            
            self.log(f"📊 v2 초기화 통계 기록 완료 (소요시간: {initialization_time:.2f}초)")
            
        except Exception as e:
            self.log(f"⚠️ 초기화 통계 기록 실패: {e}")
    
    def _handle_v2_initialization_failure(self, error, initialization_start):
        """
        v2 초기화 실패 처리 및 폴백
        
        Args:
            error (Exception): 발생한 오류
            initialization_start (datetime): 초기화 시작 시간
        """
        initialization_time = (datetime.now() - initialization_start).total_seconds()
        
        # v2 초기화 실패 상태 설정
        self.v3_0_enabled = False
        self.fallback_reason = str(error)
        
        # v2 컴포넌트 정리
        self.v3_0_components = {
            'process_manager': None,
            'module_registry': None,
            'notification_manager': None
        }
        
        # 기존 ProcessManager로 폴백 시도
        try:
            self.v3_0_components['process_manager'] = ProcessManager(self.script_dir)
            self.log("✅ 기존 ProcessManager로 폴백 완료")
        except Exception as fallback_error:
            self.log(f"❌ 기존 ProcessManager 폴백도 실패: {fallback_error}")
        
        # 실패 통계 기록
        self.v2_initialization_stats = {
            'success': False,
            'initialization_time': initialization_time,
            'timestamp': datetime.now(),
            'error': str(error),
            'fallback_reason': self.fallback_reason
        }
        
        self.log(f"⚠️ v2 아키텍처 초기화 실패 (소요시간: {initialization_time:.2f}초)")
        self.log(f"❌ 실패 원인: {error}")
        self.log("📋 기존 방식으로 폴백하여 정상 동작합니다")
    
    def _initialize_module_status_tracking(self):
        """
        모듈 상태 추적 시스템 초기화
        
        ModuleRegistry와 연동하여 각 모듈의 상태를 추적하고 제어할 수 있는 시스템을 초기화합니다.
        """
        try:
            self.log("📊 모듈 상태 추적 시스템 초기화 중...")
            
            if not self.v3_0_components['module_registry']:
                self.log("⚠️ ModuleRegistry가 없어 상태 추적을 초기화할 수 없습니다")
                return
            
            # 모듈별 상태 추적 딕셔너리 초기화
            self.module_status_tracking = {}
            
            # 등록된 모든 모듈에 대해 상태 추적 초기화
            modules = self.v3_0_components['module_registry'].list_modules()
            
            for module_name, module_info in modules.items():
                self.module_status_tracking[module_name] = {
                    'config': module_info['config'],
                    'registry_status': module_info['status'],
                    'process_status': 'unknown',  # 실제 프로세스 상태
                    'last_check': None,
                    'restart_count': 0,
                    'last_restart': None,
                    'health_check_failures': 0,
                    'last_health_check': None
                }
                
                # ModuleRegistry에서 초기 상태 설정
                # ModuleStatus enum을 동적으로 가져오기
                try:
                    import importlib.util
                    v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
                    module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
                    spec = importlib.util.spec_from_file_location("module_registry", module_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    ModuleStatus = getattr(module, 'ModuleStatus')
                    
                    self.v3_0_components['module_registry'].update_module_status(
                        module_name, 
                        ModuleStatus.REGISTERED
                    )
                except Exception as e:
                    self.log(f"⚠️ ModuleStatus 설정 실패 ({module_name}): {e}")
            
            self.log(f"✅ 모듈 상태 추적 초기화 완료: {len(self.module_status_tracking)}개 모듈")
            
            # 모듈별 상태 로그
            for module_name in self.module_status_tracking.keys():
                self.log(f"  📋 추적 대상 모듈: {module_name}")
            
        except Exception as e:
            self.log(f"❌ 모듈 상태 추적 초기화 실패: {e}")
            self.module_status_tracking = {}
    
    def update_module_status(self, module_name: str, process_status: str, additional_info: dict = None):
        """
        모듈 상태 업데이트
        
        Args:
            module_name (str): 모듈 이름
            process_status (str): 프로세스 상태 ('running', 'stopped', 'error', 'unknown')
            additional_info (dict): 추가 정보
        """
        try:
            current_time = datetime.now()
            
            # 모듈 상태 추적 정보가 없으면 초기화
            if not hasattr(self, 'module_status_tracking'):
                self.module_status_tracking = {}
            
            if module_name not in self.module_status_tracking:
                self.module_status_tracking[module_name] = {
                    'process_status': 'unknown',
                    'last_check': None,
                    'restart_count': 0,
                    'last_restart': None,
                    'health_check_failures': 0,
                    'last_health_check': None
                }
            
            # 상태 업데이트
            old_status = self.module_status_tracking[module_name]['process_status']
            self.module_status_tracking[module_name]['process_status'] = process_status
            self.module_status_tracking[module_name]['last_check'] = current_time
            
            # 추가 정보 업데이트
            if additional_info:
                self.module_status_tracking[module_name].update(additional_info)
            
            # ModuleRegistry 상태도 업데이트
            if self.v3_0_enabled and self.v3_0_components['module_registry']:
                try:
                    # 프로세스 상태에 따른 ModuleRegistry 상태 매핑
                    try:
                        import importlib.util
                        v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
                        module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/module_registry.py')
                        spec = importlib.util.spec_from_file_location("module_registry", module_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        ModuleStatus = getattr(module, 'ModuleStatus')
                        
                        if process_status == 'running':
                            registry_status = ModuleStatus.ACTIVE
                        elif process_status == 'stopped':
                            registry_status = ModuleStatus.INACTIVE
                        elif process_status == 'error':
                            registry_status = ModuleStatus.ERROR
                        else:
                            registry_status = ModuleStatus.REGISTERED
                        
                        self.v3_0_components['module_registry'].update_module_status(module_name, registry_status)
                    except Exception as enum_error:
                        self.log(f"⚠️ ModuleStatus enum 로드 실패: {enum_error}")
                    
                except Exception as e:
                    self.log(f"⚠️ ModuleRegistry 상태 업데이트 실패 ({module_name}): {e}")
            
            # 상태 변경 로그
            if old_status != process_status:
                self.log(f"📊 모듈 상태 변경: {module_name} ({old_status} → {process_status})")
            
        except Exception as e:
            self.log(f"❌ 모듈 상태 업데이트 실패 ({module_name}): {e}")
    
    def get_module_status_summary(self):
        """
        모든 모듈의 상태 요약 조회
        
        Returns:
            dict: 모듈 상태 요약 정보
        """
        try:
            if not hasattr(self, 'module_status_tracking'):
                return {'error': '모듈 상태 추적이 초기화되지 않았습니다'}
            
            summary = {
                'timestamp': datetime.now().isoformat(),
                'total_modules': len(self.module_status_tracking),
                'status_counts': {
                    'running': 0,
                    'stopped': 0,
                    'error': 0,
                    'unknown': 0
                },
                'modules': {}
            }
            
            # 각 모듈 상태 집계
            for module_name, status_info in self.module_status_tracking.items():
                process_status = status_info['process_status']
                summary['status_counts'][process_status] = summary['status_counts'].get(process_status, 0) + 1
                
                # 모듈별 상세 정보
                summary['modules'][module_name] = {
                    'process_status': process_status,
                    'last_check': status_info['last_check'].isoformat() if status_info['last_check'] else None,
                    'restart_count': status_info.get('restart_count', 0),
                    'health_check_failures': status_info.get('health_check_failures', 0)
                }
                
                # ModuleRegistry 상태도 포함
                if self.v3_0_enabled and self.v3_0_components['module_registry']:
                    try:
                        registry_status = self.v3_0_components['module_registry'].get_module_status(module_name)
                        summary['modules'][module_name]['registry_status'] = registry_status.value if registry_status else 'unknown'
                    except Exception as e:
                        summary['modules'][module_name]['registry_status'] = f'error: {e}'
            
            return summary
            
        except Exception as e:
            return {'error': f'상태 요약 조회 실패: {e}'}
    
    def control_module(self, module_name: str, action: str):
        """
        개별 모듈 제어 기능
        
        Args:
            module_name (str): 제어할 모듈 이름
            action (str): 수행할 작업 ('start', 'stop', 'restart', 'status')
            
        Returns:
            dict: 제어 결과
        """
        try:
            self.log(f"🎛️ 모듈 제어 요청: {module_name} - {action}")
            
            # ModuleRegistry에서 모듈 설정 조회
            if not (self.v3_0_enabled and self.v3_0_components['module_registry']):
                return {
                    'success': False,
                    'error': 'v2 ModuleRegistry가 비활성화되어 있습니다',
                    'fallback': 'basic_control'
                }
            
            module_config = self.v3_0_components['module_registry'].get_module_config(module_name)
            if not module_config:
                return {
                    'success': False,
                    'error': f'모듈을 찾을 수 없습니다: {module_name}'
                }
            
            result = {'success': False, 'action': action, 'module': module_name}
            
            if action == 'status':
                # 모듈 상태 조회
                if hasattr(self, 'module_status_tracking') and module_name in self.module_status_tracking:
                    result.update({
                        'success': True,
                        'status': self.module_status_tracking[module_name]
                    })
                else:
                    result.update({
                        'success': True,
                        'status': 'not_tracked'
                    })
            
            elif action == 'start':
                # 모듈 시작
                if self.v3_0_components['process_manager']:
                    try:
                        # Enhanced ProcessManager를 통한 프로세스 시작
                        start_result = self.v3_0_components['process_manager'].start_process(
                            module_config.script_path,
                            module_name,
                            working_dir=module_config.working_directory or self.script_dir,
                            env_vars=module_config.environment_vars
                        )
                        
                        if start_result:
                            self.update_module_status(module_name, 'running')
                            result.update({
                                'success': True,
                                'message': f'모듈 시작 성공: {module_name}'
                            })
                        else:
                            result.update({
                                'success': False,
                                'error': f'모듈 시작 실패: {module_name}'
                            })
                    except Exception as e:
                        result.update({
                            'success': False,
                            'error': f'모듈 시작 중 오류: {e}'
                        })
                else:
                    result.update({
                        'success': False,
                        'error': 'ProcessManager가 사용할 수 없습니다'
                    })
            
            elif action == 'stop':
                # 모듈 중지
                if self.v3_0_components['process_manager']:
                    try:
                        # Enhanced ProcessManager를 통한 프로세스 중지
                        stop_result = self.v3_0_components['process_manager'].stop_process(module_name)
                        
                        if stop_result:
                            self.update_module_status(module_name, 'stopped')
                            result.update({
                                'success': True,
                                'message': f'모듈 중지 성공: {module_name}'
                            })
                        else:
                            result.update({
                                'success': False,
                                'error': f'모듈 중지 실패: {module_name}'
                            })
                    except Exception as e:
                        result.update({
                            'success': False,
                            'error': f'모듈 중지 중 오류: {e}'
                        })
                else:
                    result.update({
                        'success': False,
                        'error': 'ProcessManager가 사용할 수 없습니다'
                    })
            
            elif action == 'restart':
                # 모듈 재시작
                stop_result = self.control_module(module_name, 'stop')
                if stop_result.get('success'):
                    time.sleep(2)  # 잠시 대기
                    start_result = self.control_module(module_name, 'start')
                    result = start_result
                    if start_result.get('success'):
                        result['message'] = f'모듈 재시작 성공: {module_name}'
                else:
                    result = stop_result
            
            else:
                result.update({
                    'success': False,
                    'error': f'지원하지 않는 작업: {action}'
                })
            
            self.log(f"🎛️ 모듈 제어 결과: {module_name} - {action} - {'성공' if result.get('success') else '실패'}")
            return result
            
        except Exception as e:
            error_result = {
                'success': False,
                'error': f'모듈 제어 중 예외 발생: {e}',
                'action': action,
                'module': module_name
            }
            self.log(f"❌ 모듈 제어 예외: {module_name} - {action} - {e}")
            return error_result
    
    def _update_module_status_from_health_check(self, health_results: dict):
        """
        헬스체크 결과를 바탕으로 모듈 상태 업데이트
        
        Args:
            health_results (dict): 프로세스별 헬스체크 결과
        """
        try:
            if not hasattr(self, 'module_status_tracking'):
                return
            
            current_time = datetime.now()
            
            for process_name, is_healthy in health_results.items():
                # 프로세스 상태 결정
                if is_healthy:
                    process_status = 'running'
                    # 연속 실패 카운트 리셋
                    if process_name in self.module_status_tracking:
                        self.module_status_tracking[process_name]['health_check_failures'] = 0
                else:
                    process_status = 'error'
                    # 연속 실패 카운트 증가
                    if process_name in self.module_status_tracking:
                        self.module_status_tracking[process_name]['health_check_failures'] = \
                            self.module_status_tracking[process_name].get('health_check_failures', 0) + 1
                
                # 모듈 상태 업데이트
                additional_info = {
                    'last_health_check': current_time,
                    'health_check_result': is_healthy
                }
                
                self.update_module_status(process_name, process_status, additional_info)
            
            # 헬스체크 통계 업데이트
            if not hasattr(self, 'health_check_stats'):
                self.health_check_stats = {}
            
            self.health_check_stats.update({
                'last_check': current_time,
                'total_modules': len(health_results),
                'healthy_modules': sum(1 for is_healthy in health_results.values() if is_healthy),
                'failed_modules': sum(1 for is_healthy in health_results.values() if not is_healthy)
            })
            
        except Exception as e:
            self.log(f"❌ 헬스체크 기반 모듈 상태 업데이트 실패: {e}")
    

    
    def get_v2_integration_status(self):
        """
        v2 통합 상태 정보 조회 - 상세한 컴포넌트 상태 포함
        
        Returns:
            dict: v2 통합 상태 정보
        """
        try:
            current_time = datetime.now()
            
            # 기본 상태 정보
            status = {
                'v3_0_enabled': self.v3_0_enabled,
                'fallback_reason': self.fallback_reason,
                'timestamp': current_time.isoformat(),
                'components': {
                    'process_manager': self.v3_0_components['process_manager'] is not None,
                    'module_registry': self.v3_0_components['module_registry'] is not None,
                    'notification_manager': self.v3_0_components['notification_manager'] is not None
                },
                'managed_processes_count': len(self.managed_processes),
                'managed_processes': self.managed_processes
            }
            
            # 초기화 통계 정보 추가
            if hasattr(self, 'v2_initialization_stats'):
                status['initialization_stats'] = self.v2_initialization_stats
            
            # 검증 결과 추가
            if hasattr(self, 'v2_validation_results'):
                status['validation_results'] = self.v2_validation_results
            
            # v2 컴포넌트별 상세 정보
            if self.v3_0_enabled:
                # Enhanced ProcessManager 상태
                if self.v3_0_components['process_manager']:
                    try:
                        system_status = self.v3_0_components['process_manager'].get_system_status()
                        status['system_metrics'] = system_status.get('system_metrics', {})
                        status['process_details'] = system_status.get('process_details', {})
                        status['process_manager_status'] = 'operational'
                    except Exception as e:
                        status['process_manager_error'] = str(e)
                        status['process_manager_status'] = 'error'
                
                # ModuleRegistry 상태
                if self.v3_0_components['module_registry']:
                    try:
                        modules = self.v3_0_components['module_registry'].list_modules()
                        startup_order = self.v3_0_components['module_registry'].get_startup_order()
                        
                        status['registered_modules'] = list(modules.keys())
                        status['startup_order'] = startup_order
                        status['module_registry_status'] = 'operational'
                        
                        # 모듈별 상세 정보
                        module_details = {}
                        for module_name, module_config in modules.items():
                            module_details[module_name] = {
                                'auto_start': module_config.auto_start,
                                'priority': module_config.priority,
                                'dependencies': module_config.dependencies,
                                'max_restart_attempts': module_config.max_restart_attempts
                            }
                        status['module_details'] = module_details
                        
                    except Exception as e:
                        status['module_registry_error'] = str(e)
                        status['module_registry_status'] = 'error'
                
                # NotificationManager 상태
                if self.v3_0_components['notification_manager']:
                    try:
                        notification_stats = self.v3_0_components['notification_manager'].get_notification_stats()
                        status['notification_stats'] = notification_stats
                        status['notification_manager_status'] = 'operational'
                    except Exception as e:
                        status['notification_manager_error'] = str(e)
                        status['notification_manager_status'] = 'error'
            
            return status
            
        except Exception as e:
            return {
                'error': f"상태 조회 실패: {e}",
                'v3_0_enabled': False,
                'timestamp': datetime.now().isoformat()
            }
    
    def check_v2_component_health(self):
        """
        v2 컴포넌트 헬스체크 수행
        
        Returns:
            dict: 컴포넌트별 헬스체크 결과
        """
        health_results = {}
        
        try:
            if not self.v3_0_enabled:
                return {
                    'overall_status': 'disabled',
                    'reason': 'v2 아키텍처가 비활성화됨',
                    'fallback_reason': self.fallback_reason
                }
            
            # Enhanced ProcessManager 헬스체크
            if self.v3_0_components['process_manager']:
                try:
                    # 시스템 상태 조회로 헬스체크
                    system_status = self.v3_0_components['process_manager'].get_system_status()
                    health_results['process_manager'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"프로세스 {len(system_status.get('process_details', {}))}개 관리 중"
                    }
                except Exception as e:
                    health_results['process_manager'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # ModuleRegistry 헬스체크
            if self.v3_0_components['module_registry']:
                try:
                    # 모듈 목록 조회로 헬스체크
                    modules = self.v3_0_components['module_registry'].list_modules()
                    health_results['module_registry'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"모듈 {len(modules)}개 등록됨"
                    }
                except Exception as e:
                    health_results['module_registry'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # NotificationManager 헬스체크
            if self.v3_0_components['notification_manager']:
                try:
                    # 알림 통계 조회로 헬스체크
                    stats = self.v3_0_components['notification_manager'].get_notification_stats()
                    health_results['notification_manager'] = {
                        'status': 'healthy',
                        'last_check': datetime.now().isoformat(),
                        'details': f"총 알림 {stats.get('total_notifications', 0)}개 전송됨"
                    }
                except Exception as e:
                    health_results['notification_manager'] = {
                        'status': 'unhealthy',
                        'last_check': datetime.now().isoformat(),
                        'error': str(e)
                    }
            
            # 전체 상태 판단
            healthy_components = sum(1 for result in health_results.values() 
                                   if result.get('status') == 'healthy')
            total_components = len(health_results)
            
            if healthy_components == total_components:
                overall_status = 'healthy'
            elif healthy_components > 0:
                overall_status = 'partially_healthy'
            else:
                overall_status = 'unhealthy'
            
            health_results['overall_status'] = overall_status
            health_results['healthy_components'] = healthy_components
            health_results['total_components'] = total_components
            health_results['check_timestamp'] = datetime.now().isoformat()
            
            return health_results
            
        except Exception as e:
            return {
                'overall_status': 'error',
                'error': str(e),
                'check_timestamp': datetime.now().isoformat()
            }
    
    def handle_process_failure_v3_0(self, process_name: str):
        """
        v2 아키텍처를 사용한 프로세스 실패 처리
        
        3단계 지능적 복구 시스템을 사용하여 실패한 프로세스를 복구합니다.
        
        구현 내용:
        - v2 ProcessManager의 auto_recovery() 메서드 사용
        - 3단계 복구 시스템: 즉시 재시작 → 5분 후 재시도 → 최종 재시도
        - 복구 성공/실패에 따른 알림 전송
        - 프로세스 상태 추적 및 로깅
        
        Args:
            process_name (str): 실패한 프로세스 이름
        """
        try:
            if not self.v3_0_enabled or not self.v3_0_components['process_manager']:
                self.log(f"⚠️ v2 아키텍처 비활성화, 기존 방식으로 처리: {process_name}")
                self._handle_process_failure_legacy(process_name)
                return
            
            self.log(f"🔧 v2 3단계 지능적 복구 시스템 시작: {process_name}")
            
            # 프로세스 정보 조회
            process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
            if not process_info:
                self.log(f"❌ {process_name}: 프로세스 정보를 찾을 수 없습니다")
                # 새 프로세스로 등록하여 복구 시도
                self._register_new_process_for_recovery(process_name)
                return
            
            # 현재 재시작 횟수 기록
            current_restart_count = process_info.restart_count
            recovery_start_time = datetime.now()
            
            self.log(f"📊 {process_name} 복구 시작 - 현재 재시작 횟수: {current_restart_count}/3")
            
            # 오류 알림 전송 (복구 시작 전)
            if self.v3_0_components['notification_manager']:
                error_details = {
                    'error_message': process_info.last_error or '프로세스 중단됨',
                    'restart_count': current_restart_count,
                    'max_attempts': 3,
                    'auto_recovery_enabled': True,
                    'recovery_stage': 'starting'
                }
                self.v3_0_components['notification_manager'].send_process_error(process_name, error_details)
            
            # v2 ProcessManager의 3단계 자동 복구 시스템 실행
            recovery_success = self.v3_0_components['process_manager'].auto_recovery(process_name)
            
            recovery_end_time = datetime.now()
            recovery_duration = (recovery_end_time - recovery_start_time).total_seconds()
            
            if recovery_success:
                # 복구 성공 처리
                new_process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                recovery_stage = new_process_info.restart_count if new_process_info else current_restart_count + 1
                
                self.log(f"✅ {process_name} 자동 복구 성공 - {recovery_stage}단계 복구 완료 (소요시간: {recovery_duration:.1f}초)")
                
                # v2 향상된 복구 성공 알림 사용
                recovery_details = {
                    'recovery_stage': f"{recovery_stage}단계 복구",
                    'recovery_time': recovery_duration,
                    'new_pid': new_process_info.pid if new_process_info else None,
                    'previous_restart_count': current_restart_count,
                    'current_restart_count': recovery_stage
                }
                self.send_recovery_success_v2(process_name, recovery_details)
                
                # 모듈 상태 업데이트 (ModuleRegistry 사용)
                if self.v3_0_components['module_registry']:
                    try:
                        # REMOVED: 원본 코드
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.ACTIVE)
                        self.log(f"📋 {process_name} 모듈 상태를 ACTIVE로 업데이트")
                    except Exception as e:
                        self.log(f"⚠️ {process_name} 모듈 상태 업데이트 실패: {e}")
                
            else:
                # 복구 실패 처리
                final_process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                final_restart_count = final_process_info.restart_count if final_process_info else 3
                
                self.log(f"❌ {process_name} 자동 복구 실패 - 모든 복구 단계 실패 (총 {final_restart_count}회 시도)")
                
                # v2 NotificationManager를 사용한 긴급 알림
                if self.v3_0_components['notification_manager']:
                    critical_details = {
                        '최대_재시작_횟수': f'{final_restart_count}회 초과',
                        '프로세스_상태': '비활성화됨',
                        '복구_소요시간': f'{recovery_duration:.1f}초',
                        '마지막_오류': final_process_info.last_error if final_process_info else '알 수 없음',
                        '필요_조치': '수동 확인 및 재시작'
                    }
                    # v2 향상된 긴급 알림 사용
                    self.send_critical_alert_v2(f"{process_name} 프로세스 복구 실패", critical_details)
                
                # 모듈 상태 업데이트 (ModuleRegistry 사용)
                if self.v3_0_components['module_registry']:
                    try:
                        # REMOVED: 원본 코드
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.FAILED)
                        self.log(f"📋 {process_name} 모듈 상태를 FAILED로 업데이트")
                    except Exception as e:
                        self.log(f"⚠️ {process_name} 모듈 상태 업데이트 실패: {e}")
                
        except Exception as e:
            self.log(f"❌ v2 프로세스 실패 처리 오류: {e}")
            # 예외 발생 시 기존 방식으로 폴백
            self._handle_process_failure_legacy(process_name)
    
    def _handle_process_failure_legacy(self, process_name: str):
        """
        기존 방식의 프로세스 실패 처리 (v2 폴백용)
        
        Args:
            process_name (str): 실패한 프로세스 이름
        """
        try:
            self.log(f"🔄 기존 방식으로 {process_name} 복구 시도")
            
            # 기존 ProcessManager 사용 (있는 경우)
            if self.v3_0_components['process_manager'] and hasattr(self.v3_0_components['process_manager'], 'restart_process'):
                success = self.v3_0_components['process_manager'].restart_process(process_name)
                if success:
                    self.log(f"✅ {process_name} 기존 방식 복구 성공")
                    self.send_notification(
                        f"✅ POSCO WatchHamster v3.0 프로세스 복구/n/n"
                        f"📋 프로세스: {process_name}/n"
                        f"🔧 복구 방식: 기존 방식 (v2 폴백)/n"
                        f"🎯 프로세스가 복구되었습니다."
                    )
                else:
                    self.log(f"❌ {process_name} 기존 방식 복구 실패")
                    self.send_notification(
                        f"❌ POSCO WatchHamster v3.0 프로세스 복구 실패/n/n"
                        f"📋 프로세스: {process_name}/n"
                        f"🔧 복구 방식: 기존 방식 (v2 폴백)/n"
                        f"🛠️ 수동 확인이 필요합니다.",
                        is_error=True
                    )
            else:
                self.log(f"⚠️ {process_name}: 사용 가능한 복구 방법이 없습니다")
                
        except Exception as e:
            self.log(f"❌ 기존 방식 프로세스 복구 오류: {e}")
    
    def _register_new_process_for_recovery(self, process_name: str):
        """
        복구를 위해 새 프로세스를 등록
        
        Args:
            process_name (str): 등록할 프로세스 이름
        """
        try:
            if not self.v3_0_components['module_registry']:
                return
            
            # 모듈 설정에서 프로세스 정보 조회
            module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
            if module_config:
                self.log(f"🔄 {process_name} 새 프로세스로 등록하여 복구 시도")
                success = self.v3_0_components['process_manager'].start_process(
                    process_name,
                    module_config.script_path,
                    [],
                    module_config.working_directory
                )
                if success:
                    self.log(f"✅ {process_name} 새 프로세스 등록 및 시작 성공")
                else:
                    self.log(f"❌ {process_name} 새 프로세스 등록 실패")
            else:
                self.log(f"❌ {process_name}: 모듈 설정을 찾을 수 없습니다")
                
        except Exception as e:
            self.log(f"❌ 새 프로세스 등록 오류: {e}")
    
    def integrate_v2_process_lifecycle_management(self):
        """
        v2 ProcessManager와 기존 프로세스 생명주기 관리 통합
        
        기존 프로세스 관리 로직을 v2 ProcessManager의 향상된 기능과 통합하여
        더 안정적이고 지능적인 프로세스 생명주기 관리를 제공합니다.
        
        구현 내용:
        - 기존 프로세스 객체를 v2 ProcessManager로 마이그레이션
        - v2의 3단계 지능적 복구 시스템 활성화
        - 프로세스 상태 추적 및 메트릭 수집 통합
        - 향상된 알림 시스템 연동
        """
        try:
            if not self.v3_0_enabled or not self.v3_0_components['process_manager']:
                self.log("⚠️ v2 아키텍처 비활성화, 프로세스 생명주기 통합 건너뜀")
                return False
            
            self.log("🔄 v2 ProcessManager와 기존 프로세스 생명주기 관리 통합 시작")
            
            integration_start_time = datetime.now()
            migrated_processes = []
            failed_migrations = []
            
            # 1. 기존 프로세스 객체들을 v2 ProcessManager로 마이그레이션
            existing_processes = getattr(self, 'monitor_process', None), getattr(self, 'realtime_process', None)
            
            for process_obj in existing_processes:
                if process_obj and hasattr(process_obj, 'pid'):
                    try:
                        # 기존 프로세스를 v2 ProcessManager에 등록
                        process_name = self._identify_process_name(process_obj)
                        if process_name:
                            # v2 ProcessManager에 기존 프로세스 정보 등록
                            self._migrate_existing_process_to_v2(process_name, process_obj)
                            migrated_processes.append(process_name)
                            self.log(f"✅ {process_name} v2 ProcessManager로 마이그레이션 완료")
                        
                    except Exception as e:
                        failed_migrations.append(f"Unknown Process: {e}")
                        self.log(f"❌ 프로세스 마이그레이션 실패: {e}")
            
            # 2. 관리 대상 프로세스들의 v2 통합 상태 확인
            for process_name in self.managed_processes:
                if process_name not in migrated_processes:
                    # 새로운 프로세스로 v2 시스템에 등록
                    try:
                        module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                        if module_config:
                            # v2 ProcessManager에 프로세스 정보 초기화
                            self.v3_0_components['process_manager']._initialize_process_info(process_name)
                            migrated_processes.append(process_name)
                            self.log(f"📋 {process_name} v2 시스템에 새로 등록됨")
                        
                    except Exception as e:
                        failed_migrations.append(f"{process_name}: {e}")
                        self.log(f"❌ {process_name} v2 등록 실패: {e}")
            
            # 3. v2 3단계 지능적 복구 시스템 활성화
            if migrated_processes:
                self.log("🛡️ v2 3단계 지능적 복구 시스템 활성화")
                
                # 복구 시스템 설정 적용
                for process_name in migrated_processes:
                    try:
                        process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                        if process_info:
                            # 복구 시스템 메타데이터 설정
                            process_info.recovery_enabled = True
                            process_info.max_recovery_attempts = 3
                            process_info.recovery_stages = ['immediate', '5min_delay', 'final_attempt']
                            
                            self.log(f"🔧 {process_name} 3단계 복구 시스템 설정 완료")
                        
                    except Exception as e:
                        self.log(f"⚠️ {process_name} 복구 시스템 설정 실패: {e}")
            
            # 4. 통합 완료 처리
            integration_end_time = datetime.now()
            integration_duration = (integration_end_time - integration_start_time).total_seconds()
            
            success_count = len(migrated_processes)
            failure_count = len(failed_migrations)
            
            self.log(f"📊 v2 프로세스 생명주기 통합 완료:")
            self.log(f"  ✅ 성공: {success_count}개 프로세스")
            self.log(f"  ❌ 실패: {failure_count}개 프로세스")
            self.log(f"  ⏱️ 소요시간: {integration_duration:.2f}초")
            
            if success_count > 0:
                # 통합 성공 알림
                if self.v3_0_components['notification_manager']:
                    integration_details = {
                        'migrated_processes': migrated_processes,
                        'failed_migrations': failed_migrations,
                        'integration_time': integration_duration,
                        'recovery_system_enabled': True
                    }
                    self.v3_0_components['notification_manager'].send_integration_success_notification(integration_details)
                else:
                    # 기존 방식 알림
                    self.send_notification(
                        f"🔄 POSCO WatchHamster v3.0.0 프로세스 생명주기 통합 완료/n/n"
                        f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"✅ 통합 성공: {success_count}개 프로세스/n"
                        f"❌ 통합 실패: {failure_count}개 프로세스/n"
                        f"⏱️ 소요시간: {integration_duration:.2f}초/n"
                        f"🛡️ 3단계 지능적 복구 시스템 활성화됨/n"
                        f"🎯 향상된 프로세스 관리 시스템이 준비되었습니다."
                    )
                
                return True
            else:
                # 통합 실패
                self.log("❌ v2 프로세스 생명주기 통합 실패 - 모든 프로세스 마이그레이션 실패")
                return False
                
        except Exception as e:
            self.log(f"❌ v2 프로세스 생명주기 통합 오류: {e}")
            import traceback
            self.log(f"❌ 상세 오류: {traceback.format_exc()}")
            return False
    
    def _identify_process_name(self, process_obj):
        """
        프로세스 객체에서 프로세스 이름 식별
        
        Args:
            process_obj: 프로세스 객체
            
        Returns:
            str: 프로세스 이름 또는 None
        """
        try:
            if hasattr(process_obj, 'args') and process_obj.args:
                # 명령행 인수에서 스크립트 이름 추출
                script_path = process_obj.args[-1] if isinstance(process_obj.args, list) else str(process_obj.args)
                script_name = os.path.basename(script_path).replace('.py', '')
                
                # 알려진 프로세스 이름과 매칭
                known_processes = {
                    'posco_main_notifier': 'posco_main_notifier',
                    'realtime_news_monitor': 'realtime_news_monitor',
                    'integrated_report_scheduler': 'integrated_report_scheduler',
                    'historical_data_collector': 'historical_data_collector'
                }
                
                return known_processes.get(script_name, script_name)
            
            return None
            
        except Exception as e:
            self.log(f"⚠️ 프로세스 이름 식별 실패: {e}")
            return None
    
    def _migrate_existing_process_to_v3_0(self, process_name: str, process_obj):
        """
        기존 프로세스를 v2 ProcessManager로 마이그레이션
        
        Args:
            process_name (str): 프로세스 이름
            process_obj: 기존 프로세스 객체
        """
        try:
            # v2 ProcessManager에 기존 프로세스 등록
                        # REMOVED: 원본 코드
            
            # 기존 프로세스 정보를 v2 형식으로 변환
            process_info = ProcessInfo(
                name=process_name,
                pid=process_obj.pid,
                status=ProcessStatus.RUNNING if process_obj.poll() is None else ProcessStatus.STOPPED,
                start_time=datetime.now(),  # 정확한 시작 시간은 알 수 없으므로 현재 시간 사용
                last_health_check=datetime.now(),
                restart_count=0,
                last_error=None
            )
            
            # v2 ProcessManager에 등록
            self.v3_0_components['process_manager'].processes[process_name] = process_obj
            self.v3_0_components['process_manager'].process_info[process_name] = process_info
            
            self.log(f"📋 {process_name} v2 ProcessManager에 마이그레이션 완료 (PID: {process_obj.pid})")
            
        except Exception as e:
            self.log(f"❌ {process_name} v2 마이그레이션 실패: {e}")
            raise
    
    def _create_system_status_object_v3_0(self, current_time, health_results):
        """
        v2 NotificationManager용 시스템 상태 객체 생성
        
        Args:
            current_time (datetime): 현재 시간
            health_results (dict): 헬스체크 결과
            
        Returns:
            SystemStatus: 시스템 상태 객체
        """
        try:
            pass  # REMOVED
            from datetime import timedelta
            
            # 프로세스 상태 통계
            running_processes = sum(1 for is_healthy in health_results.values() if is_healthy)
            total_processes = len(health_results)
            failed_processes = total_processes - running_processes
            
            # 프로세스 상세 정보
            process_details = {}
            for process_name, is_healthy in health_results.items():
                if self.v3_0_components['process_manager']:
                    process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                    if process_info:
                        process_details[process_name] = {
                            'status': 'running' if is_healthy else process_info.status.value,
                            'pid': process_info.pid,
                            'restart_count': process_info.restart_count,
                            'cpu_usage': process_info.cpu_usage,
                            'memory_usage': process_info.memory_usage,
                            'last_error': process_info.last_error
                        }
                    else:
                        process_details[process_name] = {
                            'status': 'running' if is_healthy else 'unknown',
                            'pid': None,
                            'restart_count': 0,
                            'cpu_usage': 0.0,
                            'memory_usage': 0.0,
                            'last_error': None
                        }
            
            # 시스템 메트릭
            system_metrics = {}
            if self.v3_0_components['process_manager']:
                system_status = self.v3_0_components['process_manager'].get_system_status()
                system_metrics = system_status.get('system_metrics', {})
            
            # 다음 상태 보고 시간 계산
            next_hour = None
            for hour in range(current_time.hour + 1, 24):
                if hour >= self.status_notification_start_hour:
                    hour_diff = hour - self.status_notification_start_hour
                    if hour_diff % self.status_notification_interval_hours == 0:
                        next_hour = hour
                        break
            
            if next_hour is None:
                next_hour = self.status_notification_start_hour
            
            next_status_report = current_time.replace(hour=next_hour, minute=0, second=0, microsecond=0)
            
            return SystemStatus(
                timestamp=current_time,
                uptime=timedelta(seconds=0),  # 실제로는 시작 시간을 추적해야 함
                total_processes=total_processes,
                running_processes=running_processes,
                failed_processes=failed_processes,
                process_details=process_details,
                system_metrics=system_metrics,
                next_status_report=next_status_report
            )
            
        except Exception as e:
            self.log(f"❌ 시스템 상태 객체 생성 오류: {e}")
            # 기본 객체 반환
            from datetime import timedelta
            return type('SystemStatus', (), {
                'timestamp': current_time,
                'uptime': timedelta(0),
                'total_processes': len(health_results),
                'running_processes': sum(1 for is_healthy in health_results.values() if is_healthy),
                'failed_processes': len(health_results) - sum(1 for is_healthy in health_results.values() if is_healthy),
                'process_details': {},
                'system_metrics': {},
                'next_status_report': None
            })()
        
    def log(self, message):
        """
        로그 메시지 기록
        
        콘솔과 로그 파일에 타임스탬프와 함께 메시지를 기록합니다.
        Windows 콘솔 인코딩 문제를 해결합니다.
        
        Args:
            message (str): 기록할 로그 메시지
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"[{timestamp}] {message}"
        
        # Windows 콘솔 출력 시 인코딩 문제 해결 + 즉시 출력
        try:
print(log_message,_flush = True)  # flush=True로 즉시 출력
        except UnicodeEncodeError:
            # 콘솔에서 한글 출력 실패 시 영어로 대체
            safe_message = message.encode('ascii', 'ignore').decode('ascii')
            print(f"[{timestamp}] {safe_message}", flush=True)
        
        # 로그 파일에는 항상 UTF-8로 저장
        try:
with_open(self.log_file,_"a",_encoding = "utf-8") as f:
                f.write(log_message + "/n")
        except Exception as e:
            print(f"[ERROR] 로그 파일 쓰기 실패: {e}")
    
    def should_send_status_notification(self):
        """
        절대시간 기준 정기 상태 알림 필요 여부 체크
        
        Returns:
            bool: 알림이 필요하면 True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # 정각(0분)에만 체크 (1분 이내 오차 허용)
        if current_minute > 1:
            return False
        
        # 시작 시간부터 간격에 맞는 시간인지 체크
        if current_hour < self.status_notification_start_hour:
            return False
        
        # 간격 계산: (현재시간 - 시작시간) % 간격 == 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # 이미 이 시간에 알림을 보냈는지 체크
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
#_간격_계산:_(현재시간_-_시작시간)_%_간격 = = 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # 이미 이 시간에 알림을 보냈는지 체크
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
    def should_send_hourly_check(self):
        """
        매시간 정각 상태 체크 필요 여부 체크
        
        Returns:
            bool: 체크가 필요하면 True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # 정각(0분)에만 체크 (1분 이내 오차 허용)
        if current_minute > 1:
            return False
        
        # 이미 이 시간에 체크했는지 확인
        if self.last_hourly_check_hour != current_hour:
            return True
        
        return False
    
    def check_fixed_time_tasks(self):
        """
        고정 시간 작업들 체크 및 실행 - 워치햄스터는 뉴스 관련 고정 작업 없음
        """
        # 워치햄스터는 순수 시스템 관리만 담당
        # 뉴스 관련 고정 시간 작업은 realtime_news_monitor.py와 integrated_report_scheduler.py에서 처리
        pass
    
    def is_quiet_hours_old(self):
        """
        조용한 시간대 여부 체크 (18:00~05:59) - 사용 중단
        
        Returns:
            bool: 조용한 시간대면 True
        """
        current_hour = datetime.now().hour
return_current_hour_> =  18 or current_hour < 6
    
    def send_status_notification(self):
        """
        절대시간 기준 정기 상태 알림 전송 (7, 9, 11, 13, 15, 17, 19, 21, 23시)
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        
        try:
            # 모니터링 프로세스 상태 체크
            monitor_running = self.is_monitor_running()
            monitor_status = "🟢 정상 작동" if monitor_running else "🔴 중단됨"
            
            # 시스템 리소스 정보
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                resource_info = (
                    f"💻 CPU: {cpu_percent:.1f}% | "
                    f"🧠 메모리: {memory.percent:.1f}% | "
                    f"💾 디스크: {disk.percent:.1f}%"
                )
                resource_normal = cpu_percent < 80 and memory.percent < 85 and disk.percent < 90
            except:
                resource_info = "📊 시스템 정보 수집 실패"
                resource_normal = True
            
            # 다음 알림 시간 계산
            next_hour = None
            for hour in range(current_hour + 1, 24):
                if hour >= self.status_notification_start_hour:
                    hour_diff = hour - self.status_notification_start_hour
                    if hour_diff % self.status_notification_interval_hours == 0:
                        next_hour = hour
                        break
            
            if next_hour is None:
                next_hour = self.status_notification_start_hour
            
            # 조용한 시간대 구분하여 알림 전송
            if self.is_quiet_hours():
                # 조용한 시간대: 중요한 문제가 있을 때만 상세 알림
                has_problem = not monitor_running or not resource_normal
                
                if has_problem:
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("❌ 모니터링 프로세스 중단")
                    if not resource_normal:
                        problem_details.append("❌ 시스템 리소스 임계값 초과")
                    
                    self.send_notification(
                        f"🚨 POSCO 워치햄스터 정기 보고 - 중요 문제 감지\n\n"
                        f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"🚨 감지된 문제:\n" + "\n".join(f"   • {problem}" for problem in problem_details) + "\n\n"
                        f"🔍 상세 상태:\n"
                        f"   • 모니터링: {monitor_status}\n"
                        f"   • {resource_info}\n\n"
                        f"⏰ 다음 보고: {next_hour:02d}:00\n"
                        f"🔧 자동 복구 시도 중...",
                        is_error=True
                    )
                    self.log(f"🚨 조용한 시간대 정기 보고 중요 문제 알림 전송 ({current_hour}시)")
                else:
                    # 정상 상태: 간단한 알림
                    self.send_notification(
                        f"🌙 POSCO 워치햄스터 정기 보고 (조용한 시간)\n\n"
                        f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"🔍 모니터링: {monitor_status}\n"
                        f"📊 {resource_info}\n"
                        f"⏰ 다음 보고: {next_hour:02d}:00"
                    )
                    self.log(f"🌙 조용한 시간대 정기 보고 전송 ({current_hour}시)")
            else:
                # 일반 시간대: v2 향상된 상태 보고 사용
                self.send_status_report_v2()
                self.log(f"🐹 정기 상태 보고 전송 완료 ({current_hour}시)")
                
        except Exception as e:
            self.log(f"❌ 정기 상태 보고 실패: {e}")
            self.send_notification(
                f"❌ POSCO 워치햄스터 정기 보고 오류\n\n"
                f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"❌ 오류: {str(e)}\n"
                f"🔧 수동 확인이 필요합니다.",
                is_error=True
            )
    
    def check_scheduled_tasks(self):
        """
        기존 스케줄된 작업들 체크 (기존 로직 유지)
        """
        # 기존 스케줄 작업 로직이 있다면 여기에 유지
        # 현재는 절대시간 기준 시스템으로 대체되었으므로 빈 함수로 유지
        pass

    def send_notification(self, message, is_error=False):
        """
        Dooray 알림 전송 - v2 통합 아키텍처
        
        v2 NotificationManager 사용 가능 시 해당 컴포넌트를 사용하고,
        실패 시 기존 방식으로 폴백합니다.
        
        Args:
            message (str): 전송할 메시지
            is_error (bool): 오류 알림 여부 (색상과 봇명 변경)
        """
        try:
            # v2 NotificationManager 사용 시도
            if self.v2_enabled and self.v2_components['notification_manager']:
                success = self.v2_components['notification_manager'].send_notification(message, is_error)
                if success:
                    return
                else:
                    self.log("⚠️ v2 NotificationManager 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백
            color = "#ff4444" if is_error else "#28a745"
            bot_name = "POSCO 워치햄스터 ❌" if is_error else "POSCO 워치햄스터 🐹🛡️"
            
            payload = {
                "botName": bot_name,
                "botIconImage": BOT_PROFILE_IMAGE_URL,
                "text": message.split('\n')[0],
                "attachments": [{
                    "color": color,
                    "text": message
                }]
            }
            
            response = requests.post(
                WATCHHAMSTER_WEBHOOK_URL,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                self.log(f"✅ 알림 전송 성공: {message.split(chr(10))[0]}")
            else:
                self.log(f"❌ 알림 전송 실패: {response.status_code}")
                
        except Exception as e:
            self.log(f"❌ 알림 전송 오류: {e}")
    
    def send_startup_notification_v3_0(self):
        """
        v2 시작 알림 전송 - 기존 텍스트 보존하면서 v2 컴포넌트 정보 포함
        
        Requirements: 4.1, 4.2
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManager의 구조화된 시작 알림 사용
                success = self.v3_0_components['notification_manager'].send_startup_notification(
                    self.managed_processes
                )
                if success:
                    self.log("✅ v2 시작 알림 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 시작 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 완전 보존)
            current_time = datetime.now()
            message = f"🐹 POSCO WatchHamster v3.0 시작/n/n"
            message += f"📅 시작 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"🛡️ 관리 대상 프로세스: {len(self.managed_processes)}개/n/n"
            
            message += f"📊 관리 중인 모듈:/n"
            for process in self.managed_processes:
                descriptions = {
                    'POSCO News 250808 알림',
                    'realtime_news_monitor': '실시간 모니터링',
                    'integrated_report_scheduler': '리포트 스케줄러',
                    'historical_data_collector': '데이터 수집기'
                }
                desc = descriptions.get(process, process)
                message += f"  ✅ {process} ({desc})/n"
            
            # v2 컴포넌트 상태 추가 (v2 활성화 시에만)
            if self.v3_0_enabled:
                message += f"/n🔧 v2 아키텍처 상태:/n"
                for component_name, component in self.v3_0_components.items():
                    status = "✅ 활성화" if component else "❌ 비활성화"
                    message += f"  • {component_name}: {status}/n"
            
            message += f"/n🔄 모니터링 설정:/n"
            message += f"  • 헬스체크: 5분 간격/n"
            message += f"  • 상태 보고: 2시간 간격/n"
            message += f"  • 자동 복구: 활성화/n"
            message += f"  • Git 업데이트: 60분 간격/n/n"
            message += f"🚀 전체 시스템이 정상적으로 초기화되었습니다."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"❌ 시작 알림 전송 오류: {e}")
    
    def send_status_report_v3_0(self):
        """
        v2 정기 상태 보고 - v2 컴포넌트 정보를 포함한 향상된 상태 보고
        
        Requirements: 4.2, 4.3
        """
        try:
            current_time = datetime.now()
            
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 시스템 상태 정보 수집
                system_status = self._collect_v2_system_status()
                
                # v2 NotificationManager의 구조화된 상태 보고 사용
                success = self.v3_0_components['notification_manager'].send_status_report(system_status)
                if success:
                    self.log("✅ v2 상태 보고 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 상태 보고 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존하면서 v2 정보 추가)
            message = f"📊 POSCO WatchHamster v3.0 정기 상태 보고/n/n"
            message += f"📅 보고 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            
            # 가동 시간 계산
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
hours,_remainder =  divmod(int(uptime.total_seconds()), 3600)
minutes,__ =  divmod(remainder, 60)
                message += f"⏱️ 가동 시간: {hours}시간 {minutes}분/n/n"
            
            # 프로세스 상태 확인
            running_processes = []
            failed_processes = []
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    running_processes.append(process_name)
                else:
                    failed_processes.append(process_name)
            
            # 프로세스 상태 보고
            if not failed_processes:
                message += f"🟢 정상 프로세스 ({len(running_processes)}/{len(self.managed_processes)}):/n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  ✅ {process} - 정상 (PID: {pid})/n"
            else:
                message += f"🟢 정상 프로세스 ({len(running_processes)}/{len(self.managed_processes)}):/n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  ✅ {process} - 정상 (PID: {pid})/n"
                
                message += f"/n🟡 문제 프로세스 ({len(failed_processes)}/{len(self.managed_processes)}):/n"
                for process in failed_processes:
                    message += f"  ❌ {process} - 중지됨/n"
            
            # v2 컴포넌트 상태 추가
            if self.v3_0_enabled:
                message += f"/n🔧 v2 아키텍처 상태:/n"
                for component_name, component in self.v3_0_components.items():
                    if component:
                        # 컴포넌트별 상태 정보
                        if component_name == 'notification_manager':
                            stats = component.get_notification_stats()
                            message += f"  ✅ {component_name}: 활성화 (알림: {stats.get('total_notifications', 0)}회)/n"
                        elif component_name == 'module_registry':
                            modules = component.list_modules()
                            message += f"  ✅ {component_name}: 활성화 (모듈: {len(modules)}개)/n"
                        else:
                            message += f"  ✅ {component_name}: 활성화/n"
                    else:
                        message += f"  ❌ {component_name}: 비활성화/n"
            
            # 시스템 성능 정보
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_percent = psutil.virtual_memory().percent
                disk_percent = psutil.disk_usage('/').percent
                
                message += f"/n📈 시스템 성능:/n"
                message += f"  • CPU 사용률: {cpu_percent:.0f}%/n"
                message += f"  • 메모리 사용률: {memory_percent:.0f}%/n"
                message += f"  • 디스크 사용률: {disk_percent:.0f}%/n"
            except ImportError:
                message += f"/n📈 시스템 성능: 정보 수집 불가 (psutil 필요)/n"
            
            # 다음 보고 시간
            next_report_time = current_time + timedelta(hours=self.status_notification_interval_hours)
            message += f"/n🔄 다음 상태 보고: {next_report_time.strftime('%H:%M')}"
            
            # 색상 결정 (문제가 있으면 주황색, 없으면 녹색)
            is_error = len(failed_processes) > 0
            self.send_notification(message, is_error)
            
        except Exception as e:
            self.log(f"❌ 상태 보고 전송 오류: {e}")
    
    def send_process_error_v3_0(self, process_name, error_details):
        """
        v2 프로세스 오류 알림 - 구조화된 오류 정보 포함
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): 프로세스 이름
            error_details (dict): 오류 상세 정보
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManager의 구조화된 오류 알림 사용
                success = self.v3_0_components['notification_manager'].send_process_error(
                    process_name, error_details
                )
                if success:
                    self.log(f"✅ v2 프로세스 오류 알림 전송 완료: {process_name}")
                    return
                else:
                    self.log("⚠️ v2 프로세스 오류 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존)
            current_time = datetime.now()
            message = f"❌ POSCO WatchHamster v3.0 프로세스 오류/n/n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"🔧 문제 프로세스: {process_name}/n/n"
            
            # 오류 정보
            error_msg = error_details.get('error_message', '알 수 없는 오류')
            message += f"❌ 오류 내용: {error_msg}/n"
            
            # 재시작 시도 정보
            restart_count = error_details.get('restart_count', 0)
            max_attempts = error_details.get('max_attempts', 3)
            
            if restart_count > 0:
                message += f"🔄 재시작 시도: {restart_count}/{max_attempts}회/n"
            
            # 자동 복구 상태
            auto_recovery = error_details.get('auto_recovery_enabled', True)
            if auto_recovery and restart_count < max_attempts:
                message += f"/n🔧 자동 복구 시도 중..."
            elif restart_count >= max_attempts:
                message += f"/n🚨 최대 재시작 횟수 초과 - 수동 개입 필요"
            else:
                message += f"/n⚠️ 자동 복구 비활성화 - 수동 확인 필요"
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"❌ 프로세스 오류 알림 전송 오류: {e}")
    
    def send_recovery_success_v3_0(self, process_name, recovery_details):
        """
        v2 복구 성공 알림 - 복구 단계와 상세 정보 포함
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): 프로세스 이름
            recovery_details (dict): 복구 상세 정보
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManager의 구조화된 복구 알림 사용
                success = self.v3_0_components['notification_manager'].send_recovery_success(
                    process_name, recovery_details
                )
                if success:
                    self.log(f"✅ v2 복구 성공 알림 전송 완료: {process_name}")
                    return
                else:
                    self.log("⚠️ v2 복구 성공 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존)
            current_time = datetime.now()
            message = f"✅ POSCO WatchHamster v3.0 프로세스 복구 완료/n/n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"🔧 복구된 프로세스: {process_name}/n/n"
            
            # 복구 정보
            recovery_stage = recovery_details.get('recovery_stage', '알 수 없음')
            recovery_time = recovery_details.get('recovery_time', 0)
            
            message += f"🔄 복구 단계: {recovery_stage}/n"
            if recovery_time > 0:
                message += f"⏱️ 복구 소요 시간: {recovery_time}초/n"
            
            # 새 프로세스 정보
            new_pid = recovery_details.get('new_pid')
            if new_pid:
                message += f"🆔 새 프로세스 ID: {new_pid}/n"
            
            message += f"/n🚀 프로세스가 정상적으로 복구되어 모니터링을 재개합니다."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"❌ 복구 성공 알림 전송 오류: {e}")
    
    def send_critical_alert_v3_0(self, alert_message, additional_info=None):
        """
        v2 긴급 알림 - 구조화된 긴급 상황 알림
        
        Requirements: 4.4
        
        Args:
            alert_message (str): 긴급 알림 메시지
            additional_info (dict): 추가 정보
        """
        try:
            if self.v3_0_enabled and self.v3_0_components['notification_manager']:
                # v2 NotificationManager의 구조화된 긴급 알림 사용
                success = self.v3_0_components['notification_manager'].send_critical_alert(
                    alert_message, additional_info or {}
                )
                if success:
                    self.log("✅ v2 긴급 알림 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 긴급 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백
            current_time = datetime.now()
            message = f"🚨 POSCO WatchHamster v3.0 긴급 알림/n/n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
            message += f"🚨 긴급 상황: {alert_message}/n/n"
            
            if additional_info:
                message += f"📋 추가 정보:/n"
                for key, value in additional_info.items():
                    message += f"  • {key}: {value}/n"
                message += "/n"
            
            message += f"🔧 즉시 수동 확인이 필요합니다."
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"❌ 긴급 알림 전송 오류: {e}")
    
    def _collect_v2_system_status(self):
        """
        v2 시스템 상태 정보 수집
        
        Returns:
            SystemStatus: v2 NotificationManager용 시스템 상태 객체
        """
        try:
            # v2 NotificationManager의 SystemStatus 클래스 import
            import importlib.util
            v2_path = os.path.join(os.path.dirname(self.script_dir), 'WatchHamster_v3.0')
            module_path = os.path.join(v2_path, 'core', 'Monitoring/WatchHamster_v3.0/core/notification_manager.py')
            spec = importlib.util.spec_from_file_location("notification_manager", module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            SystemStatus = getattr(module, 'SystemStatus')
            
            current_time = datetime.now()
            
            # 가동 시간 계산
            uptime = timedelta(0)
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
            
            # 프로세스 상태 수집
            process_details = {}
            running_count = 0
            failed_count = 0
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    process_details[process_name] = {
                        'status': 'running',
                        'pid': self._get_process_pid(process_name),
                        'restart_count': 0
                    }
running_count_+ =  1
                else:
                    process_details[process_name] = {
                        'status': 'stopped',
                        'pid': None,
                        'restart_count': 0
                    }
failed_count_+ =  1
            
            # 시스템 메트릭 수집
            system_metrics = {}
            try:
                import psutil
                system_metrics = {
'cpu_percent':_psutil.cpu_percent(interval = 1),
                    'memory_percent': psutil.virtual_memory().percent,
                    'disk_percent': psutil.disk_usage('/').percent
                }
            except ImportError:
                system_metrics = {
                    'cpu_percent': 0,
                    'memory_percent': 0,
                    'disk_percent': 0
                }
            
            # 다음 상태 보고 시간
            next_status_report = current_time + timedelta(hours=self.status_notification_interval_hours)
            
            return SystemStatus(
                timestamp=current_time,
                uptime=uptime,
                total_processes=len(self.managed_processes),
                running_processes=running_count,
                failed_processes=failed_count,
                process_details=process_details,
                system_metrics=system_metrics,
                last_git_update=getattr(self, 'last_git_check', None),
                next_status_report=next_status_report
            )
            
        except Exception as e:
            self.log(f"❌ v2 시스템 상태 수집 오류: {e}")
            return None
    
    def _is_process_running(self, process_name):
        """
        프로세스 실행 상태 확인
        
        Args:
            process_name (str): 프로세스 이름
            
        Returns:
            bool: 실행 중이면 True
        """
        try:
            import psutil
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info['cmdline'] or [])
                    if process_name in cmdline:
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return False
        except ImportError:
            # psutil이 없으면 기본 방식 사용
            try:
                result = subprocess.run(['pgrep', '-f', process_name], 
                                      capture_output=True, text=True)
return_result.returncode = = 0
            except:
                return False
    
    def _get_process_pid(self, process_name):
        """
        프로세스 PID 조회
        
        Args:
            process_name (str): 프로세스 이름
            
        Returns:
            int or str: PID 또는 'N/A'
        """
        try:
            import psutil
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    cmdline = ' '.join(proc.info['cmdline'] or [])
                    if process_name in cmdline:
                        return proc.info['pid']
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            return 'N/A'
        except ImportError:
            # psutil이 없으면 기본 방식 사용
            try:
                result = subprocess.run(['pgrep', '-f', process_name], 
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip().split('/n')[0]
                return 'N/A'
            except:
                return 'N/A'
    
    def check_git_updates(self):
        """
        Git 저장소 업데이트 체크
        
        원격 저장소와 로컬 저장소를 비교하여 업데이트가 있는지 확인합니다.
        
        Returns:
            bool: 업데이트가 있으면 True, 없으면 False
        """
        try:
            # 원격 저장소 정보 가져오기
            result = subprocess.run(
                ['git', 'fetch', 'origin'],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode != 0:
                self.log(f"⚠️ Git fetch 실패: {result.stderr}")
                return False
            
            # 로컬과 원격 비교
            result = subprocess.run(
                ['git', 'rev-list', 'HEAD..origin/main', '--count'],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                commit_count = int(result.stdout.strip())
                if commit_count > 0:
                    self.log(f"🔄 Git 업데이트 발견: {commit_count}개 커밋")
                    return True
                else:
                    self.log("📋 Git 업데이트 없음")
                    return False
            else:
                self.log(f"⚠️ Git 비교 실패: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            self.log("⚠️ Git 체크 타임아웃")
            return False
        except Exception as e:
            self.log(f"❌ Git 체크 오류: {e}")
            return False
    
    def apply_git_update(self):
        """Git 업데이트 적용 - 성능 최적화"""
        try:
            self.log("🔄 Git 업데이트 적용 중...")
            
            # 현재 프로세스 중지
            self.stop_monitor_process()
            
            # 로컬 변경사항이 있는지 확인
            status_result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if status_result.stdout.strip():
                # 로컬 변경사항이 있으면 stash
                subprocess.run(
                    ["git", "stash", "push", "-m", "WatchHamster auto stash"],
                    cwd=self.script_dir,
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                self.log("📦 로컬 변경사항 임시 저장")
            
            # Git pull 실행 (안전한 방식)
            result = subprocess.run(
                ["git", "pull", "origin", "main", "--allow-unrelated-histories"],
                cwd=self.script_dir,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                self.log("✅ Git 업데이트 성공")
                self.send_notification(
                    f"🔄 POSCO 모니터 Git 업데이트 완료/n/n"
                    f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                    f"📝 변경사항: {result.stdout.strip()}/n"
                    f"🚀 모니터링 재시작 중..."
                )
                
                # 모니터링 프로세스 재시작
                time.sleep(3)
                if self.start_monitor_process():
                    self.send_notification(
                        f"✅ POSCO 모니터 업데이트 후 재시작 완료/n/n"
                        f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"🔄 최신 코드로 모니터링 재개됨"
                    )
                else:
                    self.send_notification(
                        f"❌ POSCO 모니터 업데이트 후 재시작 실패/n/n"
                        f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"🔧 수동 확인이 필요합니다.",
                        is_error=True
                    )
            else:
                self.log(f"❌ Git 업데이트 실패: {result.stderr}")
                self.send_notification(
                    f"❌ POSCO 모니터 Git 업데이트 실패/n/n"
                    f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                    f"❌ 오류: {result.stderr.strip()}/n"
                    f"🔧 수동 확인이 필요합니다.",
                    is_error=True
                )
                
                # 실패 시 모니터링 프로세스 재시작
                self.start_monitor_process()
                
        except subprocess.TimeoutExpired:
            self.log("❌ Git 업데이트 타임아웃")
            self.start_monitor_process()
        except Exception as e:
            self.log(f"❌ Git 업데이트 오류: {e}")
            self.start_monitor_process()
    
    def is_monitor_running(self):
        """모니터링 프로세스 실행 상태 확인 - v2 통합 아키텍처"""
        try:
            if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                # v2 아키텍처 사용
                running_count = 0
                total_count = 0
                
                for process_name in self.managed_processes:
                    module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                    if module_config and module_config.auto_start:
total_count_+ =  1
                        if self.v3_0_components['process_manager'].is_process_running(process_name):
running_count_+ =  1
                
                # 모든 자동 시작 프로세스가 실행 중이어야 정상
return_running_count = = total_count and total_count > 0
            else:
                # 기존 방식으로 폴백
                # 통합 리포트 스케줄러 확인
                scheduler_running = False
                if self.monitor_process and self.monitor_process.poll() is None:
                    scheduler_running = True
                else:
                    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                        try:
                            if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                                cmdline = proc.info['cmdline']
                                if cmdline and 'integrated_report_scheduler.py' in ' '.join(cmdline):
                                    scheduler_running = True
                                    break
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            continue
                
                # 실시간 뉴스 모니터 확인
                realtime_running = False
                if self.realtime_process and self.realtime_process.poll() is None:
                    realtime_running = True
                else:
                    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                        try:
                            if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                                cmdline = proc.info['cmdline']
                                if cmdline and 'realtime_news_monitor.py' in ' '.join(cmdline):
                                    realtime_running = True
                                    break
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            continue
                
                # 둘 다 실행 중이어야 정상
                return scheduler_running and realtime_running
            
        except Exception as e:
            self.log(f"❌ 프로세스 상태 확인 오류: {e}")
            return False
    
    # 새로운 아키텍처 프로세스 관리 메서드들
    def start_all_processes(self) -> bool:
        """
        모든 관리 대상 프로세스 시작 - v2 통합 아키텍처
        
        v2 컴포넌트 사용 가능 시 모듈 레지스트리의 시작 순서에 따라 프로세스를 시작하고,
        실패 시 기존 방식으로 폴백합니다.
        
        Returns:
            bool: 모든 프로세스 시작 성공 여부
        """
        # 성능 측정 시작
        with self.measure_operation_performance("start_all_processes"):
            try:
                self.log("🚀 모든 프로세스 시작 중...")
                
                if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                    # v2 아키텍처 사용
                    return self._start_processes_v2()
                else:
                    # 기존 방식으로 폴백
                    self.log("📋 기존 방식으로 프로세스 시작")
                    return self.start_monitor_process()
                    
            except Exception as e:
                self.log(f"❌ 모든 프로세스 시작 오류: {e}")
                return False
    
    def _start_processes_v3_0(self) -> bool:
        """
        v2 아키텍처를 사용한 프로세스 시작
        
        v2 ProcessManager와 ModuleRegistry를 사용하여 의존성 순서에 따라
        프로세스를 시작하고 생명주기를 관리합니다.
        
        구현 내용:
        - ModuleRegistry에서 의존성 순서 조회
        - ProcessManager를 사용한 프로세스 시작
        - 프로세스별 상태 추적 및 검증
        - 시작 실패 시 자동 복구 시도
        
        Returns:
            bool: 시작 성공 여부
        """
        try:
            success_count = 0
            failed_processes = []
            startup_start_time = datetime.now()
            
            self.log("🚀 v2 아키텍처를 사용한 프로세스 시작 시작")
            
            # 의존성 순서에 따라 프로세스 시작
            startup_order = self.v3_0_components['module_registry'].get_modules_by_dependency_order()
            total_count = len([p for p in startup_order if p in self.managed_processes])
            
            self.log(f"📋 시작 순서: {' → '.join(startup_order)}")
            self.log(f"🎯 관리 대상 프로세스: {total_count}개")
            
            for process_name in startup_order:
                if process_name not in self.managed_processes:
                    continue
                
                # 모듈 설정 조회
                module_config = self.v3_0_components['module_registry'].get_module_config(process_name)
                if not module_config:
                    self.log(f"❌ {process_name}: 모듈 설정을 찾을 수 없습니다")
                    failed_processes.append(process_name)
                    continue
                
                if not module_config.auto_start:
                    self.log(f"⏭️ {process_name}: 자동 시작 비활성화, 건너뜀")
                    continue
                
                self.log(f"🔄 {process_name} 시작 중... (우선순위: {module_config.priority})")
                
                # v2 ProcessManager를 사용한 프로세스 시작
                process_start_time = datetime.now()
                
                start_success = self.v3_0_components['process_manager'].start_process(
                    process_name, 
                    module_config.script_path, 
                    getattr(module_config, 'args', []),
                    module_config.working_directory
                )
                
                process_start_duration = (datetime.now() - process_start_time).total_seconds()
                
                if start_success:
                    # 프로세스 시작 성공
                    process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
success_count_+ =  1
                    
                    self.log(f"✅ {process_name} 시작 성공 (PID: {process_info.pid if process_info else 'N/A'}, 소요시간: {process_start_duration:.1f}초)")
                    
                    # 모듈 상태 업데이트
                    try:
            pass  # REMOVED
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.ACTIVE)
                        self.log(f"📋 {process_name} 모듈 상태를 ACTIVE로 업데이트")
                    except Exception as e:
                        self.log(f"⚠️ {process_name} 모듈 상태 업데이트 실패: {e}")
                    
                    # 프로세스 초기화 대기 (의존성 고려)
                    if hasattr(module_config, 'startup_delay'):
                        startup_delay = module_config.startup_delay
                    else:
                        startup_delay = 3  # 기본 3초 대기
                    
                    self.log(f"⏳ {process_name} 초기화 대기 중... ({startup_delay}초)")
                    time.sleep(startup_delay)
                    
                    # 프로세스 상태 재확인
                    if not self.v3_0_components['process_manager'].is_process_running(process_name):
                        self.log(f"⚠️ {process_name} 시작 후 즉시 종료됨, 복구 시도")
                        # 즉시 복구 시도
                        recovery_success = self.v3_0_components['process_manager'].restart_process(process_name)
                        if not recovery_success:
                            failed_processes.append(process_name)
success_count_- =  1
                            self.log(f"❌ {process_name} 복구 실패")
                
                else:
                    # 프로세스 시작 실패
                    failed_processes.append(process_name)
                    self.log(f"❌ {process_name} 시작 실패 (소요시간: {process_start_duration:.1f}초)")
                    
                    # 모듈 상태 업데이트
                    try:
            pass  # REMOVED
                        self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.FAILED)
                        self.log(f"📋 {process_name} 모듈 상태를 FAILED로 업데이트")
                    except Exception as e:
                        self.log(f"⚠️ {process_name} 모듈 상태 업데이트 실패: {e}")
                
                # 프로세스 간 시작 간격 (의존성 고려)
                time.sleep(1)
            
            # 전체 시작 완료 시간 계산
            total_startup_time = (datetime.now() - startup_start_time).total_seconds()
            
            # 결과 보고 및 알림
            if success_count == total_count:
                self.log(f"🎉 모든 프로세스 시작 완료! ({success_count}/{total_count}, 총 소요시간: {total_startup_time:.1f}초)")
                
                # v2 NotificationManager를 사용한 시작 알림 전송
                # v2 향상된 시작 알림 사용
                self.send_startup_notification_v2()
                
                return True
                
            elif success_count > 0:
                self.log(f"⚠️ 일부 프로세스만 시작됨 ({success_count}/{total_count}, 실패: {len(failed_processes)}개)")
                
                # 부분 성공 시에도 v2 향상된 시작 알림 사용 (실패 정보 포함)
                self.send_startup_notification_v2()
                
                return True  # 일부라도 성공하면 True 반환
                
            else:
                self.log(f"❌ 모든 프로세스 시작 실패 ({success_count}/{total_count})")
                
                # 전체 실패 알림
                if self.v3_0_components['notification_manager']:
                    self.v3_0_components['notification_manager'].send_critical_alert(
                        "POSCO WatchHamster v3.0 시작 실패",
                        {
                            '총_프로세스': f'{total_count}개',
                            '실패한_프로세스': ', '.join(failed_processes),
                            '소요시간': f'{total_startup_time:.1f}초',
                            '필요_조치': '수동 확인 및 재시작'
                        }
                    )
                else:
                    # 기존 방식으로 폴백
                    self.send_notification(
                        f"🚨 POSCO WatchHamster v3.0 시작 실패/n/n"
                        f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"❌ 모든 프로세스 시작 실패 ({total_count}개)/n"
                        f"🔍 실패한 프로세스: {', '.join(failed_processes)}/n"
                        f"⏱️ 소요시간: {total_startup_time:.1f}초/n"
                        f"🛠️ 수동 확인 및 재시작이 필요합니다.",
                        is_error=True
                    )
                
                return False
                
        except Exception as e:
            self.log(f"❌ v2 프로세스 시작 오류: {e}")
            import traceback
            self.log(f"❌ 상세 오류: {traceback.format_exc()}")
            return False
    
    def stop_all_processes(self) -> bool:
        """
        모든 관리 대상 프로세스 중지 - v2 통합 아키텍처
        
        v2 컴포넌트 사용 가능 시 의존성 순서를 고려하여 프로세스를 중지하고,
        실패 시 기존 방식으로 폴백합니다.
        
        Returns:
            bool: 모든 프로세스 중지 성공 여부
        """
        try:
            self.log("🛑 모든 프로세스 중지 중...")
            
            if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                # v2 아키텍처 사용
                return self._stop_processes_v2()
            else:
                # 기존 방식으로 폴백
                self.log("📋 기존 방식으로 프로세스 중지")
                self.stop_monitor_process()
                return True
                
        except Exception as e:
            self.log(f"❌ 모든 프로세스 중지 오류: {e}")
            return False
    
    def _stop_processes_v3_0(self) -> bool:
        """
        v2 아키텍처를 사용한 프로세스 중지
        
        Returns:
            bool: 중지 성공 여부
        """
        try:
            success_count = 0
            total_count = len(self.managed_processes)
            stopped_processes = []
            
            # 역순으로 프로세스 중지 (의존성 고려)
            shutdown_order = list(reversed(self.v3_0_components['module_registry'].get_modules_by_dependency_order()))
            
            for process_name in shutdown_order:
                if process_name not in self.managed_processes:
                    continue
                
                if self.v3_0_components['process_manager'].is_process_running(process_name):
                    self.log(f"⏹️ {process_name} 중지 중...")
                    
                    if self.v3_0_components['process_manager'].stop_process(process_name):
success_count_+ =  1
                        stopped_processes.append(process_name)
                        self.log(f"✅ {process_name} 중지 성공")
                        
                        # 모듈 상태 업데이트
                        try:
            pass  # REMOVED
                            self.v3_0_components['module_registry'].update_module_status(process_name, ModuleStatus.INACTIVE)
                        except ImportError:
                            pass  # 상태 업데이트 실패해도 계속 진행
                    else:
                        self.log(f"❌ {process_name} 중지 실패")
                else:
success_count_+ =  1  # 이미 중지된 프로세스
                    stopped_processes.append(process_name)
                    self.log(f"📋 {process_name}: 이미 중지됨")
                
                # 프로세스 간 중지 간격
                time.sleep(1)
            
            # 결과 보고
            if success_count == total_count:
                self.log(f"🎉 모든 프로세스 중지 완료! ({success_count}/{total_count})")
                
                # v2 NotificationManager를 사용한 종료 알림 전송
                if self.v3_0_components['notification_manager']:
                    shutdown_status = {
                        'uptime': datetime.now() - datetime.now(),  # 실제로는 시작 시간을 추적해야 함
                        'stopped_processes': stopped_processes,
                        'total_restarts': getattr(self.v3_0_components['process_manager'], 'total_restarts', 0)
                    }
                    self.v3_0_components['notification_manager'].send_shutdown_notification(shutdown_status)
                
                return True
            else:
                self.log(f"⚠️ 일부 프로세스만 중지됨 ({success_count}/{total_count})")
                return success_count > 0
                
        except Exception as e:
            self.log(f"❌ v2 프로세스 중지 오류: {e}")
            return False
    
    def restart_process(self, process_name: str) -> bool:
        """
        개별 프로세스 재시작
        
        Args:
            process_name (str): 재시작할 프로세스 이름
            
        Returns:
            bool: 재시작 성공 여부
        """
        try:
            if process_name not in self.managed_processes:
                self.log(f"❌ 알 수 없는 프로세스: {process_name}")
                return False
            
            self.log(f"🔄 {process_name} 재시작 중...")
            
            if not self.module_registry:
                # 기존 방식으로 폴백
                if process_name == 'integrated_report_scheduler':
                    self.stop_monitor_process()
                    time.sleep(3)
                    return self.start_monitor_process()
                else:
                    self.log(f"⚠️ 기존 방식에서는 {process_name} 개별 재시작 불가")
                    return False
            
            # Enhanced ProcessManager 사용
            success = self.process_manager.restart_process(process_name)
            
            if success:
                self.log(f"✅ {process_name} 재시작 성공")
                
                # 복구 알림 전송
                if self.notification_manager:
                    recovery_details = {
                        'recovery_stage': '개별 재시작',
                        'recovery_time': 5,  # 대략적인 시간
                        'new_pid': self.process_manager.get_process_info(process_name).pid if self.process_manager.get_process_info(process_name) else None
                    }
                    self.notification_manager.send_recovery_success(process_name, recovery_details)
            else:
                self.log(f"❌ {process_name} 재시작 실패")
                
                # 오류 알림 전송
                if self.notification_manager:
                    process_info = self.process_manager.get_process_info(process_name)
                    error_details = {
                        'error_message': process_info.last_error if process_info else '알 수 없는 오류',
                        'restart_count': process_info.restart_count if process_info else 0,
                        'max_attempts': 3,
                        'auto_recovery_enabled': True
                    }
                    self.notification_manager.send_process_error(process_name, error_details)
            
            return success
            
        except Exception as e:
            self.log(f"❌ {process_name} 재시작 오류: {e}")
            return False
    
    def get_process_status(self, process_name: str) -> dict:
        """
        개별 프로세스 상태 조회
        
        Args:
            process_name (str): 조회할 프로세스 이름
            
        Returns:
            dict: 프로세스 상태 정보
        """
        try:
            if process_name not in self.managed_processes:
                return {
                    'error': f'알 수 없는 프로세스: {process_name}',
                    'status': 'unknown'
                }
            
            if not self.module_registry:
                # 기존 방식으로 폴백
                is_running = self.is_monitor_running() if process_name in ['integrated_report_scheduler', 'realtime_news_monitor'] else False
                return {
                    'name': process_name,
                    'status': 'running' if is_running else 'stopped',
                    'pid': None,
                    'restart_count': 0,
                    'last_error': None
                }
            
            # Enhanced ProcessManager 사용
            process_info = self.process_manager.get_process_info(process_name)
            
            if process_info:
                return {
                    'name': process_info.name,
                    'status': process_info.status.value,
                    'pid': process_info.pid,
                    'start_time': process_info.start_time.isoformat() if process_info.start_time else None,
                    'last_health_check': process_info.last_health_check.isoformat(),
                    'restart_count': process_info.restart_count,
                    'last_error': process_info.last_error,
                    'cpu_usage': process_info.cpu_usage,
                    'memory_usage': process_info.memory_usage
                }
            else:
                return {
                    'name': process_name,
                    'status': 'not_found',
                    'error': '프로세스 정보를 찾을 수 없습니다'
                }
                
        except Exception as e:
            return {
                'name': process_name,
                'status': 'error',
                'error': str(e)
            }
    
    def get_all_process_status(self) -> dict:
        """
        모든 프로세스 상태 조회
        
        Returns:
            dict: 전체 시스템 상태 정보
        """
        try:
            if not self.module_registry:
                # 기존 방식으로 폴백
                monitor_running = self.is_monitor_running()
                return {
                    'timestamp': datetime.now().isoformat(),
                    'total_processes': len(self.managed_processes),
                    'running_processes': 2 if monitor_running else 0,
                    'failed_processes': 0 if monitor_running else len(self.managed_processes),
                    'processes': {
                        name: self.get_process_status(name) for name in self.managed_processes
                    }
                }
            
            # Enhanced ProcessManager 사용
            system_status = self.process_manager.get_system_status()
            
            # 프로세스별 상세 정보 추가
            process_details = {}
            for process_name in self.managed_processes:
                process_details[process_name] = self.get_process_status(process_name)
            
            system_status['processes'] = process_details
            return system_status
            
        except Exception as e:
            return {
                'timestamp': datetime.now().isoformat(),
                'error': str(e),
                'total_processes': len(self.managed_processes),
                'running_processes': 0,
                'failed_processes': len(self.managed_processes)
            }
    
    # 기존 메서드들과의 통합
    def start_monitor_process(self):
        """모니터링 프로세스 시작 (통합 리포트 + 실시간 모니터)"""
        try:
            if self.is_monitor_running():
                self.log("✅ 모니터링 프로세스가 이미 실행 중입니다.")
                return True
            
            self.log("🚀 모니터링 프로세스 시작 중...")
            
            success_count = 0
            
            # 1. 통합 리포트 스케줄러 실행
            try:
                if os.name == 'nt':  # Windows
                    self.monitor_process = subprocess.Popen(
                        [sys.executable, self.monitor_script],
                        cwd=self.script_dir,
                        creationflags=subprocess.CREATE_NEW_CONSOLE
                    )
                else:  # macOS/Linux
                    self.monitor_process = subprocess.Popen(
                        [sys.executable, self.monitor_script],
                        cwd=self.script_dir
                    )
                
                time.sleep(3)  # 프로세스 시작 대기
                
                if self.monitor_process.poll() is None:
                    self.log("✅ 통합 리포트 스케줄러 시작 성공")
success_count_+ =  1
                else:
                    self.log("❌ 통합 리포트 스케줄러 시작 실패")
                    
            except Exception as e:
                self.log(f"❌ 통합 리포트 스케줄러 시작 오류: {e}")
            
            # 2. 실시간 뉴스 모니터 실행
            try:
                if os.name == 'nt':  # Windows
                    self.realtime_process = subprocess.Popen(
                        [sys.executable, self.realtime_script],
                        cwd=self.script_dir,
                        creationflags=subprocess.CREATE_NEW_CONSOLE
                    )
                else:  # macOS/Linux
                    self.realtime_process = subprocess.Popen(
                        [sys.executable, self.realtime_script],
                        cwd=self.script_dir
                    )
                
                time.sleep(3)  # 프로세스 시작 대기
                
                if self.realtime_process.poll() is None:
                    self.log("✅ 실시간 뉴스 모니터 시작 성공")
success_count_+ =  1
                else:
                    self.log("❌ 실시간 뉴스 모니터 시작 실패")
                    
            except Exception as e:
                self.log(f"❌ 실시간 뉴스 모니터 시작 오류: {e}")
            
            # 결과 확인
            if success_count == 2:
                self.log("🎉 모든 모니터링 프로세스 시작 완료!")
                return True
            elif success_count == 1:
                self.log("⚠️ 일부 모니터링 프로세스만 시작됨")
                return True
            else:
                self.log("❌ 모든 모니터링 프로세스 시작 실패")
                return False
                
        except Exception as e:
            self.log(f"❌ 모니터링 프로세스 시작 오류: {e}")
            return False
    
    def stop_monitor_process(self):
        """모니터링 프로세스 중지 (통합 리포트 + 실시간 모니터)"""
        try:
            # 실행 중인 모든 관련 프로세스 종료
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] == 'python.exe' or proc.info['name'] == 'python':
                        cmdline = proc.info['cmdline']
                        if cmdline and ('integrated_report_scheduler.py' in ' '.join(cmdline) or 
                                       'realtime_news_monitor.py' in ' '.join(cmdline)):
                            proc.terminate()
                            script_name = "통합 리포트" if 'integrated_report_scheduler.py' in ' '.join(cmdline) else "실시간 모니터"
                            self.log(f"⏹️ {script_name} 프로세스 종료: PID {proc.info['pid']}")
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # 프로세스 객체 초기화
            if self.monitor_process:
                self.monitor_process = None
            if self.realtime_process:
                self.realtime_process = None
                
            time.sleep(2)
            self.log("✅ 모든 모니터링 프로세스 중지 완료")
            
        except Exception as e:
            self.log(f"❌ 모니터링 프로세스 중지 오류: {e}")
    
    # 뉴스 관련 스케줄 작업 제거 - 워치햄스터는 순수 시스템 관리만 담당
    # 뉴스 관련 기능은 realtime_news_monitor.py와 integrated_report_scheduler.py에서 처리
    
    # 뉴스 관련 실행 함수들 제거 - 워치햄스터는 순수 시스템 관리만 담당
    # 뉴스 관련 기능은 realtime_news_monitor.py와 integrated_report_scheduler.py에서 처리
    
    def execute_integrated_report_generation(self):
        """통합 리포트 생성 실행 (17:59)"""
        try:
            self.log("📊 통합 리포트 생성 시작")
            
            if self.integrated_scheduler_enabled:
                success = self.integrated_scheduler.generate_daily_report()
                if success:
    def execute_integrated_report_notification(self):
        """통합 리포트 알림 발송 실행 (18:00)"""
        try:
            # 조용한 시간대 체크
            if self.is_quiet_hours():
                self.log("🌙 조용한 시간대 - 통합 리포트 알림 발송 생략")
                return
            
            self.log("📨 통합 리포트 알림 발송 시작")
            
            if self.integrated_scheduler_enabled:
                success = self.integrated_scheduler.send_daily_report_notification()
                if success:
                    self.log("✅ 통합 리포트 알림 발송 완료")
                else:
                    self.log("❌ 통합 리포트 알림 발송 실패")
            else:
                self.log("⚠️ 통합 리포트 스케줄러 비활성화됨")
                
        except Exception as e:
            self.log(f"❌ 통합 리포트 알림 발송 오류: {e}")
    
                    self.log("✅ 통합 리포트 알림 발송 완료")
                else:
                    self.log("❌ 통합 리포트 알림 발송 실패")
            else:
                self.log("⚠️ 통합 리포트 스케줄러 비활성화됨")
                
        except Exception as e:
            self.log(f"❌ 통합 리포트 알림 발송 오류: {e}")
    
    def check_scheduled_tasks(self):
        """스케줄된 작업 체크 및 실행"""
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        today_key = current_time.strftime('%Y-%m-%d')
        
        # 매일 06:00 - 현재 상태 체크
        if current_hour == 6 and current_minute == 0:
            if self.last_scheduled_tasks['morning_status_check'] != today_key:
                self.execute_scheduled_task("1", "아침 현재 상태 체크")
                self.last_scheduled_tasks['morning_status_check'] = today_key
        
        # 매일 06:10 - 영업일 비교 분석
        if current_hour == 6 and current_minute == 10:
            if self.last_scheduled_tasks['morning_comparison'] != today_key:
                self.execute_scheduled_task("2", "아침 영업일 비교 분석")
                self.last_scheduled_tasks['morning_comparison'] = today_key
        
        # 매일 17:59 - 통합 리포트 생성
        if current_hour == 17 and current_minute == 59:
            if self.last_scheduled_tasks['integrated_report_generation'] != today_key:
                self.execute_integrated_report_generation()
                self.last_scheduled_tasks['integrated_report_generation'] = today_key
        
        # 매일 18:00 - 통합 리포트 알림 발송
        if current_hour == 18 and current_minute == 0:
            if self.last_scheduled_tasks['integrated_report_notification'] != today_key:
                self.execute_integrated_report_notification()
                self.last_scheduled_tasks['integrated_report_notification'] = today_key
            # 기존 일일 요약 리포트도 유지
            if self.last_scheduled_tasks['evening_daily_summary'] != today_key:
                self.execute_scheduled_task("5", "저녁 일일 요약 리포트")
                self.last_scheduled_tasks['evening_daily_summary'] = today_key
        
        # 매일 18:10 - 상세 일일 요약
        if current_hour == 18 and current_minute == 10:
            if self.last_scheduled_tasks['evening_detailed_summary'] != today_key:
                self.execute_scheduled_task("7", "저녁 상세 일일 요약")
                self.last_scheduled_tasks['evening_detailed_summary'] = today_key
        
        # 매일 18:20 - 고급 분석
        if current_hour == 18 and current_minute == 20:
            if self.last_scheduled_tasks['evening_advanced_analysis'] != today_key:
                self.execute_scheduled_task("8", "저녁 고급 분석")
                self.last_scheduled_tasks['evening_advanced_analysis'] = today_key
        
        # 매시간 정각 - 현재 상태 체크 (조용한 시간대 제외)
        if current_minute == 0 and not self.is_quiet_hours():
            hourly_key = f"{today_key}-{current_hour:02d}"
            if self.last_scheduled_tasks['hourly_status_check'] != hourly_key:
                self.execute_scheduled_task("1", f"정시 상태 체크 ({current_hour}시)")
                self.last_scheduled_tasks['hourly_status_check'] = hourly_key
    
    def is_quiet_hours(self):
        """조용한 시간대 체크 (19:01~05:59)"""
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # 19:01~23:59 또는 00:00~05:59
        if (current_hour == 19 and current_minute >= 1) or current_hour >= 20 or current_hour <= 5:
            return True
        return False
    
    def should_send_status_notification(self):
        """
        절대 시간 기준으로 정기 상태 알림을 보낼 시간인지 체크
        
        예: 7시 시작, 2시간 간격 → 7, 9, 11, 13, 15, 17시에 알림
        워치햄스터 시작 시간과 무관하게 절대 시간 기준으로 동작
        
        Returns:
            bool: 알림을 보낼 시간이면 True
        """
        current_time = datetime.now()
        current_hour = current_time.hour
        current_minute = current_time.minute
        
        # 정각(0분)에만 체크 (1분 이내 오차 허용)
        if current_minute > 1:
            return False
        
        # 시작 시간부터 간격에 맞는 시간인지 체크
        if current_hour < self.status_notification_start_hour:
            return False
        
#_간격_계산:_(현재시간_-_시작시간)_%_간격 = = 0
        hour_diff = current_hour - self.status_notification_start_hour
        if hour_diff % self.status_notification_interval_hours == 0:
            # 이미 이 시간에 알림을 보냈는지 체크
            if self.last_status_notification_hour != current_hour:
                return True
        
        return False
    
    def send_status_notification(self):
        """정기 상태 알림 전송 (2시간마다, 18시 이후는 조용한 모드) - 스마트 상태 판단 적용"""
        try:
            current_time = datetime.now()
            is_quiet = self.is_quiet_hours()
            
            # 모니터링 프로세스 상태 확인
            monitor_running = self.is_monitor_running()
            monitor_status = "🟢 정상 작동" if monitor_running else "🔴 중단됨"
            
            # 스마트 상태 판단 시스템 사용
            smart_status_info = None
            current_data = None
            
            if self.smart_enabled and monitor_running:
                try:
                    # 현재 뉴스 데이터 조회
                    current_data = self.api_client.get_news_data()
                    if current_data:
                        # 스마트 상태 분석
                        smart_status_info = self.data_processor.get_status_info(current_data)
                        self.log(f"🧠 스마트 상태 분석 완료: {smart_status_info.get('status_text', '알 수 없음')}")
                    else:
                        self.log("⚠️ 뉴스 데이터 조회 실패")
                except Exception as e:
                    self.log(f"⚠️ 스마트 상태 분석 실패: {e}")
            
            # API 상태 체크 개선 - 모니터링 프로세스가 실행 중이면 API도 정상으로 간주
            api_normal = True
            api_status = "🟢 API 정상"
            
            # 최적화된 모니터링 시스템으로 API 상태 체크
            if not monitor_running:
                try:
                    # 기존 run_monitor.py 대신 최적화된 개별 모니터 사용
                    if self.individual_monitors_enabled:
                        # 개별 모니터로 API 상태 확인
                        api_checks = []
                        
                        # 뉴욕마켓워치 API 체크
                        try:
                            ny_data = self.newyork_monitor.get_current_news_data()
                            api_checks.append(ny_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # 증시마감 API 체크  
                        try:
                            kospi_data = self.kospi_monitor.get_current_news_data()
                            api_checks.append(kospi_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # 서환마감 API 체크
                        try:
                            exchange_data = self.exchange_monitor.get_current_news_data()
                            api_checks.append(exchange_data is not None)
                        except:
                            api_checks.append(False)
                        
                        # API 상태 종합 판단
                        successful_checks = sum(api_checks)
                        total_checks = len(api_checks)
                        
                        if successful_checks == total_checks:
                            api_normal = True
                            api_status = "🟢 API 정상 (최적화 모니터 기반)"
                        elif successful_checks > 0:
                            api_normal = True
                            api_status = f"🟡 API 부분 정상 ({successful_checks}/{total_checks})"
                        else:
                            api_normal = False
                            api_status = "🔴 API 연결 실패"
                        
                        self.log(f"📡 최적화된 모니터로 API 상태 체크: {api_status}")
                    else:
                        # 개별 모니터 비활성화 시 기본 API 체크
                        api_normal = self.api_client.test_connection() if hasattr(self, 'api_client') else False
                        api_status = "🟢 API 정상 (기본 체크)" if api_normal else "🟡 API 확인 필요"
                except Exception as e:
                    api_normal = False
                    api_status = f"🟡 API 확인 불가: {str(e)[:30]}"
                    self.log(f"⚠️ API 상태 체크 오류: {e}")
            else:
                # 모니터링 프로세스가 실행 중이면 API도 정상으로 간주
                self.log("📡 모니터링 프로세스 실행 중 - API 상태 정상으로 간주")
                api_normal = True
                api_status = "🟢 API 정상 (모니터링 프로세스 기반)"
            
            # 시스템 리소스 정보 수집
            resource_normal = True
            try:
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('.')
                
                # 리소스 임계값 체크 (CPU 90%, 메모리 90%, 디스크 95%)
                resource_normal = (cpu_percent < 90 and 
                                 memory.percent < 90 and 
                                 disk.percent < 95)
                
                resource_info = (
                    f"💻 CPU 사용률: {cpu_percent:.1f}%/n"
                    f"🧠 메모리 사용률: {memory.percent:.1f}%/n"
                    f"💾 디스크 사용률: {disk.percent:.1f}%"
                )
            except:
                resource_normal = False
                resource_info = "📊 시스템 정보 수집 실패"
            
            # 조용한 시간대 체크 (19:01~05:59)
            if is_quiet:
                # 조용한 시간대: 중요한 문제가 있을 때만 알림
                # 핵심 문제: 모니터링 프로세스 중단, 시스템 리소스 임계값 초과
                has_problem = not monitor_running or not resource_normal
                
                if has_problem:
                    # 중요한 문제 발생 시에만 알림 전송
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("❌ 모니터링 프로세스 중단")
                        if not api_normal:
                            problem_details.append("❌ API 연결 문제")
                    if not resource_normal:
                        problem_details.append("❌ 시스템 리소스 임계값 초과")
                    
                    self.send_notification(
                        f"🚨 POSCO WatchHamster v3.0 중요 문제 감지/n/n"
                        f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                        f"🚨 감지된 문제:/n" + "/n".join(f"   • {problem}" for problem in problem_details) + "/n/n"
                        f"🔍 상세 상태:/n"
                        f"   • 모니터링 프로세스: {monitor_status}/n"
                        f"   • API 연결: {api_status}/n"
                        f"{resource_info}/n/n"
                        f"🔧 자동 복구 시도 중...",
                        is_error=True
                    )
                    self.log("🚨 조용한 시간대 중요 문제 알림 전송 완료")
                else:
                    # 정상 상태: 로그만 기록, 알림 없음
                    self.log(f"🌙 조용한 시간대 정상 상태 확인 (알림 없음) - {current_time.strftime('%H:%M:%S')}")
            else:
                # 일반 시간대 (06:00~19:00): 정상적인 상태 알림 전송
                if self.smart_enabled and smart_status_info and current_data:
                    # 스마트 상태 알림 전송
                    try:
                        self.smart_notifier.send_smart_status_notification(current_data, smart_status_info)
                        self.log("🧠 스마트 상태 알림 전송 완료")
                    except Exception as e:
                        self.log(f"⚠️ 스마트 상태 알림 실패, 기본 알림으로 대체: {e}")
                        # 스마트 알림 실패 시 기본 알림으로 대체
                        self._send_basic_status_notification(current_time, monitor_status, api_status, resource_info)
                else:
                    # 스마트 시스템 비활성화 또는 데이터 없음 시 기본 알림
                    self._send_basic_status_notification(current_time, monitor_status, api_status, resource_info)
                
                # 개별 모니터링 시스템 상태 추가 체크
                if self.individual_monitors_enabled:
                    self._check_individual_monitors_status()
                
                self.log("📊 정기 상태 알림 전송 완료")
            
        except Exception as e:
            self.log(f"❌ 정기 상태 알림 실패: {e}")
    def _send_basic_status_notification(self, current_time, monitor_status, api_status, resource_info):
        """
        기본 상태 알림 전송 (스마트 시스템 비활성화 시 사용)
        
        Args:
            current_time (datetime): 현재 시간
            monitor_status (str): 모니터링 프로세스 상태
            api_status (str): API 연결 상태
            resource_info (str): 시스템 리소스 정보
        """
        # 다음 알림 시간 계산 (절대 시간 기준)
        current_hour = current_time.hour
        next_notification_hour = None
        
        # 현재 시간 이후의 다음 알림 시간 찾기
        for hour in range(current_hour + 1, 24):
            if hour >= self.status_notification_start_hour:
                hour_diff = hour - self.status_notification_start_hour
                if hour_diff % self.status_notification_interval_hours == 0:
                    next_notification_hour = hour
                    break
        
        # 오늘 중에 다음 알림 시간이 없으면 내일 첫 알림 시간
        if next_notification_hour is None:
            next_notification_hour = self.status_notification_start_hour
        
        next_notification_time = f"{next_notification_hour:02d}:00"
        
        # 개별 뉴스 상태 정보 수집
        news_status_info = self._get_detailed_news_status()
        
        # 사용자가 보여준 캡처와 정확히 같은 형태로 알림 전송
        self.send_notification(f"데이터 갱신 없음\n\n{news_status_info}")
    
    def _send_hourly_status_notification(self, task_name):
        """
        매시간 정각 상태 체크 알림 전송 (조용한 시간대에도 명시적 알림)
        
        Args:
            task_name (str): 작업명
        """
        try:
            current_time = datetime.now()
            current_hour = current_time.hour
            is_quiet = self.is_quiet_hours()
            
            # 모니터링 프로세스 상태 확인
            monitor_running = self.is_monitor_running()
            monitor_status = "🟢 정상 작동" if monitor_running else "🔴 중단됨"
            
            # 스마트 상태 판단 시스템 사용
            smart_status_info = None
            current_data = None
            
            if self.smart_enabled and monitor_running:
                try:
                    # 현재 뉴스 데이터 조회
                    current_data = self.api_client.get_news_data()
                    if current_data:
                        # 스마트 상태 분석
                        smart_status_info = self.data_processor.get_status_info(current_data)
                        self.log(f"🧠 매시간 스마트 상태 분석 완료: {smart_status_info.get('status_text', '알 수 없음')}")
                    else:
                        self.log("⚠️ 매시간 뉴스 데이터 조회 실패")
                except Exception as e:
                    self.log(f"⚠️ 매시간 스마트 상태 분석 실패: {e}")
            
            # API 상태 체크
            api_normal = True
            api_status = "🟢 API 정상"
            
            if not monitor_running and self.individual_monitors_enabled:
                # 개별 모니터로 API 상태 확인
                api_checks = []
                
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    api_checks.append(ny_data is not None)
                except:
                    api_checks.append(False)
                
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    api_checks.append(kospi_data is not None)
                except:
                    api_checks.append(False)
                
                try:
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    api_checks.append(exchange_data is not None)
                except:
                    api_checks.append(False)
                
                successful_checks = sum(api_checks)
                total_checks = len(api_checks)
                
                if successful_checks == total_checks:
                    api_normal = True
                    api_status = "🟢 API 정상"
                elif successful_checks > 0:
                    api_normal = True
                    api_status = f"🟡 API 부분 정상 ({successful_checks}/{total_checks})"
                else:
                    api_normal = False
                    api_status = "🔴 API 연결 실패"
            
            # 시스템 리소스 정보
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                resource_info = (
                    f"💻 CPU: {cpu_percent:.1f}% | "
                    f"🧠 메모리: {memory.percent:.1f}% | "
                    f"💾 디스크: {disk.percent:.1f}%"
                )
            except:
                resource_info = "📊 시스템 정보 수집 실패"
            
            # 조용한 시간대 구분하여 알림 전송 (19:01~05:59)
            if is_quiet:
                # 조용한 시간대: 중요한 문제가 있을 때만 알림
                has_problem = not monitor_running or not api_normal
                
                if has_problem:
                    # 중요한 문제 발생 시에만 알림 전송
                    problem_details = []
                    if not monitor_running:
                        problem_details.append("❌ 모니터링 프로세스 중단")
                    if not api_normal:
                        problem_details.append("❌ API 연결 문제")
                    
                    self.send_notification(
                        f"🚨 POSCO 워치햄스터 매시간 체크 - 중요 문제 감지\n\n"
                        f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"🚨 감지된 문제:\n" + "\n".join(f"   • {problem}" for problem in problem_details) + "\n\n"
                        f"🔍 상세 상태:\n"
                        f"   • 모니터링: {monitor_status}\n"
                        f"   • API: {api_status}\n"
                        f"   • {resource_info}\n"
                        f"⏰ 다음 체크: {(current_hour + 1) % 24:02d}:00\n"
                        f"🔧 자동 복구 시도 중...",
                        is_error=True
                    )
                    self.log(f"🚨 조용한 시간대 매시간 체크 중요 문제 알림 전송 ({current_hour}시)")
                else:
                    # 정상 상태: 로그만 기록, 알림 없음
                    self.log(f"🌙 조용한 시간대 매시간 체크 정상 상태 (알림 없음) - {current_hour}시")
            else:
                # 주간: 상세한 알림
                if self.smart_enabled and smart_status_info and current_data:
                    # 스마트 상태 알림
                    try:
                        self.smart_notifier.send_smart_status_notification(
                            current_data, 
                            smart_status_info,
                            notification_type="hourly_check"
                        )
                        self.log("🧠 매시간 스마트 상태 알림 전송 완료")
                    except Exception as e:
                        self.log(f"⚠️ 매시간 스마트 상태 알림 실패, 기본 알림으로 대체: {e}")
                        # 기본 알림으로 대체
                        self.send_notification(
                            f"🕐 POSCO 워치햄스터 매시간 상태 체크\n\n"
                            f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                            f"🔍 모니터링 프로세스: {monitor_status}\n"
                            f"🌐 API 연결: {api_status}\n"
                            f"📊 {resource_info}\n"
                            f"⏰ 다음 체크: {(current_hour + 1) % 24:02d}:00\n"
                            f"🚀 자동 복구 기능: 활성화"
                        )
                else:
                    # 기본 알림
                    self.send_notification(
                        f"🕐 POSCO 워치햄스터 매시간 상태 체크\n\n"
                        f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"🔍 모니터링 프로세스: {monitor_status}\n"
                        f"🌐 API 연결: {api_status}\n"
                        f"📊 {resource_info}\n"
                        f"⏰ 다음 체크: {(current_hour + 1) % 24:02d}:00\n"
                        f"🚀 자동 복구 기능: 활성화"
                    )
            
            self.log(f"📊 매시간 상태 체크 알림 전송 완료 ({current_hour}시)")
            
        except Exception as e:
            self.log(f"❌ 매시간 상태 체크 알림 실패: {e}")
            # 오류 발생 시에는 간단한 알림
            self.send_notification(
                f"❌ POSCO 워치햄스터 매시간 상태 체크 오류\n\n"
                f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"❌ 오류: {str(e)}\n"
                f"🔧 수동 확인이 필요합니다.",
                is_error=True
            )
    
            # 오류 발생 시에는 간단한 알림
            self.send_notification(
                f"❌ POSCO WatchHamster v3.0 매시간 상태 체크 오류/n/n"
                f"📅 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"❌ 오류: {str(e)}/n"
                f"🔧 수동 확인이 필요합니다.",
                is_error=True
            )
    
    def _check_individual_monitors_status(self):
        """
        개별 모니터링 시스템 상태 체크 및 보고
        
        최적화된 개별 모니터링 시스템들의 상태를 확인하고
        필요시 추가 정보를 제공합니다.
        """
        try:
            current_time = datetime.now()
            individual_status = {}
            
            # 뉴욕마켓워치 상태 체크
            if hasattr(self, 'newyork_monitor'):
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    ny_analysis = self.newyork_monitor.analyze_publish_pattern(ny_data)
                    individual_status['newyork'] = {
                        'published': ny_analysis.get('is_published_today', False),
                        'status': ny_analysis.get('analysis', '상태 불명')
                    }
                except Exception as e:
                    individual_status['newyork'] = {'error': str(e)}
            
            # 증시마감 상태 체크
            if hasattr(self, 'kospi_monitor'):
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    kospi_analysis = self.kospi_monitor.analyze_publish_pattern(kospi_data)
                    individual_status['kospi'] = {
                        'published': kospi_analysis.get('is_published_today', False),
                        'status': kospi_analysis.get('analysis', '상태 불명')
                    }
                except Exception as e:
                    individual_status['kospi'] = {'error': str(e)}
            
            # 서환마감 상태 체크
            if hasattr(self, 'exchange_monitor'):
                try:
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    exchange_analysis = self.exchange_monitor.analyze_publish_pattern(exchange_data)
                    individual_status['exchange'] = {
                        'published': exchange_analysis.get('is_published_today', False),
                        'status': exchange_analysis.get('analysis', '상태 불명')
                    }
                except Exception as e:
                    individual_status['exchange'] = {'error': str(e)}
            
            # 상태 요약 로그
            published_count = sum(1 for status in individual_status.values() 
                                if status.get('published', False))
            total_count = len(individual_status)
            
            if total_count > 0:
                self.log(f"📊 개별 모니터 상태: {published_count}/{total_count} 발행 완료")
                
                # 각 뉴스별 상태 로그
                news_names = {'newyork': '🌆뉴욕마켓워치', 'kospi': '📈증시마감', 'exchange': '💱서환마감'}
                for news_type, status in individual_status.items():
                    name = news_names.get(news_type, news_type)
                    if 'error' in status:
                        self.log(f"   {name}: ❌ 오류 - {status['error']}")
                    elif status.get('published', False):
                        self.log(f"   {name}: ✅ {status.get('status', '발행 완료')}")
                    else:
                        self.log(f"   {name}: ⏳ {status.get('status', '대기 중')}")
            
        except Exception as e:
            self.log(f"⚠️ 개별 모니터 상태 체크 실패: {e}")
    
    def get_enhanced_status_report(self):
        """
        향상된 상태 보고서 생성 (개별 모니터 정보 포함)
        
        Returns:
            dict: 향상된 상태 정보
        """
        try:
            # 기본 상태 정보
            basic_status = {
                'timestamp': datetime.now().isoformat(),
                'monitor_running': self.is_monitor_running(),
                'api_status': 'normal',  # 기본값
                'individual_monitors': {}
            }
            
            # 개별 모니터 상태 추가
            if self.individual_monitors_enabled:
                if hasattr(self, 'newyork_monitor'):
                    ny_data = self.newyork_monitor.get_current_news_data()
                    ny_analysis = self.newyork_monitor.analyze_publish_pattern(ny_data)
                    basic_status['individual_monitors']['newyork'] = {
                        'name': '뉴욕마켓워치',
                        'published_today': ny_analysis.get('is_published_today', False),
                        'status': ny_analysis.get('status', 'unknown'),
                        'analysis': ny_analysis.get('analysis', '분석 불가')
                    }
                
                if hasattr(self, 'kospi_monitor'):
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    kospi_analysis = self.kospi_monitor.analyze_publish_pattern(kospi_data)
                    basic_status['individual_monitors']['kospi'] = {
                        'name': '증시마감',
                        'published_today': kospi_analysis.get('is_published_today', False),
                        'status': kospi_analysis.get('status', 'unknown'),
                        'analysis': kospi_analysis.get('analysis', '분석 불가')
                    }
                
                if hasattr(self, 'exchange_monitor'):
                    exchange_data = self.exchange_monitor.get_current_news_data()
                    exchange_analysis = self.exchange_monitor.analyze_publish_pattern(exchange_data)
                    basic_status['individual_monitors']['exchange'] = {
                        'name': '서환마감',
                        'published_today': exchange_analysis.get('is_published_today', False),
                        'status': exchange_analysis.get('status', 'unknown'),
                        'analysis': exchange_analysis.get('analysis', '분석 불가')
                    }
            
            return basic_status
            
        except Exception as e:
            self.log(f"⚠️ 향상된 상태 보고서 생성 실패: {e}")
            return {'error': str(e), 'timestamp': datetime.now().isoformat()}
    
    def _check_master_monitor_integration(self):
        """
        마스터 모니터링 시스템과의 통합 상태 체크
        
        WatchHamster v3.0 상태를 확인하고
        필요시 조정합니다.
        """
        try:
            current_time = datetime.now()
            
            # 마스터 모니터의 현재 전략 확인
            if hasattr(self.master_monitor, 'get_current_monitoring_strategy'):
                strategy = self.master_monitor.get_current_monitoring_strategy()
                
                # 전략 변경 시 로그 기록
                if not hasattr(self, '_last_master_strategy') or self._last_master_strategy != strategy['mode']:
                    self.log(f"🎛️ 마스터 모니터링 전략 변경: {strategy['description']}")
                    self._last_master_strategy = strategy['mode']
                
                # 집중 모니터링 시간대에는 워치햄스터 체크 간격 조정
                if strategy['interval'] <= 60:  # 1분 간격 집중 모니터링
                    # 워치햄스터도 더 자주 체크하도록 조정 (하지만 너무 자주는 안 됨)
                    if not hasattr(self, '_intensive_mode') or not self._intensive_mode:
                        self.log("🔥 집중 모니터링 모드 감지 - 워치햄스터 체크 빈도 증가")
                        self._intensive_mode = True
                else:
                    if hasattr(self, '_intensive_mode') and self._intensive_mode:
                        self.log("📋 일반 모니터링 모드 복귀 - 워치햄스터 체크 빈도 정상화")
                        self._intensive_mode = False
            
        except Exception as e:
            self.log(f"⚠️ 마스터 모니터 통합 체크 실패: {e}")
    
    def send_enhanced_status_notification(self):
        """
        향상된 상태 알림 전송 (개별 모니터 정보 포함)
        
        기존 상태 알림에 개별 모니터링 시스템의 상태 정보를 추가하여
        더 상세한 정보를 제공합니다.
        """
        try:
            enhanced_status = self.get_enhanced_status_report()
            current_time = datetime.now()
            
            # 기본 상태 정보
            monitor_status = "🟢 정상 작동" if enhanced_status.get('monitor_running', False) else "🔴 중단됨"
            
            message = f"🛡️ POSCO 워치햄스터 향상된 상태 보고\n\n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"🔍 모니터링 프로세스: {monitor_status}\n\n"
            
            # 개별 모니터 상태 추가
            individual_monitors = enhanced_status.get('individual_monitors', {})
            if individual_monitors:
                message += f"📊 개별 뉴스 모니터 상태:\n"
                
                for news_type, info in individual_monitors.items():
                    name = info.get('name', news_type)
                    published = info.get('published_today', False)
                    analysis = info.get('analysis', '분석 불가')
                    
                    status_emoji = "✅" if published else "⏳"
                    message += f"   {status_emoji} {name}: {analysis}\n"
                
                # 전체 발행 현황
                published_count = sum(1 for info in individual_monitors.values() 
                                    if info.get('published_today', False))
                total_count = len(individual_monitors)
                message += f"\n📈 전체 발행 현황: {published_count}/{total_count} 완료\n"
            
            # 시스템 통합 상태
            if self.master_monitor_enabled:
                message += f"\n🎛️ 마스터 모니터링: 연동 활성화"
            if self.individual_monitors_enabled:
                message += f"\n🔧 개별 모니터링: 연동 활성화"
            
            message += f"\n⏰ 다음 보고: {(current_time + timedelta(hours=2)).strftime('%H:%M')}"
            
            payload = {
                "botName": "POSCO 워치햄스터 🛡️",
                "botIconImage": BOT_PROFILE_IMAGE_URL,
                "text": "향상된 상태 보고",
                "attachments": [{
                    "color": "#17a2b8",
                    "text": message
                }]
            }
            
            response = requests.post(
                WATCHHAMSTER_WEBHOOK_URL,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                self.log("✅ 향상된 상태 알림 전송 성공")
                return True
            else:
                self.log(f"❌ 향상된 상태 알림 전송 실패: {response.status_code}")
                return False
                
        except Exception as e:
            self.log(f"❌ 향상된 상태 알림 전송 오류: {e}")
            return False
    
    def manage_log_file(self):
        """로그 파일 크기 관리 - 10MB 초과 시 백업 후 새로 시작"""
        try:
            if os.path.exists(self.log_file):
                file_size = os.path.getsize(self.log_file)
                max_size = 10 * 1024 * 1024  # 10MB
                
                if file_size > max_size:
                    # 백업 파일명 생성
                    backup_name = f".naming_backup/config_data_backup/watchhamster.log"
                    backup_path = os.path.join(self.script_dir, backup_name)
                    
                    # 기존 로그 파일을 백업으로 이동
                    os.rename(self.log_file, backup_path)
                    
                    self.log(f"📁 로그 파일 백업 완료: {backup_name}")
                    
        except Exception as e:
            print(f"[ERROR] 로그 파일 관리 실패: {e}")
    
    def save_status(self):
        """현재 상태 저장 - StateManager 사용으로 안정성 개선"""
        try:
            # 로그 파일 크기 관리
            self.manage_log_file()
            
            # StateManager를 사용한 안전한 상태 저장
            status = {
                "last_check": datetime.now(),
                "monitor_running": self.is_monitor_running(),
                "last_git_check": self.last_git_check,
                "last_status_notification": self.last_status_notification,
                "last_status_notification_hour": self.last_status_notification_hour,
                "watchhamster_pid": os.getpid(),
                "last_scheduled_tasks": getattr(self, 'last_scheduled_tasks', {}),
                "individual_monitors": self._get_individual_monitors_status(),
                "error_count": getattr(self, 'error_count', 0),
                "recovery_attempts": getattr(self, 'recovery_attempts', 0)
            }
            
            # StateManager를 통한 안전한 저장
            if self.state_manager.save_state(status):
                self.log("✅ 상태 저장 완료")
            else:
                self.log("⚠️ 상태 저장 실패")
                
        except Exception as e:
            self.log(f"❌ 상태 저장 오류: {e}")
    
    def _get_individual_monitors_status(self):
        """개별 모니터 상태 정보 수집"""
        try:
            monitors_status = {}
            
            # 뉴욕마켓워치 상태
            if hasattr(self, 'newyork_monitor'):
                monitors_status['newyork'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.newyork_monitor else 'inactive'
                }
            
            # 증시마감 상태
            if hasattr(self, 'kospi_monitor'):
                monitors_status['kospi'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.kospi_monitor else 'inactive'
                }
            
            # 서환마감 상태
            if hasattr(self, 'exchange_monitor'):
                monitors_status['exchange'] = {
                    'last_check': datetime.now(),
                    'status': 'active' if self.exchange_monitor else 'inactive'
                }
            
            return monitors_status
            
        except Exception as e:
            self.log(f"⚠️ 개별 모니터 상태 수집 실패: {e}")
            return {}
    
    def _get_detailed_news_status(self):
        """
        사용자가 보여준 캡처와 정확히 같은 박스 형태의 뉴스 상태 정보 생성
        
        Returns:
            str: 박스 형태로 포맷된 뉴스 상태 정보
        """
        try:
            status_lines = []
            
            # EXCHANGE RATE 상태
            if hasattr(self, 'exchange_monitor'):
                try:
                    ex_data = self.exchange_monitor.get_current_news_data()
                    if ex_data and 'exchange-rate' in ex_data:
                        ex_news = ex_data['exchange-rate']
                        ex_time = ex_news.get('time', '데이터 없음')
                        ex_title = ex_news.get('title', '')
                        
                        # 시간 포맷팅 (전체 datetime 형식으로)
                        if ex_time != '데이터 없음' and len(ex_time) >= 6:
                            ex_date = ex_news.get('date', '')
                            if len(ex_date) == 8:  # YYYYMMDD
                                formatted_time = f"{ex_date[:4]}-{ex_date[4:6]}-{ex_date[6:8]} {ex_time[:2]}:{ex_time[2:4]}:{ex_time[4:6]}"
                            else:
                                formatted_time = ex_time
                        else:
                            formatted_time = "데이터 없음"
                        
                        # 오늘 발행 여부 확인
                        today = datetime.now().strftime('%Y%m%d')
                        ex_date = ex_news.get('date', '')
                        is_today = (ex_date == today)
                        
                        status_emoji = "🟢" if is_today else "🔴"
                        status_text = "최신" if is_today else "데이터 없음"
                        
                        status_lines.append("┌  EXCHANGE RATE")
                        status_lines.append(f"├ 상태: {status_emoji} {status_text}")
                        status_lines.append(f"├ 시간: {formatted_time}")
                        status_lines.append(f"└ 제목: {ex_title}")
                    else:
                        status_lines.append("┌  EXCHANGE RATE")
                        status_lines.append("├ 상태: 🔴 데이터 없음")
                        status_lines.append("├ 시간: 데이터 없음")
                        status_lines.append("└ 제목:")
                except Exception as e:
                    status_lines.append("┌  EXCHANGE RATE")
                    status_lines.append("├ 상태: ❌ 오류")
                    status_lines.append("├ 시간: 데이터 없음")
                    status_lines.append("└ 제목:")
            
            status_lines.append("")  # 빈 줄
            
            # NEWYORK MARKET WATCH 상태
            if hasattr(self, 'newyork_monitor'):
                try:
                    ny_data = self.newyork_monitor.get_current_news_data()
                    if ny_data and 'newyork-market-watch' in ny_data:
                        ny_news = ny_data['newyork-market-watch']
                        ny_time = ny_news.get('time', '데이터 없음')
                        ny_title = ny_news.get('title', '')
                        
                        # 시간 포맷팅 (전체 datetime 형식으로)
                        if ny_time != '데이터 없음' and len(ny_time) >= 6:
                            ny_date = ny_news.get('date', '')
                            if len(ny_date) == 8:  # YYYYMMDD
                                formatted_time = f"{ny_date[:4]}-{ny_date[4:6]}-{ny_date[6:8]} {ny_time[:2]}:{ny_time[2:4]}:{ny_time[4:6]}"
                            else:
                                formatted_time = ny_time
                        else:
                            formatted_time = "데이터 없음"
                        
                        # 오늘 발행 여부 확인
                        today = datetime.now().strftime('%Y%m%d')
                        ny_date = ny_news.get('date', '')
                        is_today = (ny_date == today)
                        
                        status_emoji = "🟢" if is_today else "🔴"
                        status_text = "최신" if is_today else "데이터 없음"
                        
                        status_lines.append("┌  NEWYORK MARKET WATCH")
                        status_lines.append(f"├ 상태: {status_emoji} {status_text}")
                        status_lines.append(f"├ 시간: {formatted_time}")
                        status_lines.append(f"└ 제목: {ny_title}")
                    else:
                        status_lines.append("┌  NEWYORK MARKET WATCH")
                        status_lines.append("├ 상태: 🔴 데이터 없음")
                        status_lines.append("├ 시간: 데이터 없음")
                        status_lines.append("└ 제목:")
                except Exception as e:
                    status_lines.append("┌  NEWYORK MARKET WATCH")
                    status_lines.append("├ 상태: ❌ 오류")
                    status_lines.append("├ 시간: 데이터 없음")
                    status_lines.append("└ 제목:")
            
            status_lines.append("")  # 빈 줄
            
            # KOSPI CLOSE 상태
            if hasattr(self, 'kospi_monitor'):
                try:
                    kospi_data = self.kospi_monitor.get_current_news_data()
                    if kospi_data and 'kospi-close' in kospi_data:
                        kospi_news = kospi_data['kospi-close']
                        kospi_time = kospi_news.get('time', '데이터 없음')
                        kospi_title = kospi_news.get('title', '')
                        
                        # 시간 포맷팅 (전체 datetime 형식으로)
                        if kospi_time != '데이터 없음' and len(kospi_time) >= 6:
                            kospi_date = kospi_news.get('date', '')
                            if len(kospi_date) == 8:  # YYYYMMDD
                                formatted_time = f"{kospi_date[:4]}-{kospi_date[4:6]}-{kospi_date[6:8]} {kospi_time[:2]}:{kospi_time[2:4]}:{kospi_time[4:6]}"
                            else:
                                formatted_time = kospi_time
                        else:
                            formatted_time = "데이터 없음"
                        
                        # 오늘 발행 여부 확인
                        today = datetime.now().strftime('%Y%m%d')
                        kospi_date = kospi_news.get('date', '')
                        is_today = (kospi_date == today)
                        
                        status_emoji = "🟢" if is_today else "🔴"
                        status_text = "최신" if is_today else "데이터 없음"
                        
                        status_lines.append("┌  KOSPI CLOSE")
                        status_lines.append(f"├ 상태: {status_emoji} {status_text}")
                        status_lines.append(f"├ 시간: {formatted_time}")
                        status_lines.append(f"└ 제목: {kospi_title}")
                    else:
                        status_lines.append("┌  KOSPI CLOSE")
                        status_lines.append("├ 상태: 🔴 데이터 없음")
                        status_lines.append("├ 시간: 데이터 없음")
                        status_lines.append("└ 제목:")
                except Exception as e:
                    status_lines.append("┌  KOSPI CLOSE")
                    status_lines.append("├ 상태: ❌ 오류")
                    status_lines.append("├ 시간: 데이터 없음")
                    status_lines.append("└ 제목:")
            
            # 최종 확인 시간 추가
            status_lines.append("")
            status_lines.append(f"최종 확인: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            return "/n".join(status_lines)
            
        except Exception as e:
            return f"❌ 뉴스 상태 정보 수집 오류: {str(e)}"
    
    def load_previous_state(self):
        """이전 상태 로드 - StateManager 및 ModuleRegistry 연동"""
        try:
            previous_state = self.state_manager.load_state()
            
            # 이전 상태에서 복원 가능한 정보들
            if previous_state.get('last_status_notification_hour'):
                self.last_status_notification_hour = previous_state['last_status_notification_hour']
            
            # 이전 스케줄 작업 정보 복원
            if previous_state.get('last_scheduled_tasks'):
                self.last_scheduled_tasks = previous_state['last_scheduled_tasks']
            
            # 오류 카운트 복원
            self.error_count = previous_state.get('error_count', 0)
            self.recovery_attempts = previous_state.get('recovery_attempts', 0)
            
            # 모듈 레지스트리가 있는 경우 모듈 상태 동기화
            if self.module_registry:
                try:
                    # 이전에 실행 중이던 프로세스 정보 복원
                    previous_processes = previous_state.get('running_processes', [])
                    for process_name in previous_processes:
                        if process_name in self.managed_processes:
                            # 프로세스가 실제로 실행 중인지 확인
                            if self.process_manager.is_process_running(process_name):
                                self.log(f"📋 기존 프로세스 발견: {process_name}")
                            else:
                                self.log(f"⚠️ 이전 프로세스 종료됨: {process_name}")
                    
                    self.log("🔄 모듈 레지스트리 상태 동기화 완료")
                except Exception as e:
                    self.log(f"⚠️ 모듈 상태 동기화 실패: {e}")
            
            self.log("📋 이전 상태 로드 완료")
            
        except Exception as e:
            self.log(f"⚠️ 이전 상태 로드 실패: {e}")
            # 기본값으로 초기화
            self.error_count = 0
            self.recovery_attempts = 0
    
    def is_monitor_running(self) -> bool:
        """
        모니터링 시스템 실행 상태 확인
        
        Returns:
            bool: 모니터링 시스템 실행 여부
        """
        try:
            # ProcessManager를 통한 헬스 체크
healthy_count,_total_count =  self.process_manager.perform_health_checks()
            
            # 50% 이상의 모니터가 정상이면 실행 중으로 간주
return_healthy_count_> =  (total_count * 0.5)
            
        except Exception as e:
            self.log(f"❌ 모니터 실행 상태 확인 오류: {e}")
            return False
    
    def run(self):
        """워치햄스터 🛡️ 메인 실행 루프"""
        # 컬러풀한 시작 배너 출력 (UI가 있는 경우만)
        if self.ui:
            self.ui.print_startup_banner()
        else:
            print("🐹 POSCO WatchHamster v3.0 시작")
        
        self.log("POSCO WatchHamster v3.0 시작")
        
        # v2 통합 상태 로그
        if self.v3_0_enabled:
            self.log("🎉 v2 아키텍처 활성화 - 하이브리드 모드로 동작")
        else:
            self.log(f"📋 기존 방식으로 동작 - 폴백 사유: {self.fallback_reason}")
        
        # 시작 알림 전송 (v2 NotificationManager 우선 사용)
        if self.v3_0_enabled and self.v3_0_components['notification_manager']:
            # v2 시작 알림은 start_all_processes에서 전송됨
            pass
        else:
            # 기존 방식 시작 알림
            self.send_notification(
                f"POSCO WatchHamster v3.0 시작/n/n"
                f"시작 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"모니터링 간격: {self.process_check_interval/60}분/n"
                f"상태 알림: {self.status_notification_interval_hours}시간 간격/n"
                f"아키텍처: {'v2 하이브리드' if self.v3_0_enabled else '기존 방식'}"
            )
        
        # 새로운 아키텍처로 모니터링 시스템 초기화
        if self.ui:
            self.ui.print_info_message("모니터링 시스템 초기화 중...", "process")
        else:
            self.log("🔄 모니터링 시스템 초기화 중...")
        
        # v2 프로세스 생명주기 관리 통합
        if self.v3_0_enabled:
            self.log("🔄 v2 프로세스 생명주기 관리 통합 중...")
            integration_success = self.integrate_v2_process_lifecycle_management()
            if integration_success:
                self.log("✅ v2 프로세스 생명주기 관리 통합 완료")
            else:
                self.log("⚠️ v2 프로세스 생명주기 관리 통합 부분 실패")
        
        # 모든 프로세스 시작
        if self.start_all_processes():
            if self.ui:
                self.ui.print_success_message("모니터링 시스템 초기화 성공")
                
                # 프로세스 상태 표시
                if self.v3_0_enabled and self.v3_0_components['module_registry']:
                    system_status = self.get_all_process_status()
                    if self.ui and hasattr(self.ui, 'print_process_status'):
                        self.ui.print_process_status(system_status)
            else:
                self.log("✅ 모니터링 시스템 초기화 성공")
        else:
            if self.ui:
                self.ui.print_warning_message("모니터링 시스템 부분 초기화", "일부 프로세스 실패")
            else:
                self.log("⚠️ 모니터링 시스템 부분 초기화 - 일부 프로세스 실패")
        
        try:
            while True:
                current_time = datetime.now()
                
                # v2 통합 아키텍처 헬스체크 및 3단계 지능적 복구 시스템
                if self.v3_0_enabled and self.v3_0_components['module_registry'] and self.v3_0_components['process_manager']:
                    # v2 Enhanced ProcessManager를 통한 종합적 헬스체크
                    health_results = self.v3_0_components['process_manager'].perform_health_check()
                    
                    healthy_count = sum(1 for is_healthy in health_results.values() if is_healthy)
                    total_count = len(health_results)
                    failed_processes = [name for name, is_healthy in health_results.items() if not is_healthy]
                    
                    # 헬스체크 결과 상세 로깅
                    if total_count > 0:
                        health_percentage = (healthy_count / total_count) * 100
                        self.log(f"🔍 v2 프로세스 헬스체크 완료: {healthy_count}/{total_count} 정상 ({health_percentage:.1f}%)")
                        
                        if failed_processes:
                            self.log(f"⚠️ 문제 감지된 프로세스: {', '.join(failed_processes)}")
                    
                    # 모듈 상태 추적 업데이트
                    self._update_module_status_from_health_check(health_results)
                    
                    if healthy_count < total_count:
                        # 프로세스 실패 감지 - v2 3단계 지능적 복구 시스템 활성화
                        self.log(f"🚨 프로세스 실패 감지 - v2 3단계 복구 시스템 활성화")
                        
                        recovery_start_time = datetime.now()
                        recovery_results = {}
                        
                        # 실패한 프로세스들에 대해 v2 자동 복구 시도
                        for process_name in failed_processes:
                            self.log(f"🔧 {process_name} 3단계 지능적 복구 시작")
                            
                            # 프로세스 정보 조회 (복구 전 상태)
                            process_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                            pre_recovery_restart_count = process_info.restart_count if process_info else 0
                            
                            # v2 ProcessManager의 3단계 자동 복구 실행
                            recovery_success = self.handle_process_failure_v2(process_name)
                            
                            # 복구 결과 기록
                            post_recovery_info = self.v3_0_components['process_manager'].get_process_info(process_name)
                            recovery_results[process_name] = {
                                'success': recovery_success,
                                'pre_restart_count': pre_recovery_restart_count,
                                'post_restart_count': post_recovery_info.restart_count if post_recovery_info else pre_recovery_restart_count,
                                'final_status': post_recovery_info.status.value if post_recovery_info else 'unknown'
                            }
                        
                        recovery_end_time = datetime.now()
                        total_recovery_time = (recovery_end_time - recovery_start_time).total_seconds()
                        
                        # 복구 결과 종합 분석
                        successful_recoveries = sum(1 for result in recovery_results.values() if result['success'])
                        failed_recoveries = len(recovery_results) - successful_recoveries
                        
                        self.log(f"📊 v2 복구 시스템 결과: 성공 {successful_recoveries}개, 실패 {failed_recoveries}개 (소요시간: {total_recovery_time:.1f}초)")
                        
                        # 복구 결과별 상세 로깅
                        for process_name, result in recovery_results.items():
                            if result['success']:
                                self.log(f"✅ {process_name}: 복구 성공 (재시작 횟수: {result['pre_restart_count']} → {result['post_restart_count']})")
                            else:
                                self.log(f"❌ {process_name}: 복구 실패 (최종 상태: {result['final_status']})")
                        
                        # 전체 상태 불량 시 알림 (조용한 시간대 고려)
                        if not self.is_quiet_hours() or healthy_count == 0:
                            if self.v3_0_components['notification_manager']:
                                # v2 알림 시스템 사용 - 복구 결과 포함
                                system_status_obj = self._create_system_status_object_v2(current_time, health_results)
                                
                                # 복구 정보 추가
                                recovery_summary = {
                                    'total_failed': len(failed_processes),
                                    'recovery_attempted': len(recovery_results),
                                    'recovery_successful': successful_recoveries,
                                    'recovery_failed': failed_recoveries,
                                    'recovery_time': total_recovery_time,
                                    'recovery_details': recovery_results
                                }
                                
                                self.v3_0_components['notification_manager'].send_status_report(system_status_obj, recovery_summary)
                            else:
                                # 기존 알림 시스템 폴백
                                recovery_status = f"복구 시도: {successful_recoveries}성공/{failed_recoveries}실패"
                                self.send_notification(
                                    f"🚨 POSCO WatchHamster v3.0.0 프로세스 상태 불량/n/n"
                                    f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                    f"📊 정상 프로세스: {healthy_count}/{total_count}/n"
                                    f"⚠️ 문제 프로세스: {', '.join(failed_processes)}/n"
                                    f"🔧 {recovery_status}/n"
                                    f"⏱️ 복구 소요시간: {total_recovery_time:.1f}초/n"
                                    f"🛡️ v2 3단계 지능적 복구 시스템 작동됨",
                                    is_error=True
                                )
                    else:
                        # 모든 프로세스 정상
                        if hasattr(self, 'last_health_warning') and self.last_health_warning:
                            # 이전에 문제가 있었다면 복구 완료 알림
                            self.log("✅ 모든 프로세스 정상 복구 완료 - v2 시스템 안정화됨")
                            
                            if self.v3_0_components['notification_manager']:
                                # v2 복구 완료 알림
                                system_status_obj = self._create_system_status_object_v2(current_time, health_results)
                                self.v3_0_components['notification_manager'].send_recovery_complete_notification(system_status_obj)
                            else:
                                # 기존 방식 복구 완료 알림
                                self.send_notification(
                                    f"✅ POSCO WatchHamster v3.0.0 시스템 복구 완료/n/n"
                                    f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                    f"🎯 모든 프로세스 정상 동작 중 ({total_count}개)/n"
                                    f"🛡️ v2 3단계 지능적 복구 시스템이 성공적으로 작동했습니다."
                                )
                            
                            self.last_health_warning = False
                        
                    # 헬스체크 결과 기록 및 통계 업데이트
                    self.last_health_warning = (healthy_count < total_count)
                    
                    # v2 시스템 메트릭 업데이트
                    if hasattr(self, 'v2_system_metrics'):
                        self.v2_system_metrics['last_health_check'] = current_time
                        self.v2_system_metrics['health_check_count'] = self.v2_system_metrics.get('health_check_count', 0) + 1
                        self.v2_system_metrics['healthy_processes'] = healthy_count
                        self.v2_system_metrics['total_processes'] = total_count
                    else:
                        self.v2_system_metrics = {
                            'last_health_check': current_time,
                            'health_check_count': 1,
                            'healthy_processes': healthy_count,
                            'total_processes': total_count
                        }
                else:
                    # 기존 방식으로 폴백
                    monitor_running = self.is_monitor_running()
                    if not monitor_running:
                        self.log("⚠️ 모니터링 프로세스 중단 감지, 재시작 시도")
                        if self.start_monitor_process():
                            self.log("✅ 모니터링 프로세스 재시작 성공")
                        else:
                            self.log("❌ 모니터링 프로세스 재시작 실패")
                            self.send_notification(
                                f"POSCO 모니터 재시작 실패/n/n"
                                f"시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}/n"
                                f"수동 확인이 필요합니다.",
                                is_error=True
                            )

                
                # Git 업데이트 체크 (조용한 시간대 제외)
                if not self.is_quiet_hours() and (current_time - self.last_git_check).total_seconds() >= (self.git_check_interval):
                    self.log("🔍 Git 업데이트 체크 중...")
                    if self.check_git_updates():
                        self.apply_git_update()
                    self.last_git_check = current_time
                
                # 스케줄된 작업 체크 및 실행
                self.check_scheduled_tasks()
                
                # 절대시간 기준 알림 시스템
                
                # 1. 정기 상태 알림 (조용한 시간대 제외: 7, 9, 11, 13, 15, 17시만)
                if self.should_send_status_notification() and not self.is_quiet_hours():
                    self.send_status_notification()
                    self.last_status_notification_hour = current_time.hour
                
                # 2. 매시간 정각 상태 체크 (0~23시)
                if self.should_send_hourly_check():
                    if self.is_quiet_hours():
                        self.execute_scheduled_task("1", f"정시 상태 체크 ({current_time.hour}시) - 조용한 모드")
                    else:
                        self.execute_scheduled_task("1", f"정시 상태 체크 ({current_time.hour}시)")
                    self.last_hourly_check_hour = current_time.hour
                
                # 3. 고정 시간 작업들 (06:00, 06:10, 18:00, 18:10, 18:20)
                self.check_fixed_time_tasks()
                
                # 마스터 모니터링 시스템 상태 체크 (필요시)
                if self.master_monitor_enabled and hasattr(self, 'master_monitor'):
                    self._check_master_monitor_integration()
                
                # v2 성능 모니터링 및 최적화 체크 (10분마다)
                if (self.performance_monitor and 
                    hasattr(self, '_last_performance_check') and 
                    (current_time - self._last_performance_check).total_seconds() >= 600):
                    self._perform_performance_analysis()
                    self._last_performance_check = current_time
                elif self.performance_monitor and not hasattr(self, '_last_performance_check'):
                    self._last_performance_check = current_time
                
                # 상태 저장 (메모리 최적화)
                self.save_status()
                
                # 메모리 정리 (가비지 컬렉션)
                import gc
                gc.collect()
                
                # 대기 (CPU 사용률 최적화)
                time.sleep(self.process_check_interval)
                
        except KeyboardInterrupt:
            self.log("🛑 워치햄스터 🛡️ 중단 요청 받음")
            self.send_notification(
                f"POSCO WatchHamster v3.0 중단/n/n"
                f"중단 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
        except Exception as e:
            self.log(f"❌ WatchHamster v3.0 오류: {e}")
            self.send_notification(
                f"POSCO WatchHamster v3.0 오류/n/n"
                f"시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}/n"
                f"오류: {str(e)}",
                is_error=True
            )


    def send_startup_notification_v2(self):
        """
        v2 시작 알림 전송 - 기존 텍스트 보존하면서 v2 컴포넌트 정보 포함
        
        Requirements: 4.1, 4.2
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManager의 구조화된 시작 알림 사용
                success = self.v2_components['notification_manager'].send_startup_notification(
                    self.managed_processes
                )
                if success:
                    self.log("✅ v2 시작 알림 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 시작 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 완전 보존)
            current_time = datetime.now()
            message = f"🐹 POSCO 워치햄스터 시스템 시작\n\n"
            message += f"📅 시작 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"🛡️ 관리 대상 프로세스: {len(self.managed_processes)}개\n\n"
            
            message += f"📊 관리 중인 모듈:\n"
            for process in self.managed_processes:
                descriptions = {
                    'posco_main_notifier': '메인 뉴스 알림',
                    'realtime_news_monitor': '실시간 모니터링',
                    'integrated_report_scheduler': '리포트 스케줄러',
                    'historical_data_collector': '데이터 수집기'
                }
                desc = descriptions.get(process, process)
                message += f"  ✅ {process} ({desc})\n"
            
            # v2 컴포넌트 상태 추가 (v2 활성화 시에만)
            if self.v2_enabled:
                message += f"\n🔧 v2 아키텍처 상태:\n"
                for component_name, component in self.v2_components.items():
                    status = "✅ 활성화" if component else "❌ 비활성화"
                    message += f"  • {component_name}: {status}\n"
            
            message += f"\n🔄 모니터링 설정:\n"
            message += f"  • 헬스체크: 5분 간격\n"
            message += f"  • 상태 보고: 2시간 간격\n"
            message += f"  • 자동 복구: 활성화\n"
            message += f"  • Git 업데이트: 60분 간격\n\n"
            message += f"🚀 전체 시스템이 정상적으로 초기화되었습니다."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"❌ 시작 알림 전송 오류: {e}")
    

    def send_status_report_v2(self):
        """
        v2 정기 상태 보고 - v2 컴포넌트 정보를 포함한 향상된 상태 보고
        
        Requirements: 4.2, 4.3
        """
        try:
            current_time = datetime.now()
            
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 시스템 상태 정보 수집
                system_status = self._collect_v2_system_status()
                
                # v2 NotificationManager의 구조화된 상태 보고 사용
                success = self.v2_components['notification_manager'].send_status_report(system_status)
                if success:
                    self.log("✅ v2 상태 보고 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 상태 보고 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존하면서 v2 정보 추가)
            message = f"📊 POSCO 워치햄스터 정기 상태 보고\n\n"
            message += f"📅 보고 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            
            # 가동 시간 계산
            if hasattr(self, 'start_time'):
                uptime = current_time - self.start_time
                hours, remainder = divmod(int(uptime.total_seconds()), 3600)
                minutes, _ = divmod(remainder, 60)
                message += f"⏱️ 가동 시간: {hours}시간 {minutes}분\n\n"
            
            # 프로세스 상태 확인
            running_processes = []
            failed_processes = []
            
            for process_name in self.managed_processes:
                if self._is_process_running(process_name):
                    running_processes.append(process_name)
                else:
                    failed_processes.append(process_name)
            
            # 프로세스 상태 보고
            if not failed_processes:
                message += f"🟢 정상 프로세스 ({len(running_processes)}/{len(self.managed_processes)}):\n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  ✅ {process} - 정상 (PID: {pid})\n"
            else:
                message += f"🟢 정상 프로세스 ({len(running_processes)}/{len(self.managed_processes)}):\n"
                for process in running_processes:
                    pid = self._get_process_pid(process)
                    message += f"  ✅ {process} - 정상 (PID: {pid})\n"
                
                message += f"\n🟡 문제 프로세스 ({len(failed_processes)}/{len(self.managed_processes)}):\n"
                for process in failed_processes:
                    message += f"  ❌ {process} - 중지됨\n"
            
            # v2 컴포넌트 상태 추가
            if self.v2_enabled:
                message += f"\n🔧 v2 아키텍처 상태:\n"
                for component_name, component in self.v2_components.items():
                    if component:
                        # 컴포넌트별 상태 정보
                        if component_name == 'notification_manager':
                            stats = component.get_notification_stats()
                            message += f"  ✅ {component_name}: 활성화 (알림: {stats.get('total_notifications', 0)}회)\n"
                        elif component_name == 'module_registry':
                            modules = component.list_modules()
                            message += f"  ✅ {component_name}: 활성화 (모듈: {len(modules)}개)\n"
                        else:
                            message += f"  ✅ {component_name}: 활성화\n"
                    else:
                        message += f"  ❌ {component_name}: 비활성화\n"
            
            # 시스템 성능 정보
            try:
                import psutil
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_percent = psutil.virtual_memory().percent
                disk_percent = psutil.disk_usage('/').percent
                
                message += f"\n📈 시스템 성능:\n"
                message += f"  • CPU 사용률: {cpu_percent:.0f}%\n"
                message += f"  • 메모리 사용률: {memory_percent:.0f}%\n"
                message += f"  • 디스크 사용률: {disk_percent:.0f}%\n"
            except ImportError:
                message += f"\n📈 시스템 성능: 정보 수집 불가 (psutil 필요)\n"
            
            # 다음 보고 시간
            next_report_time = current_time + timedelta(hours=self.status_notification_interval_hours)
            message += f"\n🔄 다음 상태 보고: {next_report_time.strftime('%H:%M')}"
            
            # 색상 결정 (문제가 있으면 주황색, 없으면 녹색)
            is_error = len(failed_processes) > 0
            self.send_notification(message, is_error)
            
        except Exception as e:
            self.log(f"❌ 상태 보고 전송 오류: {e}")
    


    def send_critical_alert_v2(self, alert_message, additional_info=None):
        """
        v2 긴급 알림 - 구조화된 긴급 상황 알림
        
        Requirements: 4.4
        
        Args:
            alert_message (str): 긴급 알림 메시지
            additional_info (dict): 추가 정보
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManager의 구조화된 긴급 알림 사용
                success = self.v2_components['notification_manager'].send_critical_alert(
                    alert_message, additional_info or {}
                )
                if success:
                    self.log("✅ v2 긴급 알림 전송 완료")
                    return
                else:
                    self.log("⚠️ v2 긴급 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백
            current_time = datetime.now()
            message = f"🚨 POSCO 워치햄스터 긴급 알림\n\n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"🚨 긴급 상황: {alert_message}\n\n"
            
            if additional_info:
                message += f"📋 추가 정보:\n"
                for key, value in additional_info.items():
                    message += f"  • {key}: {value}\n"
                message += "\n"
            
            message += f"🔧 즉시 수동 확인이 필요합니다."
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"❌ 긴급 알림 전송 오류: {e}")
    


    def send_recovery_success_v2(self, process_name, recovery_details):
        """
        v2 복구 성공 알림 - 복구 단계와 상세 정보 포함
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): 프로세스 이름
            recovery_details (dict): 복구 상세 정보
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManager의 구조화된 복구 알림 사용
                success = self.v2_components['notification_manager'].send_recovery_success(
                    process_name, recovery_details
                )
                if success:
                    self.log(f"✅ v2 복구 성공 알림 전송 완료: {process_name}")
                    return
                else:
                    self.log("⚠️ v2 복구 성공 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존)
            current_time = datetime.now()
            message = f"✅ POSCO 워치햄스터 프로세스 복구 완료\n\n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"🔧 복구된 프로세스: {process_name}\n\n"
            
            # 복구 정보
            recovery_stage = recovery_details.get('recovery_stage', '알 수 없음')
            recovery_time = recovery_details.get('recovery_time', 0)
            
            message += f"🔄 복구 단계: {recovery_stage}\n"
            if recovery_time > 0:
                message += f"⏱️ 복구 소요 시간: {recovery_time}초\n"
            
            # 새 프로세스 정보
            new_pid = recovery_details.get('new_pid')
            if new_pid:
                message += f"🆔 새 프로세스 ID: {new_pid}\n"
            
            message += f"\n🚀 프로세스가 정상적으로 복구되어 모니터링을 재개합니다."
            
            self.send_notification(message)
            
        except Exception as e:
            self.log(f"❌ 복구 성공 알림 전송 오류: {e}")
    


    def send_process_error_v2(self, process_name, error_details):
        """
        v2 프로세스 오류 알림 - 구조화된 오류 정보 포함
        
        Requirements: 4.3, 4.4
        
        Args:
            process_name (str): 프로세스 이름
            error_details (dict): 오류 상세 정보
        """
        try:
            if self.v2_enabled and self.v2_components['notification_manager']:
                # v2 NotificationManager의 구조화된 오류 알림 사용
                success = self.v2_components['notification_manager'].send_process_error(
                    process_name, error_details
                )
                if success:
                    self.log(f"✅ v2 프로세스 오류 알림 전송 완료: {process_name}")
                    return
                else:
                    self.log("⚠️ v2 프로세스 오류 알림 실패, 기존 방식으로 폴백")
            
            # 기존 방식으로 폴백 (기존 텍스트 보존)
            current_time = datetime.now()
            message = f"❌ POSCO 워치햄스터 프로세스 오류\n\n"
            message += f"📅 시간: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            message += f"🔧 문제 프로세스: {process_name}\n\n"
            
            # 오류 정보
            error_msg = error_details.get('error_message', '알 수 없는 오류')
            message += f"❌ 오류 내용: {error_msg}\n"
            
            # 재시작 시도 정보
            restart_count = error_details.get('restart_count', 0)
            max_attempts = error_details.get('max_attempts', 3)
            
            if restart_count > 0:
                message += f"🔄 재시작 시도: {restart_count}/{max_attempts}회\n"
            
            # 자동 복구 상태
            auto_recovery = error_details.get('auto_recovery_enabled', True)
            if auto_recovery and restart_count < max_attempts:
                message += f"\n🔧 자동 복구 시도 중..."
            elif restart_count >= max_attempts:
                message += f"\n🚨 최대 재시작 횟수 초과 - 수동 개입 필요"
            else:
                message += f"\n⚠️ 자동 복구 비활성화 - 수동 확인 필요"
            
            self.send_notification(message, is_error=True)
            
        except Exception as e:
            self.log(f"❌ 프로세스 오류 알림 전송 오류: {e}")
    

if __name__ == "__main__":
    # Windows 환경에서 UTF-8 출력 설정 개선
    if sys.platform == "win32":
        import codecs
        import locale
        
        # 콘솔 코드페이지를 UTF-8로 설정
        try:
            import subprocess
subprocess.run(['chcp',_'65001'],_shell = True, capture_output=True)
        except:
            pass
        
        # 표준 출력/오류를 UTF-8로 설정
        try:
            sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
            sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())
        except:
            # 이미 설정된 경우 무시
            pass
        
        # 환경 변수 설정
        os.environ['PYTHONIOENCODING'] = 'utf-8'
    
    watchhamster = WatchHamster v3.00Monitor()
    watchhamster.run()
    watchhamster.run()