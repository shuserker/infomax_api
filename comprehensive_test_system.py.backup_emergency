#!/usr/bin/env python3
"""
POSCO ì‹œìŠ¤í…œ ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ
Comprehensive Test System for POSCO System Repair and Completion

ì´ ëª¨ë“ˆì€ ë‹¤ìŒ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤:
1. ìë™í™”ëœ êµ¬ë¬¸ ê²€ì¦ ì‹œìŠ¤í…œ
2. ëª¨ë“ˆ Import í…ŒìŠ¤íŠ¸ ìë™í™”
3. íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ìë™ ê²€ì¦
4. ì„±ëŠ¥ ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
"""

import ast
import sys
import os
import json
import time
import psutil
import importlib
import traceback
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import subprocess
import re
import gc
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

@dataclass
class TestResult:
    """í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ì €ì¥í•˜ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    test_name: str
    success: bool
    message: str
    details: Optional[Dict[str, Any]] = None
    execution_time: float = 0.0
    timestamp: str = ""

@dataclass
class SyntaxTestResult(TestResult):
    """êµ¬ë¬¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    file_path: str = ""
    line_number: int = 0
    error_type: str = ""

@dataclass
class ImportTestResult(TestResult):
    """Import í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    module_name: str = ""
    import_path: str = ""
    dependency_chain: List[str] = None

@dataclass
class FileReferenceTestResult(TestResult):
    """íŒŒì¼ ì°¸ì¡° í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    source_file: str = ""
    referenced_file: str = ""
    reference_type: str = ""

@dataclass
class PerformanceTestResult(TestResult):
    """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    disk_io: Dict[str, float] = None
    network_io: Dict[str, float] = None

class SyntaxVerificationSystem:
    """ìë™í™”ëœ êµ¬ë¬¸ ê²€ì¦ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.python_files = []
        self.results = []
        
    def discover_python_files(self, root_path: Path = None) -> List[Path]:
        """Python íŒŒì¼ë“¤ì„ ìë™ìœ¼ë¡œ ë°œê²¬"""
        if root_path is None:
            root_path = Path.cwd()
            
        python_files = []
        
        # ì œì™¸í•  ë””ë ‰í† ë¦¬ íŒ¨í„´
        exclude_patterns = [
            '__pycache__',
            '.git',
            '.vscode',
            'node_modules',
            '.pytest_cache',
            '.backup',
            'backup',
            '.repair_backup',
            '.enhanced_repair_backup',
            '.aggressive_syntax_repair_backup',
            '.comprehensive_repair_backup',
            '.file_reference_backup',
            '.file_renaming_backup',
            '.filename_standardization_backup',
            '.final_file_reference_cleanup_backup',
            '.final_reference_cleanup_backup',
            '.final_syntax_repair_backup',
            '.focused_file_reference_backup',
            '.indentation_backup',
            '.naming_backup',
            '.refined_file_reference_backup',
            '.repair_backups',
            '.syntax_repair_backup'
        ]
        
        # ì•ˆì „í•œ íŒŒì¼ íƒìƒ‰ (ê¹Šì´ ì œí•œ ë° ê²½ë¡œ ê¸¸ì´ ì²´í¬)
        def safe_rglob(path: Path, pattern: str, max_depth: int = 10):
            """ì•ˆì „í•œ ì¬ê·€ íŒŒì¼ íƒìƒ‰"""
            try:
                for file_path in path.rglob(pattern):
                    # ê²½ë¡œ ê¸¸ì´ ì²´í¬ (macOS íŒŒì¼ëª… ê¸¸ì´ ì œí•œ ê³ ë ¤)
                    if len(str(file_path)) > 1000:
                        continue
                    
                    # ê¹Šì´ ì²´í¬
                    relative_path = file_path.relative_to(path)
                    if len(relative_path.parts) > max_depth:
                        continue
                    
                    # ì œì™¸ íŒ¨í„´ í™•ì¸
                    if any(pattern in str(file_path) for pattern in exclude_patterns):
                        continue
                    
                    yield file_path
            except (OSError, ValueError) as e:
                # íŒŒì¼ ì‹œìŠ¤í…œ ì˜¤ë¥˜ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
                print(f"âš ï¸  íŒŒì¼ íƒìƒ‰ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨): {e}")
                return
        
        for file_path in safe_rglob(root_path, "*.py"):
            python_files.append(file_path)
            
        self.python_files = python_files
        return python_files
    
    def verify_syntax(self, file_path: Path) -> SyntaxTestResult:
        """ê°œë³„ íŒŒì¼ì˜ êµ¬ë¬¸ì„ ê²€ì¦"""
        start_time = time.time()
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST íŒŒì‹±ìœ¼ë¡œ êµ¬ë¬¸ ê²€ì¦
            ast.parse(content)
            
            # py_compileë¡œ ì¶”ê°€ ê²€ì¦
            result = subprocess.run([
                sys.executable, '-m', 'py_compile', str(file_path)
            ], capture_output=True, text=True, timeout=30)
            
            execution_time = time.time() - start_time
            
            if result.returncode == 0:
                return SyntaxTestResult(
                    test_name=f"syntax_check_{file_path.name}",
                    success=True,
                    message="êµ¬ë¬¸ ê²€ì¦ ì„±ê³µ",
                    file_path=str(file_path),
                    execution_time=execution_time,
                    timestamp=datetime.now().isoformat()
                )
            else:
                return SyntaxTestResult(
                    test_name=f"syntax_check_{file_path.name}",
                    success=False,
                    message=f"ì»´íŒŒì¼ ì˜¤ë¥˜: {result.stderr}",
                    file_path=str(file_path),
                    error_type="compilation_error",
                    execution_time=execution_time,
                    timestamp=datetime.now().isoformat()
                )
                
        except SyntaxError as e:
            execution_time = time.time() - start_time
            return SyntaxTestResult(
                test_name=f"syntax_check_{file_path.name}",
                success=False,
                message=f"êµ¬ë¬¸ ì˜¤ë¥˜: {str(e)}",
                file_path=str(file_path),
                line_number=e.lineno or 0,
                error_type="syntax_error",
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
        except Exception as e:
            execution_time = time.time() - start_time
            return SyntaxTestResult(
                test_name=f"syntax_check_{file_path.name}",
                success=False,
                message=f"ê²€ì¦ ì‹¤íŒ¨: {str(e)}",
                file_path=str(file_path),
                error_type="verification_error",
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
    
    def verify_all_files(self, max_workers: int = 4) -> List[SyntaxTestResult]:
        """ëª¨ë“  Python íŒŒì¼ì˜ êµ¬ë¬¸ì„ ë³‘ë ¬ë¡œ ê²€ì¦"""
        if not self.python_files:
            self.discover_python_files()
            
        results = []
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_file = {
                executor.submit(self.verify_syntax, file_path): file_path 
                for file_path in self.python_files
            }
            
            for future in as_completed(future_to_file):
                file_path = future_to_file[future]
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    results.append(SyntaxTestResult(
                        test_name=f"syntax_check_{file_path.name}",
                        success=False,
                        message=f"í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}",
                        file_path=str(file_path),
                        error_type="execution_error",
                        timestamp=datetime.now().isoformat()
                    ))
        
        self.results = results
        return results
    
    def generate_syntax_report(self) -> Dict[str, Any]:
        """êµ¬ë¬¸ ê²€ì¦ ë³´ê³ ì„œ ìƒì„±"""
        if not self.results:
            return {"error": "ê²€ì¦ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. verify_all_files()ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."}
            
        total_files = len(self.results)
        successful_files = sum(1 for r in self.results if r.success)
        failed_files = total_files - successful_files
        
        error_types = {}
        for result in self.results:
            if not result.success and result.error_type:
                error_types[result.error_type] = error_types.get(result.error_type, 0) + 1
        
        return {
            "summary": {
                "total_files": total_files,
                "successful_files": successful_files,
                "failed_files": failed_files,
                "success_rate": (successful_files / total_files * 100) if total_files > 0 else 0
            },
            "error_types": error_types,
            "failed_files": [
                {
                    "file": result.file_path,
                    "error": result.message,
                    "line": result.line_number,
                    "type": result.error_type
                }
                for result in self.results if not result.success
            ],
            "execution_time": sum(r.execution_time for r in self.results),
            "timestamp": datetime.now().isoformat()
        }

class ModuleImportTestSystem:
    """ëª¨ë“ˆ Import í…ŒìŠ¤íŠ¸ ìë™í™” ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.core_modules = [
            'naming_convention_manager',
            'file_renaming_system',
            'python_naming_standardizer',
            'shell_batch_script_standardizer',
            'documentation_standardizer',
            'config_data_standardizer',
            'system_output_message_standardizer',
            'folder_structure_reorganizer',
            'naming_standardization_verification_system'
        ]
        self.results = []
        
    def test_module_import(self, module_name: str) -> ImportTestResult:
        """ê°œë³„ ëª¨ë“ˆì˜ importë¥¼ í…ŒìŠ¤íŠ¸"""
        start_time = time.time()
        
        try:
            # ê¸°ì¡´ ëª¨ë“ˆì´ ìˆë‹¤ë©´ ì œê±° (ì¬ë¡œë”©ì„ ìœ„í•´)
            if module_name in sys.modules:
                del sys.modules[module_name]
            
            # ëª¨ë“ˆ import ì‹œë„
            module = importlib.import_module(module_name)
            
            execution_time = time.time() - start_time
            
            return ImportTestResult(
                test_name=f"import_{module_name}",
                success=True,
                message="ëª¨ë“ˆ import ì„±ê³µ",
                module_name=module_name,
                import_path=getattr(module, '__file__', 'unknown'),
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
            
        except ImportError as e:
            execution_time = time.time() - start_time
            return ImportTestResult(
                test_name=f"import_{module_name}",
                success=False,
                message=f"Import ì˜¤ë¥˜: {str(e)}",
                module_name=module_name,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
        except Exception as e:
            execution_time = time.time() - start_time
            return ImportTestResult(
                test_name=f"import_{module_name}",
                success=False,
                message=f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}",
                module_name=module_name,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
    
    def test_all_core_modules(self) -> List[ImportTestResult]:
        """ëª¨ë“  í•µì‹¬ ëª¨ë“ˆì˜ importë¥¼ í…ŒìŠ¤íŠ¸"""
        results = []
        
        for module_name in self.core_modules:
            result = self.test_module_import(module_name)
            results.append(result)
            
        self.results = results
        return results
    
    def test_dependency_chain(self, module_name: str) -> ImportTestResult:
        """ëª¨ë“ˆì˜ ì˜ì¡´ì„± ì²´ì¸ì„ í…ŒìŠ¤íŠ¸"""
        start_time = time.time()
        dependency_chain = []
        
        try:
            # ëª¨ë“ˆ íŒŒì¼ ì°¾ê¸°
            module_file = None
            for py_file in Path.cwd().rglob(f"{module_name}.py"):
                module_file = py_file
                break
                
            if not module_file:
                return ImportTestResult(
                    test_name=f"dependency_{module_name}",
                    success=False,
                    message=f"ëª¨ë“ˆ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {module_name}",
                    module_name=module_name,
                    timestamp=datetime.now().isoformat()
                )
            
            # íŒŒì¼ì—ì„œ import êµ¬ë¬¸ ì¶”ì¶œ
            with open(module_file, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # import êµ¬ë¬¸ íŒŒì‹±
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        dependency_chain.append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        dependency_chain.append(node.module)
            
            execution_time = time.time() - start_time
            
            return ImportTestResult(
                test_name=f"dependency_{module_name}",
                success=True,
                message=f"ì˜ì¡´ì„± ì²´ì¸ ë¶„ì„ ì™„ë£Œ: {len(dependency_chain)}ê°œ ì˜ì¡´ì„±",
                module_name=module_name,
                dependency_chain=dependency_chain,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            return ImportTestResult(
                test_name=f"dependency_{module_name}",
                success=False,
                message=f"ì˜ì¡´ì„± ë¶„ì„ ì‹¤íŒ¨: {str(e)}",
                module_name=module_name,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
    
    def generate_import_report(self) -> Dict[str, Any]:
        """Import í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ ìƒì„±"""
        if not self.results:
            return {"error": "í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. test_all_core_modules()ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."}
            
        total_modules = len(self.results)
        successful_imports = sum(1 for r in self.results if r.success)
        failed_imports = total_modules - successful_imports
        
        return {
            "summary": {
                "total_modules": total_modules,
                "successful_imports": successful_imports,
                "failed_imports": failed_imports,
                "success_rate": (successful_imports / total_modules * 100) if total_modules > 0 else 0
            },
            "failed_modules": [
                {
                    "module": result.module_name,
                    "error": result.message
                }
                for result in self.results if not result.success
            ],
            "execution_time": sum(r.execution_time for r in self.results),
            "timestamp": datetime.now().isoformat()
        }

class FileReferenceIntegritySystem:
    """íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ìë™ ê²€ì¦ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.results = []
        self.file_references = []
        
    def scan_file_references(self, root_path: Path = None) -> List[Dict[str, Any]]:
        """ëª¨ë“  íŒŒì¼ ì°¸ì¡°ë¥¼ ìŠ¤ìº”"""
        if root_path is None:
            root_path = Path.cwd()
            
        references = []
        
        # ì œì™¸í•  ë””ë ‰í† ë¦¬ íŒ¨í„´
        exclude_patterns = [
            '__pycache__', '.git', '.vscode', 'node_modules', '.pytest_cache',
            '.backup', 'backup', '.repair_backup', '.enhanced_repair_backup',
            '.aggressive_syntax_repair_backup', '.comprehensive_repair_backup',
            '.file_reference_backup', '.file_renaming_backup', '.filename_standardization_backup',
            '.final_file_reference_cleanup_backup', '.final_reference_cleanup_backup',
            '.final_syntax_repair_backup', '.focused_file_reference_backup',
            '.indentation_backup', '.naming_backup', '.refined_file_reference_backup',
            '.repair_backups', '.syntax_repair_backup'
        ]
        
        # ì•ˆì „í•œ íŒŒì¼ íƒìƒ‰ í•¨ìˆ˜
        def safe_scan_files(path: Path, pattern: str):
            """ì•ˆì „í•œ íŒŒì¼ ìŠ¤ìº”"""
            try:
                for file_path in path.rglob(pattern):
                    # ê²½ë¡œ ê¸¸ì´ ì²´í¬
                    if len(str(file_path)) > 1000:
                        continue
                    
                    # ì œì™¸ íŒ¨í„´ í™•ì¸
                    if any(exclude_pattern in str(file_path) for exclude_pattern in exclude_patterns):
                        continue
                    
                    yield file_path
            except (OSError, ValueError):
                # íŒŒì¼ ì‹œìŠ¤í…œ ì˜¤ë¥˜ ë¬´ì‹œ
                return
        
        # Python íŒŒì¼ì—ì„œ import êµ¬ë¬¸ ìŠ¤ìº”
        for py_file in safe_scan_files(root_path, "*.py"):
                
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # import êµ¬ë¬¸ ì°¾ê¸° (ë” ì •í™•í•œ íŒ¨í„´)
                import_lines = [line.strip() for line in content.split('\n') if line.strip().startswith(('import ', 'from '))]
                for line_num, line in enumerate(content.split('\n'), 1):
                    line = line.strip()
                    if line.startswith('import ') and not line.startswith('import '):
                        continue
                    
                    # í‘œì¤€ import íŒ¨í„´
                    import_match = re.match(r'^import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)', line)
                    if import_match:
                        module_name = import_match.group(1)
                        # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ ë¡œì»¬ ëª¨ë“ˆë§Œ í¬í•¨
                        if not any(skip in module_name for skip in ['__', 'site-packages']):
                            references.append({
                                'source_file': str(py_file),
                                'referenced_file': module_name,
                                'reference_type': 'import',
                                'line_number': line_num
                            })
                    
                    # from import íŒ¨í„´
                    from_match = re.match(r'^from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import', line)
                    if from_match:
                        module_name = from_match.group(1)
                        if not any(skip in module_name for skip in ['__', 'site-packages']) and not module_name.startswith('.'):
                            references.append({
                                'source_file': str(py_file),
                                'referenced_file': module_name,
                                'reference_type': 'import',
                                'line_number': line_num
                            })
                
                # íŒŒì¼ ê²½ë¡œ ì°¸ì¡° ì°¾ê¸° (ë” ì—„ê²©í•œ íŒ¨í„´)
                # ì‹¤ì œ íŒŒì¼ ê²½ë¡œë¡œ ë³´ì´ëŠ” ê²ƒë“¤ë§Œ í¬í•¨
                path_patterns = [
                    r'open\s*\(\s*["\']([^"\']+\.(?:py|sh|bat|json|md|txt|log|csv))["\']',  # open() í•¨ìˆ˜
                    r'Path\s*\(\s*["\']([^"\']+\.(?:py|sh|bat|json|md|txt|log|csv))["\']',  # Path() í•¨ìˆ˜
                    r'["\']([^"\']*[/\\][^"\']+\.(?:py|sh|bat|json|md|txt|log|csv))["\']',  # ê²½ë¡œê°€ í¬í•¨ëœ íŒŒì¼
                    r'subprocess\.run\s*\(\s*\[["\']([^"\']+\.(?:py|sh|bat))["\']',  # subprocess ì‹¤í–‰
                ]
                
                for pattern in path_patterns:
                    for match in re.finditer(pattern, content):
                        file_path = match.group(1)
                        # ë„ˆë¬´ ê¸´ ê²½ë¡œë‚˜ íŠ¹ìˆ˜ ë¬¸ìê°€ ë§ì€ ê²½ìš° ì œì™¸
                        if len(file_path) < 200 and not any(char in file_path for char in ['*', '?', '<', '>', '|']):
                            references.append({
                                'source_file': str(py_file),
                                'referenced_file': file_path,
                                'reference_type': 'file_path',
                                'line_number': content[:match.start()].count('\n') + 1
                            })
                    
            except Exception as e:
                continue
        
        # ì„¤ì • íŒŒì¼ì—ì„œ íŒŒì¼ ì°¸ì¡° ìŠ¤ìº”
        for config_file in safe_scan_files(root_path, "*.json"):
                
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # JSON ë‚´ íŒŒì¼ ê²½ë¡œ ì°¾ê¸° (ë” ì •í™•í•œ íŒ¨í„´)
                try:
                    import json
                    json_data = json.loads(content)
                    
                    def extract_file_paths(obj, path=""):
                        """JSON ê°ì²´ì—ì„œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ"""
                        if isinstance(obj, dict):
                            for key, value in obj.items():
                                if isinstance(value, str) and any(ext in value for ext in ['.py', '.sh', '.bat', '.json', '.md', '.txt', '.log']):
                                    if len(value) < 200 and '/' in value or '\\' in value or value.endswith(('.py', '.sh', '.bat', '.json', '.md', '.txt', '.log')):
                                        references.append({
                                            'source_file': str(config_file),
                                            'referenced_file': value,
                                            'reference_type': 'config',
                                            'line_number': 1  # JSONì—ì„œëŠ” ì •í™•í•œ ë¼ì¸ ë²ˆí˜¸ ì¶”ì ì´ ì–´ë ¤ì›€
                                        })
                                elif isinstance(value, (dict, list)):
                                    extract_file_paths(value, f"{path}.{key}" if path else key)
                        elif isinstance(obj, list):
                            for i, item in enumerate(obj):
                                if isinstance(item, (dict, list)):
                                    extract_file_paths(item, f"{path}[{i}]")
                    
                    extract_file_paths(json_data)
                    
                except (json.JSONDecodeError, UnicodeDecodeError):
                    # JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ íŒ¨í„´ìœ¼ë¡œ ëŒ€ì²´
                    path_pattern = r'"([^"]+\.(?:py|sh|bat|json|md|txt|log))"'
                    for match in re.finditer(path_pattern, content):
                        file_path = match.group(1)
                        if len(file_path) < 200:
                            references.append({
                                'source_file': str(config_file),
                                'referenced_file': file_path,
                                'reference_type': 'config',
                                'line_number': content[:match.start()].count('\n') + 1
                            })
                    
            except Exception as e:
                continue
        
        self.file_references = references
        return references
    
    def verify_reference(self, reference: Dict[str, Any]) -> FileReferenceTestResult:
        """ê°œë³„ íŒŒì¼ ì°¸ì¡°ë¥¼ ê²€ì¦"""
        start_time = time.time()
        
        source_file = reference['source_file']
        referenced_file = reference['referenced_file']
        reference_type = reference['reference_type']
        
        try:
            if reference_type == 'import':
                # ëª¨ë“ˆ import ê²€ì¦
                try:
                    importlib.import_module(referenced_file)
                    success = True
                    message = "ëª¨ë“ˆ ì°¸ì¡° ìœ íš¨"
                except ImportError:
                    # ë¡œì»¬ ëª¨ë“ˆì¸ì§€ í™•ì¸
                    local_file = Path(referenced_file + '.py')
                    if local_file.exists():
                        success = True
                        message = "ë¡œì»¬ ëª¨ë“ˆ ì°¸ì¡° ìœ íš¨"
                    else:
                        success = False
                        message = f"ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {referenced_file}"
                        
            else:
                # íŒŒì¼ ê²½ë¡œ ê²€ì¦
                ref_path = Path(referenced_file)
                if not ref_path.is_absolute():
                    # ìƒëŒ€ ê²½ë¡œì¸ ê²½ìš° ì†ŒìŠ¤ íŒŒì¼ ê¸°ì¤€ìœ¼ë¡œ í•´ì„
                    source_dir = Path(source_file).parent
                    ref_path = source_dir / ref_path
                
                if ref_path.exists():
                    success = True
                    message = "íŒŒì¼ ì°¸ì¡° ìœ íš¨"
                else:
                    success = False
                    message = f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {referenced_file}"
            
            execution_time = time.time() - start_time
            
            return FileReferenceTestResult(
                test_name=f"reference_{Path(source_file).name}_{referenced_file}",
                success=success,
                message=message,
                source_file=source_file,
                referenced_file=referenced_file,
                reference_type=reference_type,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            return FileReferenceTestResult(
                test_name=f"reference_{Path(source_file).name}_{referenced_file}",
                success=False,
                message=f"ê²€ì¦ ì‹¤íŒ¨: {str(e)}",
                source_file=source_file,
                referenced_file=referenced_file,
                reference_type=reference_type,
                execution_time=execution_time,
                timestamp=datetime.now().isoformat()
            )
    
    def verify_all_references(self, max_workers: int = 4, show_progress: bool = True) -> List[FileReferenceTestResult]:
        """ëª¨ë“  íŒŒì¼ ì°¸ì¡°ë¥¼ ë³‘ë ¬ë¡œ ê²€ì¦"""
        if not self.file_references:
            self.scan_file_references()
            
        total_refs = len(self.file_references)
        if total_refs == 0:
            return []
        
        # ë„ˆë¬´ ë§ì€ ì°¸ì¡°ê°€ ìˆìœ¼ë©´ ê²½ê³ í•˜ê³  ìƒ˜í”Œë§
        if total_refs > 10000:
            print(f"âš ï¸  ì°¸ì¡°ê°€ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤ ({total_refs}ê°œ). ì²˜ìŒ 5000ê°œë§Œ ê²€ì¦í•©ë‹ˆë‹¤.")
            self.file_references = self.file_references[:5000]
            total_refs = 5000
        
        results = []
        completed = 0
        
        # ì ì ˆí•œ ì›Œì»¤ ìˆ˜ ì¡°ì • (ë„ˆë¬´ ë§ìœ¼ë©´ ì˜¤íˆë ¤ ëŠë ¤ì§)
        optimal_workers = min(max_workers, max(1, total_refs // 100))
        
        with ThreadPoolExecutor(max_workers=optimal_workers) as executor:
            future_to_ref = {
                executor.submit(self.verify_reference, ref): ref 
                for ref in self.file_references
            }
            
            for future in as_completed(future_to_ref):
                reference = future_to_ref[future]
                completed += 1
                
                # ì§„í–‰ë¥  í‘œì‹œ
                if show_progress and completed % max(1, total_refs // 20) == 0:
                    progress = (completed / total_refs) * 100
                    print(f"  ì§„í–‰ë¥ : {progress:.1f}% ({completed}/{total_refs})")
                
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    results.append(FileReferenceTestResult(
                        test_name=f"reference_error",
                        success=False,
                        message=f"í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}",
                        source_file=reference.get('source_file', ''),
                        referenced_file=reference.get('referenced_file', ''),
                        reference_type=reference.get('reference_type', ''),
                        timestamp=datetime.now().isoformat()
                    ))
        
        if show_progress:
            print(f"  ì™„ë£Œ: 100.0% ({total_refs}/{total_refs})")
        
        self.results = results
        return results
    
    def generate_integrity_report(self) -> Dict[str, Any]:
        """íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± ë³´ê³ ì„œ ìƒì„±"""
        if not self.results:
            return {"error": "ê²€ì¦ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. verify_all_references()ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."}
            
        total_references = len(self.results)
        valid_references = sum(1 for r in self.results if r.success)
        broken_references = total_references - valid_references
        
        reference_types = {}
        for result in self.results:
            ref_type = result.reference_type
            if ref_type not in reference_types:
                reference_types[ref_type] = {'total': 0, 'valid': 0, 'broken': 0}
            reference_types[ref_type]['total'] += 1
            if result.success:
                reference_types[ref_type]['valid'] += 1
            else:
                reference_types[ref_type]['broken'] += 1
        
        return {
            "summary": {
                "total_references": total_references,
                "valid_references": valid_references,
                "broken_references": broken_references,
                "integrity_rate": (valid_references / total_references * 100) if total_references > 0 else 0
            },
            "by_type": reference_types,
            "broken_references": [
                {
                    "source": result.source_file,
                    "reference": result.referenced_file,
                    "type": result.reference_type,
                    "error": result.message
                }
                for result in self.results if not result.success
            ],
            "execution_time": sum(r.execution_time for r in self.results),
            "timestamp": datetime.now().isoformat()
        }

class PerformanceMonitoringSystem:
    """ì„±ëŠ¥ ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.monitoring_active = False
        self.monitoring_thread = None
        self.performance_data = []
        self.results = []
        
    def start_monitoring(self, interval: float = 1.0):
        """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.monitoring_active = True
        self.monitoring_thread = threading.Thread(
            target=self._monitor_performance, 
            args=(interval,)
        )
        self.monitoring_thread.start()
    
    def stop_monitoring(self):
        """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.monitoring_active = False
        if self.monitoring_thread:
            self.monitoring_thread.join()
    
    def _monitor_performance(self, interval: float):
        """ì„±ëŠ¥ ë°ì´í„°ë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ìˆ˜ì§‘"""
        while self.monitoring_active:
            try:
                # CPU ì‚¬ìš©ë¥ 
                cpu_percent = psutil.cpu_percent(interval=0.1)
                
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
                memory = psutil.virtual_memory()
                memory_percent = memory.percent
                memory_used_mb = memory.used / (1024 * 1024)
                
                # ë””ìŠ¤í¬ I/O
                disk_io = psutil.disk_io_counters()
                disk_data = {
                    'read_bytes': disk_io.read_bytes if disk_io else 0,
                    'write_bytes': disk_io.write_bytes if disk_io else 0
                }
                
                # ë„¤íŠ¸ì›Œí¬ I/O
                net_io = psutil.net_io_counters()
                network_data = {
                    'bytes_sent': net_io.bytes_sent if net_io else 0,
                    'bytes_recv': net_io.bytes_recv if net_io else 0
                }
                
                # í”„ë¡œì„¸ìŠ¤ë³„ ì •ë³´
                current_process = psutil.Process()
                process_memory = current_process.memory_info().rss / (1024 * 1024)  # MB
                
                performance_point = {
                    'timestamp': datetime.now().isoformat(),
                    'cpu_percent': cpu_percent,
                    'memory_percent': memory_percent,
                    'memory_used_mb': memory_used_mb,
                    'process_memory_mb': process_memory,
                    'disk_io': disk_data,
                    'network_io': network_data
                }
                
                self.performance_data.append(performance_point)
                
                time.sleep(interval)
                
            except Exception as e:
                print(f"ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
                time.sleep(interval)
    
    def run_performance_test(self, test_function, test_name: str = "performance_test") -> PerformanceTestResult:
        """íŠ¹ì • í•¨ìˆ˜ì˜ ì„±ëŠ¥ì„ í…ŒìŠ¤íŠ¸"""
        # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì‹¤í–‰
        gc.collect()
        
        # ì´ˆê¸° ìƒíƒœ ì¸¡ì •
        initial_memory = psutil.virtual_memory().used / (1024 * 1024)
        initial_process_memory = psutil.Process().memory_info().rss / (1024 * 1024)
        
        # ëª¨ë‹ˆí„°ë§ ì‹œì‘
        self.performance_data = []
        self.start_monitoring(0.5)
        
        start_time = time.time()
        
        try:
            # í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ ì‹¤í–‰
            result = test_function()
            success = True
            message = "ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì™„ë£Œ"
        except Exception as e:
            result = None
            success = False
            message = f"í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}"
        
        execution_time = time.time() - start_time
        
        # ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
        self.stop_monitoring()
        
        # ìµœì¢… ìƒíƒœ ì¸¡ì •
        final_memory = psutil.virtual_memory().used / (1024 * 1024)
        final_process_memory = psutil.Process().memory_info().rss / (1024 * 1024)
        
        # ì„±ëŠ¥ ë°ì´í„° ë¶„ì„
        if self.performance_data:
            avg_cpu = sum(p['cpu_percent'] for p in self.performance_data) / len(self.performance_data)
            max_cpu = max(p['cpu_percent'] for p in self.performance_data)
            avg_memory = sum(p['memory_percent'] for p in self.performance_data) / len(self.performance_data)
            max_memory = max(p['memory_percent'] for p in self.performance_data)
        else:
            avg_cpu = max_cpu = avg_memory = max_memory = 0
        
        performance_result = PerformanceTestResult(
            test_name=test_name,
            success=success,
            message=message,
            cpu_usage=avg_cpu,
            memory_usage=avg_memory,
            execution_time=execution_time,
            details={
                'max_cpu_usage': max_cpu,
                'max_memory_usage': max_memory,
                'memory_delta_mb': final_memory - initial_memory,
                'process_memory_delta_mb': final_process_memory - initial_process_memory,
                'data_points': len(self.performance_data),
                'result': str(result) if result else None
            },
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(performance_result)
        return performance_result
    
    def generate_performance_report(self) -> Dict[str, Any]:
        """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ ìƒì„±"""
        if not self.results:
            return {"error": "ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."}
            
        total_tests = len(self.results)
        successful_tests = sum(1 for r in self.results if r.success)
        
        avg_cpu = sum(r.cpu_usage for r in self.results) / total_tests
        avg_memory = sum(r.memory_usage for r in self.results) / total_tests
        total_execution_time = sum(r.execution_time for r in self.results)
        
        return {
            "summary": {
                "total_tests": total_tests,
                "successful_tests": successful_tests,
                "average_cpu_usage": avg_cpu,
                "average_memory_usage": avg_memory,
                "total_execution_time": total_execution_time
            },
            "test_results": [
                {
                    "test_name": result.test_name,
                    "success": result.success,
                    "cpu_usage": result.cpu_usage,
                    "memory_usage": result.memory_usage,
                    "execution_time": result.execution_time,
                    "details": result.details
                }
                for result in self.results
            ],
            "timestamp": datetime.now().isoformat()
        }

class ComprehensiveTestSystem:
    """ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ - ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì„ í†µí•©"""
    
    def __init__(self):
        self.syntax_system = SyntaxVerificationSystem()
        self.import_system = ModuleImportTestSystem()
        self.reference_system = FileReferenceIntegritySystem()
        self.performance_system = PerformanceMonitoringSystem()
        
    def run_all_tests(self, include_performance: bool = True) -> Dict[str, Any]:
        """ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ê³  ì¢…í•© ë³´ê³ ì„œ ìƒì„±"""
        print("ğŸš€ POSCO ì‹œìŠ¤í…œ ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        
        overall_start_time = time.time()
        test_results = {}
        
        # 1. êµ¬ë¬¸ ê²€ì¦ í…ŒìŠ¤íŠ¸
        print("\nğŸ“ êµ¬ë¬¸ ê²€ì¦ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        try:
            self.syntax_system.verify_all_files()
            syntax_report = self.syntax_system.generate_syntax_report()
            test_results['syntax_verification'] = syntax_report
            print(f"   âœ… êµ¬ë¬¸ ê²€ì¦ ì™„ë£Œ: {syntax_report['summary']['success_rate']:.1f}% ì„±ê³µ")
        except Exception as e:
            test_results['syntax_verification'] = {"error": str(e)}
            print(f"   âŒ êµ¬ë¬¸ ê²€ì¦ ì‹¤íŒ¨: {e}")
        
        # 2. ëª¨ë“ˆ Import í…ŒìŠ¤íŠ¸
        print("\nğŸ“¦ ëª¨ë“ˆ Import í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        try:
            self.import_system.test_all_core_modules()
            import_report = self.import_system.generate_import_report()
            test_results['module_import'] = import_report
            print(f"   âœ… Import í…ŒìŠ¤íŠ¸ ì™„ë£Œ: {import_report['summary']['success_rate']:.1f}% ì„±ê³µ")
        except Exception as e:
            test_results['module_import'] = {"error": str(e)}
            print(f"   âŒ Import í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        
        # 3. íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± í…ŒìŠ¤íŠ¸
        print("\nğŸ”— íŒŒì¼ ì°¸ì¡° ë¬´ê²°ì„± í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        try:
            self.reference_system.verify_all_references()
            integrity_report = self.reference_system.generate_integrity_report()
            test_results['file_reference_integrity'] = integrity_report
            print(f"   âœ… ì°¸ì¡° ë¬´ê²°ì„± ì™„ë£Œ: {integrity_report['summary']['integrity_rate']:.1f}% ìœ íš¨")
        except Exception as e:
            test_results['file_reference_integrity'] = {"error": str(e)}
            print(f"   âŒ ì°¸ì¡° ë¬´ê²°ì„± í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        
        # 4. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ (ì„ íƒì )
        if include_performance:
            print("\nâš¡ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
            try:
                # ìƒ˜í”Œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                def sample_test():
                    time.sleep(2)  # 2ì´ˆ ëŒ€ê¸°
                    return "ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì™„ë£Œ"
                
                perf_result = self.performance_system.run_performance_test(
                    sample_test, "comprehensive_test_performance"
                )
                performance_report = self.performance_system.generate_performance_report()
                test_results['performance_monitoring'] = performance_report
                print(f"   âœ… ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì™„ë£Œ: CPU {perf_result.cpu_usage:.1f}%, ë©”ëª¨ë¦¬ {perf_result.memory_usage:.1f}%")
            except Exception as e:
                test_results['performance_monitoring'] = {"error": str(e)}
                print(f"   âŒ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹¤íŒ¨: {e}")
        
        overall_execution_time = time.time() - overall_start_time
        
        # ì¢…í•© ë³´ê³ ì„œ ìƒì„±
        comprehensive_report = {
            "test_summary": {
                "execution_time": overall_execution_time,
                "timestamp": datetime.now().isoformat(),
                "tests_run": len(test_results),
                "overall_success": all(
                    'error' not in result for result in test_results.values()
                )
            },
            "detailed_results": test_results
        }
        
        print(f"\nğŸ¯ ì¢…í•© í…ŒìŠ¤íŠ¸ ì™„ë£Œ! ì´ ì‹¤í–‰ ì‹œê°„: {overall_execution_time:.2f}ì´ˆ")
        
        return comprehensive_report
    
    def save_report(self, report: Dict[str, Any], filename: str = None) -> str:
        """í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œë¥¼ íŒŒì¼ë¡œ ì €ì¥"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"comprehensive_test_report_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        return filename

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ”§ POSCO ì‹œìŠ¤í…œ ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ")
    print("=" * 50)
    
    # ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    test_system = ComprehensiveTestSystem()
    
    # ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    report = test_system.run_all_tests(include_performance=True)
    
    # ë³´ê³ ì„œ ì €ì¥
    report_file = test_system.save_report(report)
    print(f"\nğŸ“Š í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ ì €ì¥ë¨: {report_file}")
    
    # ìš”ì•½ ì¶œë ¥
    print("\nğŸ“‹ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½:")
    print("-" * 30)
    
    if 'syntax_verification' in report['detailed_results']:
        syntax_data = report['detailed_results']['syntax_verification']
        if 'summary' in syntax_data:
            print(f"êµ¬ë¬¸ ê²€ì¦: {syntax_data['summary']['success_rate']:.1f}% ì„±ê³µ "
                  f"({syntax_data['summary']['successful_files']}/{syntax_data['summary']['total_files']})")
    
    if 'module_import' in report['detailed_results']:
        import_data = report['detailed_results']['module_import']
        if 'summary' in import_data:
            print(f"ëª¨ë“ˆ Import: {import_data['summary']['success_rate']:.1f}% ì„±ê³µ "
                  f"({import_data['summary']['successful_imports']}/{import_data['summary']['total_modules']})")
    
    if 'file_reference_integrity' in report['detailed_results']:
        integrity_data = report['detailed_results']['file_reference_integrity']
        if 'summary' in integrity_data:
            print(f"íŒŒì¼ ì°¸ì¡°: {integrity_data['summary']['integrity_rate']:.1f}% ìœ íš¨ "
                  f"({integrity_data['summary']['valid_references']}/{integrity_data['summary']['total_references']})")
    
    if 'performance_monitoring' in report['detailed_results']:
        perf_data = report['detailed_results']['performance_monitoring']
        if 'summary' in perf_data:
            print(f"ì„±ëŠ¥ í…ŒìŠ¤íŠ¸: {perf_data['summary']['successful_tests']}/{perf_data['summary']['total_tests']} ì„±ê³µ")
    
    print(f"\nì „ì²´ ì‹¤í–‰ ì‹œê°„: {report['test_summary']['execution_time']:.2f}ì´ˆ")
    print(f"ì „ì²´ ì„±ê³µ ì—¬ë¶€: {'âœ… ì„±ê³µ' if report['test_summary']['overall_success'] else 'âŒ ì‹¤íŒ¨'}")

if __name__ == "__main__":
    main()