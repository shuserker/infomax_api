#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Execute Test Scenario
POSCO 시스템 테스트

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import os
import sys
import json
import argparse
import subprocess
import time
from datetime import datetime
from typing import Dict, List, Optional

class TestScenarioExecutor:
    """테스트 시나리오 실행기"""
    
    def __init__(self, config_file: str = 'test_config.json'):
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = os.path.join(self.script_dir, config_file)
        self.config = self.load_config()
        self.results = []
        
    def load_config(self) -> Dict:
        """설정 파일 로드"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"⚠️ 설정 파일을 찾을 수 없습니다: {self.config_file}")
            return self.get_default_config()
        except json.JSONDecodeError as e:
            print(f"❌ 설정 파일 파싱 오류: {e}")
            return self.get_default_config()
    
    def get_default_config(self) -> Dict:
        """기본 설정 반환"""
        return {
            "end_to_end_test_config": {
                "test_categories": {
                    "system_test": {
                        "name": "전체 시스템 테스트",
                        "timeout": 180,
                        "critical": True
                    },
                    "stress_test": {
                        "name": "스트레스 테스트", 
                        "timeout": 300,
                        "critical": True
                    }
                }
            }
        }
    
    def list_available_scenarios(self):
        """사용 가능한 테스트 시나리오 목록 출력"""
        print("📋 사용 가능한 테스트 시나리오:")
        print("="*60)
        
        test_config = self.config.get('end_to_end_test_config', {})
        categories = test_config.get('test_categories', {})
        
        for i, (key, category) in enumerate(categories.items(), 1):
            name = category.get('name', key)
            description = category.get('description', '설명 없음')
            timeout = category.get('timeout', 60)
            critical = "🔴 중요" if category.get('critical', False) else "🟡 일반"
            
            print(f"{i}. {name} ({critical})")
            print(f"   키: {key}")
            print(f"   설명: {description}")
            print(f"   타임아웃: {timeout}초")
            print()
    
    def execute_scenario(self, scenario_key: str, custom_timeout: Optional[int] = None) -> Dict:
        """특정 시나리오 실행"""
        test_config = self.config.get('end_to_end_test_config', {})
        categories = test_config.get('test_categories', {})
        
        if scenario_key not in categories:
            return {
                'scenario': scenario_key,
                'success': False,
                'error': f"시나리오를 찾을 수 없습니다: {scenario_key}",
                'duration': 0
            }
        
        category = categories[scenario_key]
        scenario_name = category.get('name', scenario_key)
        timeout = custom_timeout or category.get('timeout', 300)
        
        print(f"🧪 {scenario_name} 실행 중...")
        print(f"   타임아웃: {timeout}초")
        print(f"   시작 시간: {datetime.now().strftime('%H:%M:%S')}")
        
        start_time = time.time()
        
        try:
            # 테스트 스크립트 실행
            test_script = os.path.join(self.script_dir, 'test_end_to_end_integration.py')
            
            if not os.path.exists(test_script):
                raise FileNotFoundError(f"테스트 스크립트를 찾을 수 없습니다: {test_script}")
            
            # 환경 변수 설정
            env = os.environ.copy()
            env['TEST_SCENARIO'] = scenario_key
            env['TEST_MODE'] = '1'
            
            # 테스트 실행
            result = subprocess.run([
                sys.executable, test_script
            ], capture_output=True, text=True, timeout=timeout,
            cwd=self.script_dir, env=env)
            
            end_time = time.time()
            duration = end_time - start_time
            
            success = result.returncode == 0
            
            # 결과 분석
            test_stats = self.analyze_output(result.stdout)
            
            scenario_result = {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': success,
                'return_code': result.returncode,
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat(),
                'test_stats': test_stats,
                'stdout_length': len(result.stdout),
                'stderr_length': len(result.stderr)
            }
            
            if not success:
                scenario_result['error'] = f"테스트 실패 (return code: {result.returncode})"
                if result.stderr:
                    scenario_result['error_details'] = result.stderr[:1000]  # 처음 1000자만
            
            # 결과 출력
            status = "✅ 성공" if success else "❌ 실패"
            print(f"{status} {scenario_name}")
            print(f"   소요시간: {duration:.2f}초")
            print(f"   테스트 통계: {test_stats}")
            
            if not success and result.stderr:
                print(f"   오류: {result.stderr[:200]}...")
            
            return scenario_result
            
        except subprocess.TimeoutExpired:
            end_time = time.time()
            duration = end_time - start_time
            
            print(f"⏰ {scenario_name} 타임아웃 ({timeout}초)")
            
            return {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': False,
                'error': f"테스트 타임아웃 ({timeout}초)",
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat()
            }
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            
            print(f"❌ {scenario_name} 실행 중 오류: {e}")
            
            return {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': False,
                'error': str(e),
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat()
            }
    
    def analyze_output(self, output: str) -> Dict:
        """테스트 출력 분석"""
        stats = {
            'total_tests': 0,
            'passed': 0,
            'failed': 0,
            'errors': 0,
            'success_rate': 0.0
        }
        
        lines = output.split('\n')
        
        for line in lines:
            # unittest 결과 패턴 찾기
            if 'Ran' in line and 'test' in line:
                try:
                    parts = line.split()
                    if len(parts) >= 2 and parts[0] == 'Ran':
                        stats['total_tests'] = int(parts[1])
                except (ValueError, IndexError):
                    pass
            
            elif 'FAILED' in line:
                # 실패 정보 추출
                if 'failures=' in line:
                    try:
                        failures_part = line.split('failures=')[1].split(',')[0].split(')')[0]
                        stats['failed'] = int(failures_part)
                    except (ValueError, IndexError):
                        pass
                
                if 'errors=' in line:
                    try:
                        errors_part = line.split('errors=')[1].split(',')[0].split(')')[0]
                        stats['errors'] = int(errors_part)
                    except (ValueError, IndexError):
                        pass
            
            elif line.strip() == 'OK' and stats['total_tests'] > 0:
                stats['passed'] = stats['total_tests']
        
        # 성공한 테스트 수 계산
        if stats['passed'] == 0 and stats['total_tests'] > 0:
            stats['passed'] = stats['total_tests'] - stats['failed'] - stats['errors']
        
        # 성공률 계산
        if stats['total_tests'] > 0:
            stats['success_rate'] = (stats['passed'] / stats['total_tests']) * 100
        
        return stats
    
    def execute_multiple_scenarios(self, scenario_keys: List[str], 
                                 custom_timeout: Optional[int] = None) -> List[Dict]:
        """여러 시나리오 순차 실행"""
        print(f"🚀 {len(scenario_keys)}개 시나리오 순차 실행 시작")
        print("="*60)
        
        results = []
        
        for i, scenario_key in enumerate(scenario_keys, 1):
            print(f"\n📋 시나리오 {i}/{len(scenario_keys)}: {scenario_key}")
            print("-"*40)
            
            result = self.execute_scenario(scenario_key, custom_timeout)
            results.append(result)
            
            # 중간 결과 요약
            if result['success']:
                print(f"✅ {scenario_key} 완료")
            else:
                print(f"❌ {scenario_key} 실패: {result.get('error', 'Unknown error')}")
        
        return results
    
    def generate_summary_report(self, results: List[Dict]) -> str:
        """요약 보고서 생성"""
        total_scenarios = len(results)
        successful_scenarios = sum(1 for r in results if r['success'])
        total_duration = sum(r['duration'] for r in results)
        
        # 테스트 통계 집계
        total_tests = sum(r.get('test_stats', {}).get('total_tests', 0) for r in results)
        total_passed = sum(r.get('test_stats', {}).get('passed', 0) for r in results)
        total_failed = sum(r.get('test_stats', {}).get('failed', 0) for r in results)
        total_errors = sum(r.get('test_stats', {}).get('errors', 0) for r in results)
        
        overall_success_rate = (total_passed / total_tests * 100) if total_tests > 0 else 0
        
        report = f"""
📊 테스트 시나리오 실행 결과 요약
{'='*60}

🎯 실행 통계
• 총 시나리오: {total_scenarios}개
• 성공한 시나리오: {successful_scenarios}개
• 실패한 시나리오: {total_scenarios - successful_scenarios}개
• 시나리오 성공률: {(successful_scenarios/total_scenarios*100):.1f}%
• 총 소요시간: {total_duration:.2f}초

📈 개별 테스트 통계
• 총 테스트: {total_tests}개
• 성공: {total_passed}개
• 실패: {total_failed}개
• 오류: {total_errors}개
• 전체 성공률: {overall_success_rate:.1f}%

📋 시나리오별 상세 결과
{'-'*60}
"""
        
        for result in results:
            status = "✅" if result['success'] else "❌"
            name = result.get('name', result['scenario'])
            duration = result['duration']
            
            report += f"""
{status} {name}
• 시나리오 키: {result['scenario']}
• 소요시간: {duration:.2f}초
"""
            
            if 'test_stats' in result:
                stats = result['test_stats']
                report += f"• 테스트 결과: {stats['passed']}/{stats['total_tests']} 성공 ({stats['success_rate']:.1f}%)\n"
            
            if not result['success']:
                error = result.get('error', 'Unknown error')
                report += f"• 오류: {error}\n"
        
        # 권장사항
        report += f"""
{'-'*60}
🔧 권장사항
{'-'*60}
"""
        
        if successful_scenarios == total_scenarios:
            report += """
✅ 모든 시나리오가 성공했습니다!
• 시스템이 모든 테스트 조건에서 안정적으로 동작합니다.
• 추가 테스트나 프로덕션 배포를 진행할 수 있습니다.
"""
        elif successful_scenarios >= total_scenarios * 0.8:
            report += """
⚠️ 대부분의 시나리오가 성공했지만 일부 개선이 필요합니다.
• 실패한 시나리오를 분석하고 수정하세요.
• 수정 후 해당 시나리오를 재실행하여 검증하세요.
"""
        else:
            report += """
❌ 다수의 시나리오가 실패했습니다.
• 시스템에 심각한 문제가 있을 수 있습니다.
• 실패한 모든 시나리오를 우선적으로 분석하고 수정하세요.
• 전체 시스템 점검을 권장합니다.
"""
        
        return report
    
    def save_results(self, results: List[Dict], filename: str = None):
        """결과를 JSON 파일로 저장"""
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'test_scenario_results_{timestamp}.json'
        
        filepath = os.path.join(self.script_dir, filename)
        
        session_data = {
            'execution_time': datetime.now().isoformat(),
            'total_scenarios': len(results),
            'successful_scenarios': sum(1 for r in results if r['success']),
            'total_duration': sum(r['duration'] for r in results),
            'results': results
        }
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            print(f"📁 결과 저장: {filepath}")
            
        except Exception as e:
            print(f"⚠️ 결과 저장 실패: {e}")


def main():
    """메인 함수"""
    parser = argparse.ArgumentParser(
        description='POSCO WatchHamster v3.0 테스트 시나리오 실행기',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
사용 예시:
  python execute_test_scenario.py --list                    # 사용 가능한 시나리오 목록
  python execute_test_scenario.py --scenario system_test    # 특정 시나리오 실행
  python execute_test_scenario.py --all                     # 모든 시나리오 실행
  python execute_test_scenario.py --scenario stress_test --timeout 600  # 타임아웃 설정
        """
    )
    
    parser.add_argument('--list', action='store_true',
                       help='사용 가능한 테스트 시나리오 목록 출력')
    parser.add_argument('--scenario', type=str,
                       help='실행할 테스트 시나리오 키')
    parser.add_argument('--scenarios', nargs='+',
                       help='실행할 여러 테스트 시나리오 키들')
    parser.add_argument('--all', action='store_true',
                       help='모든 테스트 시나리오 실행')
    parser.add_argument('--timeout', type=int,
                       help='테스트 타임아웃 (초)')
    parser.add_argument('--config', type=str, default='test_config.json',
                       help='설정 파일 경로')
    parser.add_argument('--save', type=str,
                       help='결과 저장 파일명')
    
    args = parser.parse_args()
    
    try:
        executor = TestScenarioExecutor(args.config)
        
        if args.list:
            executor.list_available_scenarios()
            return 0
        
        results = []
        
        if args.scenario:
            # 단일 시나리오 실행
            result = executor.execute_scenario(args.scenario, args.timeout)
            results = [result]
            
        elif args.scenarios:
            # 여러 시나리오 실행
            results = executor.execute_multiple_scenarios(args.scenarios, args.timeout)
            
        elif args.all:
            # 모든 시나리오 실행
            test_config = executor.config.get('end_to_end_test_config', {})
            all_scenarios = list(test_config.get('test_categories', {}).keys())
            results = executor.execute_multiple_scenarios(all_scenarios, args.timeout)
            
        else:
            print("❌ 실행할 시나리오를 지정하세요. --help 옵션으로 사용법을 확인하세요.")
            return 1
        
        if results:
            # 요약 보고서 출력
            print("\n" + "="*80)
            summary_report = executor.generate_summary_report(results)
            print(summary_report)
            
            # 결과 저장
            executor.save_results(results, args.save)
            
            # 전체 성공 여부 반환
            successful_count = sum(1 for r in results if r['success'])
            success_rate = (successful_count / len(results) * 100) if results else 0
            
            if success_rate >= 80:
                print("\n🎉 테스트 시나리오 실행이 성공적으로 완료되었습니다!")
                return 0
            else:
                print("\n❌ 테스트 시나리오에서 문제가 발견되었습니다.")
                return 1
        
        return 0
        
    except KeyboardInterrupt:
        print("\n⚠️ 테스트가 사용자에 의해 중단되었습니다.")
        return 1
        
    except Exception as e:
        print(f"\n❌ 테스트 실행 중 오류 발생: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())