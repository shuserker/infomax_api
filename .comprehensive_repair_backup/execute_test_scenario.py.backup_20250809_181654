#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Execute Test Scenario
POSCO ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import os
import sys
import json
import argparse
import subprocess
import time
from datetime import datetime
from typing import Dict, List, Optional

class TestScenarioExecutor:
    """í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ê¸°"""
    
    def __init__(self, config_file: str = 'test_config.json'):
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = os.path.join(self.script_dir, config_file)
        self.config = self.load_config()
        self.results = []
        
    def load_config(self) -> Dict:
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"âš ï¸ ì„¤ì • íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {self.config_file}")
            return self.get_default_config()
        except json.JSONDecodeError as e:
            print(f"âŒ ì„¤ì • íŒŒì¼ íŒŒì‹± ì˜¤ë¥˜: {e}")
            return self.get_default_config()
    
    def get_default_config(self) -> Dict:
        """ê¸°ë³¸ ì„¤ì • ë°˜í™˜"""
        return {
            "end_to_end_test_config": {
                "test_categories": {
                    "system_test": {
                        "name": "ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸",
                        "timeout": 180,
                        "critical": True
                    },
                    "stress_test": {
                        "name": "ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸", 
                        "timeout": 300,
                        "critical": True
                    }
                }
            }
        }
    
    def list_available_scenarios(self):
        """ì‚¬ìš© ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ëª©ë¡ ì¶œë ¥"""
        print("ğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤:")
        print("="*60)
        
        test_config = self.config.get('end_to_end_test_config', {})
        categories = test_config.get('test_categories', {})
        
        for i, (key, category) in enumerate(categories.items(), 1):
            name = category.get('name', key)
            description = category.get('description', 'ì„¤ëª… ì—†ìŒ')
            timeout = category.get('timeout', 60)
            critical = "ğŸ”´ ì¤‘ìš”" if category.get('critical', False) else "ğŸŸ¡ ì¼ë°˜"
            
            print(f"{i}. {name} ({critical})")
            print(f"   í‚¤: {key}")
            print(f"   ì„¤ëª…: {description}")
            print(f"   íƒ€ì„ì•„ì›ƒ: {timeout}ì´ˆ")
            print()
    
    def execute_scenario(self, scenario_key: str, custom_timeout: Optional[int] = None) -> Dict:
        """íŠ¹ì • ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰"""
        test_config = self.config.get('end_to_end_test_config', {})
        categories = test_config.get('test_categories', {})
        
        if scenario_key not in categories:
            return {
                'scenario': scenario_key,
                'success': False,
                'error': f"ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {scenario_key}",
                'duration': 0
            }
        
        category = categories[scenario_key]
        scenario_name = category.get('name', scenario_key)
        timeout = custom_timeout or category.get('timeout', 300)
        
        print(f"ğŸ§ª {scenario_name} ì‹¤í–‰ ì¤‘...")
        print(f"   íƒ€ì„ì•„ì›ƒ: {timeout}ì´ˆ")
        print(f"   ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%H:%M:%S')}")
        
        start_time = time.time()
        
        try:
            # í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
            test_script = os.path.join(self.script_dir, 'test_end_to_end_integration.py')
            
            if not os.path.exists(test_script):
                raise FileNotFoundError(f"í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {test_script}")
            
            # í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
            env = os.environ.copy()
            env['TEST_SCENARIO'] = scenario_key
            env['TEST_MODE'] = '1'
            
            # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
            result = subprocess.run([
                sys.executable, test_script
            ], capture_output=True, text=True, timeout=timeout,
            cwd=self.script_dir, env=env)
            
            end_time = time.time()
            duration = end_time - start_time
            
            success = result.returncode == 0
            
            # ê²°ê³¼ ë¶„ì„
            test_stats = self.analyze_output(result.stdout)
            
            scenario_result = {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': success,
                'return_code': result.returncode,
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat(),
                'test_stats': test_stats,
                'stdout_length': len(result.stdout),
                'stderr_length': len(result.stderr)
            }
            
            if not success:
                scenario_result['error'] = f"í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ (return code: {result.returncode})"
                if result.stderr:
                    scenario_result['error_details'] = result.stderr[:1000]  # ì²˜ìŒ 1000ìë§Œ
            
            # ê²°ê³¼ ì¶œë ¥
            status = "âœ… ì„±ê³µ" if success else "âŒ ì‹¤íŒ¨"
            print(f"{status} {scenario_name}")
            print(f"   ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ")
            print(f"   í…ŒìŠ¤íŠ¸ í†µê³„: {test_stats}")
            
            if not success and result.stderr:
                print(f"   ì˜¤ë¥˜: {result.stderr[:200]}...")
            
            return scenario_result
            
        except subprocess.TimeoutExpired:
            end_time = time.time()
            duration = end_time - start_time
            
            print(f"â° {scenario_name} íƒ€ì„ì•„ì›ƒ ({timeout}ì´ˆ)")
            
            return {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': False,
                'error': f"í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ ({timeout}ì´ˆ)",
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat()
            }
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            
            print(f"âŒ {scenario_name} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
            
            return {
                'scenario': scenario_key,
                'name': scenario_name,
                'success': False,
                'error': str(e),
                'duration': duration,
                'start_time': datetime.fromtimestamp(start_time).isoformat(),
                'end_time': datetime.fromtimestamp(end_time).isoformat()
            }
    
    def analyze_output(self, output: str) -> Dict:
        """í…ŒìŠ¤íŠ¸ ì¶œë ¥ ë¶„ì„"""
        stats = {
            'total_tests': 0,
            'passed': 0,
            'failed': 0,
            'errors': 0,
            'success_rate': 0.0
        }
        
        lines = output.split('\n')
        
        for line in lines:
            # unittest ê²°ê³¼ íŒ¨í„´ ì°¾ê¸°
            if 'Ran' in line and 'test' in line:
                try:
                    parts = line.split()
                    if len(parts) >= 2 and parts[0] == 'Ran':
                        stats['total_tests'] = int(parts[1])
                except (ValueError, IndexError):
                    pass
            
            elif 'FAILED' in line:
                # ì‹¤íŒ¨ ì •ë³´ ì¶”ì¶œ
                if 'failures=' in line:
                    try:
                        failures_part = line.split('failures=')[1].split(',')[0].split(')')[0]
                        stats['failed'] = int(failures_part)
                    except (ValueError, IndexError):
                        pass
                
                if 'errors=' in line:
                    try:
                        errors_part = line.split('errors=')[1].split(',')[0].split(')')[0]
                        stats['errors'] = int(errors_part)
                    except (ValueError, IndexError):
                        pass
            
            elif line.strip() == 'OK' and stats['total_tests'] > 0:
                stats['passed'] = stats['total_tests']
        
        # ì„±ê³µí•œ í…ŒìŠ¤íŠ¸ ìˆ˜ ê³„ì‚°
        if stats['passed'] == 0 and stats['total_tests'] > 0:
            stats['passed'] = stats['total_tests'] - stats['failed'] - stats['errors']
        
        # ì„±ê³µë¥  ê³„ì‚°
        if stats['total_tests'] > 0:
            stats['success_rate'] = (stats['passed'] / stats['total_tests']) * 100
        
        return stats
    
    def execute_multiple_scenarios(self, scenario_keys: List[str], 
                                 custom_timeout: Optional[int] = None) -> List[Dict]:
        """ì—¬ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ ìˆœì°¨ ì‹¤í–‰"""
        print(f"ğŸš€ {len(scenario_keys)}ê°œ ì‹œë‚˜ë¦¬ì˜¤ ìˆœì°¨ ì‹¤í–‰ ì‹œì‘")
        print("="*60)
        
        results = []
        
        for i, scenario_key in enumerate(scenario_keys, 1):
            print(f"\nğŸ“‹ ì‹œë‚˜ë¦¬ì˜¤ {i}/{len(scenario_keys)}: {scenario_key}")
            print("-"*40)
            
            result = self.execute_scenario(scenario_key, custom_timeout)
            results.append(result)
            
            # ì¤‘ê°„ ê²°ê³¼ ìš”ì•½
            if result['success']:
                print(f"âœ… {scenario_key} ì™„ë£Œ")
            else:
                print(f"âŒ {scenario_key} ì‹¤íŒ¨: {result.get('error', 'Unknown error')}")
        
        return results
    
    def generate_summary_report(self, results: List[Dict]) -> str:
        """ìš”ì•½ ë³´ê³ ì„œ ìƒì„±"""
        total_scenarios = len(results)
        successful_scenarios = sum(1 for r in results if r['success'])
        total_duration = sum(r['duration'] for r in results)
        
        # í…ŒìŠ¤íŠ¸ í†µê³„ ì§‘ê³„
        total_tests = sum(r.get('test_stats', {}).get('total_tests', 0) for r in results)
        total_passed = sum(r.get('test_stats', {}).get('passed', 0) for r in results)
        total_failed = sum(r.get('test_stats', {}).get('failed', 0) for r in results)
        total_errors = sum(r.get('test_stats', {}).get('errors', 0) for r in results)
        
        overall_success_rate = (total_passed / total_tests * 100) if total_tests > 0 else 0
        
        report = f"""
ğŸ“Š í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ ê²°ê³¼ ìš”ì•½
{'='*60}

ğŸ¯ ì‹¤í–‰ í†µê³„
â€¢ ì´ ì‹œë‚˜ë¦¬ì˜¤: {total_scenarios}ê°œ
â€¢ ì„±ê³µí•œ ì‹œë‚˜ë¦¬ì˜¤: {successful_scenarios}ê°œ
â€¢ ì‹¤íŒ¨í•œ ì‹œë‚˜ë¦¬ì˜¤: {total_scenarios - successful_scenarios}ê°œ
â€¢ ì‹œë‚˜ë¦¬ì˜¤ ì„±ê³µë¥ : {(successful_scenarios/total_scenarios*100):.1f}%
â€¢ ì´ ì†Œìš”ì‹œê°„: {total_duration:.2f}ì´ˆ

ğŸ“ˆ ê°œë³„ í…ŒìŠ¤íŠ¸ í†µê³„
â€¢ ì´ í…ŒìŠ¤íŠ¸: {total_tests}ê°œ
â€¢ ì„±ê³µ: {total_passed}ê°œ
â€¢ ì‹¤íŒ¨: {total_failed}ê°œ
â€¢ ì˜¤ë¥˜: {total_errors}ê°œ
â€¢ ì „ì²´ ì„±ê³µë¥ : {overall_success_rate:.1f}%

ğŸ“‹ ì‹œë‚˜ë¦¬ì˜¤ë³„ ìƒì„¸ ê²°ê³¼
{'-'*60}
"""
        
        for result in results:
            status = "âœ…" if result['success'] else "âŒ"
            name = result.get('name', result['scenario'])
            duration = result['duration']
            
            report += f"""
{status} {name}
â€¢ ì‹œë‚˜ë¦¬ì˜¤ í‚¤: {result['scenario']}
â€¢ ì†Œìš”ì‹œê°„: {duration:.2f}ì´ˆ
"""
            
            if 'test_stats' in result:
                stats = result['test_stats']
                report += f"â€¢ í…ŒìŠ¤íŠ¸ ê²°ê³¼: {stats['passed']}/{stats['total_tests']} ì„±ê³µ ({stats['success_rate']:.1f}%)\n"
            
            if not result['success']:
                error = result.get('error', 'Unknown error')
                report += f"â€¢ ì˜¤ë¥˜: {error}\n"
        
        # ê¶Œì¥ì‚¬í•­
        report += f"""
{'-'*60}
ğŸ”§ ê¶Œì¥ì‚¬í•­
{'-'*60}
"""
        
        if successful_scenarios == total_scenarios:
            report += """
âœ… ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ê°€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!
â€¢ ì‹œìŠ¤í…œì´ ëª¨ë“  í…ŒìŠ¤íŠ¸ ì¡°ê±´ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
â€¢ ì¶”ê°€ í…ŒìŠ¤íŠ¸ë‚˜ í”„ë¡œë•ì…˜ ë°°í¬ë¥¼ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
"""
        elif successful_scenarios >= total_scenarios * 0.8:
            report += """
âš ï¸ ëŒ€ë¶€ë¶„ì˜ ì‹œë‚˜ë¦¬ì˜¤ê°€ ì„±ê³µí–ˆì§€ë§Œ ì¼ë¶€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.
â€¢ ì‹¤íŒ¨í•œ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë¶„ì„í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”.
â€¢ ìˆ˜ì • í›„ í•´ë‹¹ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì¬ì‹¤í–‰í•˜ì—¬ ê²€ì¦í•˜ì„¸ìš”.
"""
        else:
            report += """
âŒ ë‹¤ìˆ˜ì˜ ì‹œë‚˜ë¦¬ì˜¤ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
â€¢ ì‹œìŠ¤í…œì— ì‹¬ê°í•œ ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
â€¢ ì‹¤íŒ¨í•œ ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ë¶„ì„í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”.
â€¢ ì „ì²´ ì‹œìŠ¤í…œ ì ê²€ì„ ê¶Œì¥í•©ë‹ˆë‹¤.
"""
        
        return report
    
    def save_results(self, results: List[Dict], filename: str = None):
        """ê²°ê³¼ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥"""
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'test_scenario_results_{timestamp}.json'
        
        filepath = os.path.join(self.script_dir, filename)
        
        session_data = {
            'execution_time': datetime.now().isoformat(),
            'total_scenarios': len(results),
            'successful_scenarios': sum(1 for r in results if r['success']),
            'total_duration': sum(r['duration'] for r in results),
            'results': results
        }
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            print(f"ğŸ“ ê²°ê³¼ ì €ì¥: {filepath}")
            
        except Exception as e:
            print(f"âš ï¸ ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {e}")


def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    parser = argparse.ArgumentParser(
        description='POSCO WatchHamster v3.0 í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ê¸°',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ì‚¬ìš© ì˜ˆì‹œ:
  python execute_test_scenario.py --list                    # ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œë‚˜ë¦¬ì˜¤ ëª©ë¡
  python execute_test_scenario.py --scenario system_test    # íŠ¹ì • ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
  python execute_test_scenario.py --all                     # ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
  python execute_test_scenario.py --scenario stress_test --timeout 600  # íƒ€ì„ì•„ì›ƒ ì„¤ì •
        """
    )
    
    parser.add_argument('--list', action='store_true',
                       help='ì‚¬ìš© ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ëª©ë¡ ì¶œë ¥')
    parser.add_argument('--scenario', type=str,
                       help='ì‹¤í–‰í•  í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ í‚¤')
    parser.add_argument('--scenarios', nargs='+',
                       help='ì‹¤í–‰í•  ì—¬ëŸ¬ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ í‚¤ë“¤')
    parser.add_argument('--all', action='store_true',
                       help='ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰')
    parser.add_argument('--timeout', type=int,
                       help='í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ (ì´ˆ)')
    parser.add_argument('--config', type=str, default='test_config.json',
                       help='ì„¤ì • íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--save', type=str,
                       help='ê²°ê³¼ ì €ì¥ íŒŒì¼ëª…')
    
    args = parser.parse_args()
    
    try:
        executor = TestScenarioExecutor(args.config)
        
        if args.list:
            executor.list_available_scenarios()
            return 0
        
        results = []
        
        if args.scenario:
            # ë‹¨ì¼ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
            result = executor.execute_scenario(args.scenario, args.timeout)
            results = [result]
            
        elif args.scenarios:
            # ì—¬ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
            results = executor.execute_multiple_scenarios(args.scenarios, args.timeout)
            
        elif args.all:
            # ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
            test_config = executor.config.get('end_to_end_test_config', {})
            all_scenarios = list(test_config.get('test_categories', {}).keys())
            results = executor.execute_multiple_scenarios(all_scenarios, args.timeout)
            
        else:
            print("âŒ ì‹¤í–‰í•  ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì§€ì •í•˜ì„¸ìš”. --help ì˜µì…˜ìœ¼ë¡œ ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”.")
            return 1
        
        if results:
            # ìš”ì•½ ë³´ê³ ì„œ ì¶œë ¥
            print("\n" + "="*80)
            summary_report = executor.generate_summary_report(results)
            print(summary_report)
            
            # ê²°ê³¼ ì €ì¥
            executor.save_results(results, args.save)
            
            # ì „ì²´ ì„±ê³µ ì—¬ë¶€ ë°˜í™˜
            successful_count = sum(1 for r in results if r['success'])
            success_rate = (successful_count / len(results) * 100) if results else 0
            
            if success_rate >= 80:
                print("\nğŸ‰ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
                return 0
            else:
                print("\nâŒ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.")
                return 1
        
        return 0
        
    except KeyboardInterrupt:
        print("\nâš ï¸ í…ŒìŠ¤íŠ¸ê°€ ì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
        return 1
        
    except Exception as e:
        print(f"\nâŒ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())