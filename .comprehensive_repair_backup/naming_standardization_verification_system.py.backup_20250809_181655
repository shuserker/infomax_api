#!/usr/bin/env python3
"""
POSCO ë„¤ì´ë° í‘œì¤€í™” ê²€ì¦ ì‹œìŠ¤í…œ
WatchHamster v3.0 & POSCO News 250808 í˜¸í™˜

ëª¨ë“  íŒŒì¼ëª…, ì½”ë“œ ë‚´ë¶€ ë„¤ì´ë°, ë¬¸ì„œ ë° ì£¼ì„ì˜ í‘œì¤€í™”ë¥¼ ê²€ì¦í•˜ëŠ” ì‹œìŠ¤í…œ
"""

import os
import re
import json
import ast
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional
from dataclasses import dataclass, asdict
import logging

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('naming_verification.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class VerificationResult:
    """ê²€ì¦ ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤"""
    file_path: str
    rule_type: str  # "filename", "code_naming", "comment", "document"
    status: str     # "pass", "fail", "warning"
    expected: str
    actual: str
    message: str
    timestamp: str = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now().isoformat()

class NamingStandardizationVerifier:
    """ë„¤ì´ë° í‘œì¤€í™” ê²€ì¦ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.results: List[VerificationResult] = []
        self.watchhamster_version = "v3.0"
        self.posco_news_version = "250808"
        
        # ë„¤ì´ë° ê·œì¹™ íŒ¨í„´ ì •ì˜
        self.naming_patterns = {
            'watchhamster': {
                'file_patterns': [
                    r'.*[Ww]atch[Hh]amster.*v3\.0.*',
                    r'.*watchhamster.*v3_0.*',
                    r'.*WatchHamster.*V30.*'
                ],
                'class_patterns': [
                    r'.*WatchHamsterV30.*',
                    r'.*WatchHamster.*V3.*'
                ],
                'variable_patterns': [
                    r'.*watchhamster.*v3.*',
                    r'.*WATCHHAMSTER.*V3.*'
                ],
                'comment_patterns': [
                    r'.*[Ww]atch[Hh]amster.*v3\.0.*',
                    r'.*ì›Œì¹˜í–„ìŠ¤í„°.*v3\.0.*'
                ]
            },
            'posco_news': {
                'file_patterns': [
                    r'.*[Pp]osco.*[Nn]ews.*250808.*',
                    r'.*POSCO.*News.*250808.*',
                    r'.*posco.*news.*250808.*'
                ],
                'class_patterns': [
                    r'.*PoscoNews250808.*',
                    r'.*POSCO.*News.*250808.*'
                ],
                'variable_patterns': [
                    r'.*posco.*news.*250808.*',
                    r'.*POSCO.*NEWS.*250808.*'
                ],
                'comment_patterns': [
                    r'.*[Pp]osco.*[Nn]ews.*250808.*',
                    r'.*í¬ìŠ¤ì½”.*ë‰´ìŠ¤.*250808.*'
                ]
            }
        }
        
        # ì œì™¸í•  íŒŒì¼/í´ë” íŒ¨í„´
        self.exclude_patterns = [
            r'\.git.*',
            r'__pycache__.*',
            r'\.DS_Store',
            r'.*\.pyc',
            r'.*\.log',
            r'.*backup.*',
            r'.*archive.*',
            r'.*temp.*',
            r'.*test_.*\.py$'  # í…ŒìŠ¤íŠ¸ íŒŒì¼ì€ ë³„ë„ ê²€ì¦
        ]
    
    def should_exclude_file(self, file_path: str) -> bool:
        """íŒŒì¼ì´ ê²€ì¦ ì œì™¸ ëŒ€ìƒì¸ì§€ í™•ì¸"""
        for pattern in self.exclude_patterns:
            if re.match(pattern, file_path, re.IGNORECASE):
                return True
        return False
    
    def verify_filename_standards(self) -> List[VerificationResult]:
        """íŒŒì¼ëª… í‘œì¤€í™” ê²€ì¦"""
        logger.info("íŒŒì¼ëª… í‘œì¤€í™” ê²€ì¦ ì‹œì‘...")
        results = []
        
        for root, dirs, files in os.walk('.'):
            # ì œì™¸í•  ë””ë ‰í† ë¦¬ í•„í„°ë§
            dirs[:] = [d for d in dirs if not self.should_exclude_file(os.path.join(root, d))]
            
            for file in files:
                file_path = os.path.join(root, file)
                
                if self.should_exclude_file(file_path):
                    continue
                
                # ì›Œì¹˜í–„ìŠ¤í„° ê´€ë ¨ íŒŒì¼ ê²€ì¦
                if any(keyword in file.lower() for keyword in ['watchhamster', 'ì›Œì¹˜í–„ìŠ¤í„°', 'hamster']):
                    result = self._verify_watchhamster_filename(file_path, file)
                    if result:
                        results.append(result)
                
                # í¬ìŠ¤ì½” ë‰´ìŠ¤ ê´€ë ¨ íŒŒì¼ ê²€ì¦
                elif any(keyword in file.lower() for keyword in ['posco', 'news', 'ë‰´ìŠ¤', 'í¬ìŠ¤ì½”']):
                    result = self._verify_posco_news_filename(file_path, file)
                    if result:
                        results.append(result)
        
        logger.info(f"íŒŒì¼ëª… ê²€ì¦ ì™„ë£Œ: {len(results)}ê°œ ê²°ê³¼")
        return results
    
    def _verify_watchhamster_filename(self, file_path: str, filename: str) -> Optional[VerificationResult]:
        """ì›Œì¹˜í–„ìŠ¤í„° íŒŒì¼ëª… ê²€ì¦"""
        patterns = self.naming_patterns['watchhamster']['file_patterns']
        
        for pattern in patterns:
            if re.match(pattern, filename, re.IGNORECASE):
                return VerificationResult(
                    file_path=file_path,
                    rule_type="filename",
                    status="pass",
                    expected="WatchHamster v3.0 naming pattern",
                    actual=filename,
                    message="íŒŒì¼ëª…ì´ ì›Œì¹˜í–„ìŠ¤í„° v3.0 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                )
        
        # êµ¬ë²„ì „ íŒ¨í„´ ê²€ì‚¬
        old_patterns = [r'.*v2.*', r'.*mini.*v2.*', r'.*ì›Œì¹˜í–„ìŠ¤í„°.*v2.*']
        for old_pattern in old_patterns:
            if re.match(old_pattern, filename, re.IGNORECASE):
                return VerificationResult(
                    file_path=file_path,
                    rule_type="filename",
                    status="fail",
                    expected="WatchHamster v3.0 naming pattern",
                    actual=filename,
                    message="êµ¬ë²„ì „ í‘œê¸°ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. v3.0ìœ¼ë¡œ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤"
                )
        
        return VerificationResult(
            file_path=file_path,
            rule_type="filename",
            status="warning",
            expected="WatchHamster v3.0 naming pattern",
            actual=filename,
            message="ì›Œì¹˜í–„ìŠ¤í„° ê´€ë ¨ íŒŒì¼ì´ì§€ë§Œ í‘œì¤€ ë„¤ì´ë° íŒ¨í„´ì„ ë”°ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
        )
    
    def _verify_posco_news_filename(self, file_path: str, filename: str) -> Optional[VerificationResult]:
        """í¬ìŠ¤ì½” ë‰´ìŠ¤ íŒŒì¼ëª… ê²€ì¦"""
        patterns = self.naming_patterns['posco_news']['file_patterns']
        
        for pattern in patterns:
            if re.match(pattern, filename, re.IGNORECASE):
                return VerificationResult(
                    file_path=file_path,
                    rule_type="filename",
                    status="pass",
                    expected="POSCO News 250808 naming pattern",
                    actual=filename,
                    message="íŒŒì¼ëª…ì´ í¬ìŠ¤ì½” ë‰´ìŠ¤ 250808 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                )
        
        # êµ¬ë²„ì „ íŒ¨í„´ ê²€ì‚¬
        old_patterns = [r'.*mini.*', r'.*_mini_.*', r'.*posco.*news(?!.*250808).*']
        for old_pattern in old_patterns:
            if re.match(old_pattern, filename, re.IGNORECASE):
                return VerificationResult(
                    file_path=file_path,
                    rule_type="filename",
                    status="fail",
                    expected="POSCO News 250808 naming pattern",
                    actual=filename,
                    message="êµ¬ë²„ì „ í‘œê¸°ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. 250808ë¡œ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤"
                )
        
        return VerificationResult(
            file_path=file_path,
            rule_type="filename",
            status="warning",
            expected="POSCO News 250808 naming pattern",
            actual=filename,
            message="í¬ìŠ¤ì½” ë‰´ìŠ¤ ê´€ë ¨ íŒŒì¼ì´ì§€ë§Œ í‘œì¤€ ë„¤ì´ë° íŒ¨í„´ì„ ë”°ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
        )    

    def verify_code_naming_standards(self) -> List[VerificationResult]:
        """ì½”ë“œ ë‚´ë¶€ ë„¤ì´ë° ì¼ê´€ì„± ê²€ì¦"""
        logger.info("ì½”ë“œ ë‚´ë¶€ ë„¤ì´ë° ê²€ì¦ ì‹œì‘...")
        results = []
        
        # Python íŒŒì¼ ê²€ì¦
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if not self.should_exclude_file(os.path.join(root, d))]
            
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    
                    if self.should_exclude_file(file_path):
                        continue
                    
                    try:
                        results.extend(self._verify_python_code_naming(file_path))
                    except Exception as e:
                        logger.warning(f"Python íŒŒì¼ ê²€ì¦ ì‹¤íŒ¨ {file_path}: {e}")
                        results.append(VerificationResult(
                            file_path=file_path,
                            rule_type="code_naming",
                            status="warning",
                            expected="Valid Python syntax",
                            actual="Parse error",
                            message=f"íŒŒì¼ íŒŒì‹± ì‹¤íŒ¨: {str(e)}"
                        ))
        
        # Shell/Batch ìŠ¤í¬ë¦½íŠ¸ ê²€ì¦
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if not self.should_exclude_file(os.path.join(root, d))]
            
            for file in files:
                if file.endswith(('.sh', '.bat', '.ps1', '.command')):
                    file_path = os.path.join(root, file)
                    
                    if self.should_exclude_file(file_path):
                        continue
                    
                    try:
                        results.extend(self._verify_script_naming(file_path))
                    except Exception as e:
                        logger.warning(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ê²€ì¦ ì‹¤íŒ¨ {file_path}: {e}")
        
        logger.info(f"ì½”ë“œ ë„¤ì´ë° ê²€ì¦ ì™„ë£Œ: {len(results)}ê°œ ê²°ê³¼")
        return results
    
    def _verify_python_code_naming(self, file_path: str) -> List[VerificationResult]:
        """Python ì½”ë“œ ë„¤ì´ë° ê²€ì¦"""
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # AST íŒŒì‹±ìœ¼ë¡œ í´ë˜ìŠ¤ëª…, í•¨ìˆ˜ëª…, ë³€ìˆ˜ëª… ê²€ì¦
            try:
                tree = ast.parse(content)
                
                for node in ast.walk(tree):
                    # í´ë˜ìŠ¤ëª… ê²€ì¦
                    if isinstance(node, ast.ClassDef):
                        result = self._verify_class_name(file_path, node.name)
                        if result:
                            results.append(result)
                    
                    # í•¨ìˆ˜ëª… ê²€ì¦
                    elif isinstance(node, ast.FunctionDef):
                        result = self._verify_function_name(file_path, node.name)
                        if result:
                            results.append(result)
                    
                    # ë³€ìˆ˜ í• ë‹¹ ê²€ì¦
                    elif isinstance(node, ast.Assign):
                        for target in node.targets:
                            if isinstance(target, ast.Name):
                                result = self._verify_variable_name(file_path, target.id)
                                if result:
                                    results.append(result)
            
            except SyntaxError as e:
                results.append(VerificationResult(
                    file_path=file_path,
                    rule_type="code_naming",
                    status="warning",
                    expected="Valid Python syntax",
                    actual="Syntax error",
                    message=f"Python ë¬¸ë²• ì˜¤ë¥˜: {str(e)}"
                ))
            
            # ë¬¸ìì—´ íŒ¨í„´ìœ¼ë¡œ ë²„ì „ ì •ë³´ ê²€ì¦
            results.extend(self._verify_version_strings_in_code(file_path, content))
            
        except Exception as e:
            logger.warning(f"Python íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ {file_path}: {e}")
        
        return results
    
    def _verify_class_name(self, file_path: str, class_name: str) -> Optional[VerificationResult]:
        """í´ë˜ìŠ¤ëª… ê²€ì¦"""
        # ì›Œì¹˜í–„ìŠ¤í„° ê´€ë ¨ í´ë˜ìŠ¤
        if any(keyword in class_name.lower() for keyword in ['watchhamster', 'hamster']):
            patterns = self.naming_patterns['watchhamster']['class_patterns']
            for pattern in patterns:
                if re.match(pattern, class_name):
                    return VerificationResult(
                        file_path=file_path,
                        rule_type="code_naming",
                        status="pass",
                        expected="WatchHamster v3.0 class naming",
                        actual=class_name,
                        message="í´ë˜ìŠ¤ëª…ì´ ì›Œì¹˜í–„ìŠ¤í„° v3.0 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                    )
            
            return VerificationResult(
                file_path=file_path,
                rule_type="code_naming",
                status="fail",
                expected="WatchHamsterV30* pattern",
                actual=class_name,
                message="ì›Œì¹˜í–„ìŠ¤í„° í´ë˜ìŠ¤ëª…ì´ v3.0 í‘œì¤€ì„ ë”°ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
            )
        
        # í¬ìŠ¤ì½” ë‰´ìŠ¤ ê´€ë ¨ í´ë˜ìŠ¤
        elif any(keyword in class_name.lower() for keyword in ['posco', 'news']):
            patterns = self.naming_patterns['posco_news']['class_patterns']
            for pattern in patterns:
                if re.match(pattern, class_name):
                    return VerificationResult(
                        file_path=file_path,
                        rule_type="code_naming",
                        status="pass",
                        expected="POSCO News 250808 class naming",
                        actual=class_name,
                        message="í´ë˜ìŠ¤ëª…ì´ í¬ìŠ¤ì½” ë‰´ìŠ¤ 250808 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                    )
            
            return VerificationResult(
                file_path=file_path,
                rule_type="code_naming",
                status="fail",
                expected="PoscoNews250808* pattern",
                actual=class_name,
                message="í¬ìŠ¤ì½” ë‰´ìŠ¤ í´ë˜ìŠ¤ëª…ì´ 250808 í‘œì¤€ì„ ë”°ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
            )
        
        return None
    
    def _verify_function_name(self, file_path: str, function_name: str) -> Optional[VerificationResult]:
        """í•¨ìˆ˜ëª… ê²€ì¦"""
        # ë²„ì „ ì •ë³´ê°€ í¬í•¨ëœ í•¨ìˆ˜ëª… ê²€ì¦
        if 'v2' in function_name.lower() or 'mini' in function_name.lower():
            return VerificationResult(
                file_path=file_path,
                rule_type="code_naming",
                status="fail",
                expected="Updated version in function name",
                actual=function_name,
                message="í•¨ìˆ˜ëª…ì— êµ¬ë²„ì „ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤"
            )
        
        return None
    
    def _verify_variable_name(self, file_path: str, variable_name: str) -> Optional[VerificationResult]:
        """ë³€ìˆ˜ëª… ê²€ì¦"""
        # ë²„ì „ ê´€ë ¨ ë³€ìˆ˜ ê²€ì¦
        if any(keyword in variable_name.lower() for keyword in ['version', 'ver']):
            if 'watchhamster' in variable_name.lower() or 'hamster' in variable_name.lower():
                if 'v3' not in variable_name.lower() and '3_0' not in variable_name.lower():
                    return VerificationResult(
                        file_path=file_path,
                        rule_type="code_naming",
                        status="fail",
                        expected="v3.0 version in variable",
                        actual=variable_name,
                        message="ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ ë³€ìˆ˜ê°€ v3.0ì„ ë°˜ì˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"
                    )
            
            elif 'posco' in variable_name.lower() or 'news' in variable_name.lower():
                if '250808' not in variable_name:
                    return VerificationResult(
                        file_path=file_path,
                        rule_type="code_naming",
                        status="fail",
                        expected="250808 version in variable",
                        actual=variable_name,
                        message="í¬ìŠ¤ì½” ë‰´ìŠ¤ ë²„ì „ ë³€ìˆ˜ê°€ 250808ì„ ë°˜ì˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"
                    )
        
        return None
    
    def _verify_version_strings_in_code(self, file_path: str, content: str) -> List[VerificationResult]:
        """ì½”ë“œ ë‚´ ë²„ì „ ë¬¸ìì—´ ê²€ì¦"""
        results = []
        
        # ë²„ì „ ë¬¸ìì—´ íŒ¨í„´ ê²€ìƒ‰
        version_patterns = [
            (r'".*v2\.0.*"', "ì›Œì¹˜í–„ìŠ¤í„° v2.0 ë¬¸ìì—´ ë°œê²¬"),
            (r'".*mini.*v2.*"', "mini v2 ë¬¸ìì—´ ë°œê²¬"),
            (r'".*ì›Œì¹˜í–„ìŠ¤í„°.*v2.*"', "ì›Œì¹˜í–„ìŠ¤í„° v2 í•œê¸€ ë¬¸ìì—´ ë°œê²¬"),
            (r'".*WatchHamster.*v2.*"', "WatchHamster v2 ë¬¸ìì—´ ë°œê²¬")
        ]
        
        for pattern, message in version_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                results.append(VerificationResult(
                    file_path=file_path,
                    rule_type="code_naming",
                    status="fail",
                    expected="Updated version string",
                    actual=match.group(),
                    message=f"{message}: {match.group()}"
                ))
        
        return results
    
    def _verify_script_naming(self, file_path: str) -> List[VerificationResult]:
        """ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ë„¤ì´ë° ê²€ì¦"""
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # ìŠ¤í¬ë¦½íŠ¸ ë‚´ ë³€ìˆ˜ëª… ë° ì£¼ì„ ê²€ì¦
            lines = content.split('\n')
            for line_num, line in enumerate(lines, 1):
                # ë³€ìˆ˜ í• ë‹¹ ê²€ì¦
                if '=' in line and not line.strip().startswith('#'):
                    var_match = re.match(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=', line)
                    if var_match:
                        var_name = var_match.group(1)
                        result = self._verify_script_variable_name(file_path, var_name, line_num)
                        if result:
                            results.append(result)
                
                # ì£¼ì„ ë‚´ ë²„ì „ ì •ë³´ ê²€ì¦
                if line.strip().startswith('#'):
                    result = self._verify_comment_version(file_path, line.strip(), line_num)
                    if result:
                        results.append(result)
        
        except Exception as e:
            logger.warning(f"ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ {file_path}: {e}")
        
        return results
    
    def _verify_script_variable_name(self, file_path: str, var_name: str, line_num: int) -> Optional[VerificationResult]:
        """ìŠ¤í¬ë¦½íŠ¸ ë³€ìˆ˜ëª… ê²€ì¦"""
        if 'version' in var_name.lower() or 'ver' in var_name.lower():
            if 'watchhamster' in var_name.lower() and 'v3' not in var_name.lower():
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="code_naming",
                    status="fail",
                    expected="v3.0 in watchhamster version variable",
                    actual=var_name,
                    message="ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ ë³€ìˆ˜ê°€ v3.0ì„ ë°˜ì˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"
                )
            
            elif 'posco' in var_name.lower() and '250808' not in var_name:
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="code_naming",
                    status="fail",
                    expected="250808 in posco version variable",
                    actual=var_name,
                    message="í¬ìŠ¤ì½” ë²„ì „ ë³€ìˆ˜ê°€ 250808ì„ ë°˜ì˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"
                )
        
        return None
    
    def verify_document_standards(self) -> List[VerificationResult]:
        """ë¬¸ì„œ ë° ì£¼ì„ í‘œì¤€í™” ê²€ì¦"""
        logger.info("ë¬¸ì„œ í‘œì¤€í™” ê²€ì¦ ì‹œì‘...")
        results = []
        
        # ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ ê²€ì¦
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if not self.should_exclude_file(os.path.join(root, d))]
            
            for file in files:
                if file.endswith('.md'):
                    file_path = os.path.join(root, file)
                    
                    if self.should_exclude_file(file_path):
                        continue
                    
                    try:
                        results.extend(self._verify_markdown_document(file_path))
                    except Exception as e:
                        logger.warning(f"ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ ê²€ì¦ ì‹¤íŒ¨ {file_path}: {e}")
        
        logger.info(f"ë¬¸ì„œ í‘œì¤€í™” ê²€ì¦ ì™„ë£Œ: {len(results)}ê°œ ê²°ê³¼")
        return results
    
    def _verify_markdown_document(self, file_path: str) -> List[VerificationResult]:
        """ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ ê²€ì¦"""
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            for line_num, line in enumerate(lines, 1):
                # ì œëª©ì—ì„œ ë²„ì „ ì •ë³´ ê²€ì¦
                if line.startswith('#'):
                    result = self._verify_document_title(file_path, line, line_num)
                    if result:
                        results.append(result)
                
                # ë³¸ë¬¸ì—ì„œ ë²„ì „ ì •ë³´ ê²€ì¦
                result = self._verify_document_content(file_path, line, line_num)
                if result:
                    results.append(result)
        
        except Exception as e:
            logger.warning(f"ë§ˆí¬ë‹¤ìš´ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ {file_path}: {e}")
        
        return results
    
    def _verify_document_title(self, file_path: str, title_line: str, line_num: int) -> Optional[VerificationResult]:
        """ë¬¸ì„œ ì œëª© ê²€ì¦"""
        title = title_line.strip()
        
        # ì›Œì¹˜í–„ìŠ¤í„° ê´€ë ¨ ì œëª©
        if any(keyword in title.lower() for keyword in ['watchhamster', 'ì›Œì¹˜í–„ìŠ¤í„°', 'hamster']):
            if 'v3.0' in title or 'v3' in title:
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="document",
                    status="pass",
                    expected="WatchHamster v3.0 in title",
                    actual=title,
                    message="ë¬¸ì„œ ì œëª©ì´ ì›Œì¹˜í–„ìŠ¤í„° v3.0 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                )
            elif 'v2' in title or 'mini' in title.lower():
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="document",
                    status="fail",
                    expected="WatchHamster v3.0 in title",
                    actual=title,
                    message="ë¬¸ì„œ ì œëª©ì— êµ¬ë²„ì „ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤"
                )
        
        # í¬ìŠ¤ì½” ë‰´ìŠ¤ ê´€ë ¨ ì œëª©
        elif any(keyword in title.lower() for keyword in ['posco', 'news', 'ë‰´ìŠ¤', 'í¬ìŠ¤ì½”']):
            if '250808' in title:
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="document",
                    status="pass",
                    expected="POSCO News 250808 in title",
                    actual=title,
                    message="ë¬¸ì„œ ì œëª©ì´ í¬ìŠ¤ì½” ë‰´ìŠ¤ 250808 í‘œì¤€ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤"
                )
            elif 'mini' in title.lower() and '250808' not in title:
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="document",
                    status="fail",
                    expected="POSCO News 250808 in title",
                    actual=title,
                    message="ë¬¸ì„œ ì œëª©ì— êµ¬ë²„ì „ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤"
                )
        
        return None
    
    def _verify_document_content(self, file_path: str, line: str, line_num: int) -> Optional[VerificationResult]:
        """ë¬¸ì„œ ë‚´ìš© ê²€ì¦"""
        # êµ¬ë²„ì „ íŒ¨í„´ ê²€ìƒ‰
        old_patterns = [
            (r'ì›Œì¹˜í–„ìŠ¤í„°.*v2', "ì›Œì¹˜í–„ìŠ¤í„° v2 í‘œê¸° ë°œê²¬"),
            (r'WatchHamster.*v2', "WatchHamster v2 í‘œê¸° ë°œê²¬"),
            (r'mini.*v2', "mini v2 í‘œê¸° ë°œê²¬"),
            (r'Posco.*News.*mini(?!.*250808)', "êµ¬ë²„ì „ Posco News mini í‘œê¸° ë°œê²¬")
        ]
        
        for pattern, message in old_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="document",
                    status="fail",
                    expected="Updated version information",
                    actual=line.strip(),
                    message=f"{message}: {line.strip()}"
                )
        
        return None
    
    def _verify_comment_version(self, file_path: str, comment_line: str, line_num: int) -> Optional[VerificationResult]:
        """ì£¼ì„ ë‚´ ë²„ì „ ì •ë³´ ê²€ì¦"""
        comment = comment_line.strip()
        
        # êµ¬ë²„ì „ íŒ¨í„´ ê²€ìƒ‰
        old_patterns = [
            (r'#.*v2\.0', "v2.0 ì£¼ì„ ë°œê²¬"),
            (r'#.*mini.*v2', "mini v2 ì£¼ì„ ë°œê²¬"),
            (r'#.*ì›Œì¹˜í–„ìŠ¤í„°.*v2', "ì›Œì¹˜í–„ìŠ¤í„° v2 ì£¼ì„ ë°œê²¬")
        ]
        
        for pattern, message in old_patterns:
            if re.search(pattern, comment, re.IGNORECASE):
                return VerificationResult(
                    file_path=f"{file_path}:{line_num}",
                    rule_type="comment",
                    status="fail",
                    expected="Updated version in comment",
                    actual=comment,
                    message=f"{message}: {comment}"
                )
        
        return None
    
    def verify_configuration_standards(self) -> List[VerificationResult]:
        """ì„¤ì • íŒŒì¼ í‘œì¤€í™” ê²€ì¦"""
        logger.info("ì„¤ì • íŒŒì¼ í‘œì¤€í™” ê²€ì¦ ì‹œì‘...")
        results = []
        
        # JSON ì„¤ì • íŒŒì¼ ê²€ì¦
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if not self.should_exclude_file(os.path.join(root, d))]
            
            for file in files:
                if file.endswith('.json'):
                    file_path = os.path.join(root, file)
                    
                    if self.should_exclude_file(file_path):
                        continue
                    
                    try:
                        results.extend(self._verify_json_configuration(file_path))
                    except Exception as e:
                        logger.warning(f"JSON ì„¤ì • íŒŒì¼ ê²€ì¦ ì‹¤íŒ¨ {file_path}: {e}")
        
        logger.info(f"ì„¤ì • íŒŒì¼ ê²€ì¦ ì™„ë£Œ: {len(results)}ê°œ ê²°ê³¼")
        return results
    
    def _verify_json_configuration(self, file_path: str) -> List[VerificationResult]:
        """JSON ì„¤ì • íŒŒì¼ ê²€ì¦"""
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # ì¬ê·€ì ìœ¼ë¡œ JSON ë°ì´í„° ê²€ì¦
            results.extend(self._verify_json_data(file_path, data, ""))
        
        except json.JSONDecodeError as e:
            results.append(VerificationResult(
                file_path=file_path,
                rule_type="configuration",
                status="warning",
                expected="Valid JSON format",
                actual="JSON parse error",
                message=f"JSON íŒŒì‹± ì˜¤ë¥˜: {str(e)}"
            ))
        except Exception as e:
            logger.warning(f"JSON íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ {file_path}: {e}")
        
        return results
    
    def _verify_json_data(self, file_path: str, data: Any, path: str) -> List[VerificationResult]:
        """JSON ë°ì´í„° ì¬ê·€ ê²€ì¦"""
        results = []
        
        if isinstance(data, dict):
            for key, value in data.items():
                current_path = f"{path}.{key}" if path else key
                
                # í‚¤ ì´ë¦„ ê²€ì¦
                if 'version' in key.lower():
                    result = self._verify_version_field(file_path, key, value, current_path)
                    if result:
                        results.append(result)
                
                # ì¬ê·€ ê²€ì¦
                results.extend(self._verify_json_data(file_path, value, current_path))
        
        elif isinstance(data, list):
            for i, item in enumerate(data):
                current_path = f"{path}[{i}]"
                results.extend(self._verify_json_data(file_path, item, current_path))
        
        elif isinstance(data, str):
            # ë¬¸ìì—´ ê°’ì—ì„œ ë²„ì „ ì •ë³´ ê²€ì¦
            result = self._verify_string_version(file_path, data, path)
            if result:
                results.append(result)
        
        return results
    
    def _verify_version_field(self, file_path: str, key: str, value: Any, path: str) -> Optional[VerificationResult]:
        """ë²„ì „ í•„ë“œ ê²€ì¦"""
        if isinstance(value, str):
            if 'watchhamster' in key.lower() or 'hamster' in key.lower():
                if value == "v3.0":
                    return VerificationResult(
                        file_path=f"{file_path}:{path}",
                        rule_type="configuration",
                        status="pass",
                        expected="v3.0",
                        actual=value,
                        message="ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ì´ v3.0ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤"
                    )
                else:
                    return VerificationResult(
                        file_path=f"{file_path}:{path}",
                        rule_type="configuration",
                        status="fail",
                        expected="v3.0",
                        actual=value,
                        message="ì›Œì¹˜í–„ìŠ¤í„° ë²„ì „ì´ v3.0ìœ¼ë¡œ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
                    )
            
            elif 'posco' in key.lower() or 'news' in key.lower():
                if value == "250808":
                    return VerificationResult(
                        file_path=f"{file_path}:{path}",
                        rule_type="configuration",
                        status="pass",
                        expected="250808",
                        actual=value,
                        message="í¬ìŠ¤ì½” ë‰´ìŠ¤ ë²„ì „ì´ 250808ë¡œ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤"
                    )
                else:
                    return VerificationResult(
                        file_path=f"{file_path}:{path}",
                        rule_type="configuration",
                        status="fail",
                        expected="250808",
                        actual=value,
                        message="í¬ìŠ¤ì½” ë‰´ìŠ¤ ë²„ì „ì´ 250808ë¡œ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
                    )
        
        return None
    
    def _verify_string_version(self, file_path: str, text: str, path: str) -> Optional[VerificationResult]:
        """ë¬¸ìì—´ ë‚´ ë²„ì „ ì •ë³´ ê²€ì¦"""
        # êµ¬ë²„ì „ íŒ¨í„´ ê²€ìƒ‰
        old_patterns = [
            (r'v2\.0', "v2.0 ë¬¸ìì—´ ë°œê²¬"),
            (r'mini.*v2', "mini v2 ë¬¸ìì—´ ë°œê²¬"),
            (r'ì›Œì¹˜í–„ìŠ¤í„°.*v2', "ì›Œì¹˜í–„ìŠ¤í„° v2 ë¬¸ìì—´ ë°œê²¬")
        ]
        
        for pattern, message in old_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return VerificationResult(
                    file_path=f"{file_path}:{path}",
                    rule_type="configuration",
                    status="fail",
                    expected="Updated version string",
                    actual=text,
                    message=f"{message}: {text}"
                )
        
        return None    

    def run_full_verification(self) -> Dict[str, Any]:
        """ì „ì²´ ê²€ì¦ ì‹¤í–‰"""
        logger.info("=== POSCO ë„¤ì´ë° í‘œì¤€í™” ì „ì²´ ê²€ì¦ ì‹œì‘ ===")
        
        # ëª¨ë“  ê²€ì¦ ì‹¤í–‰
        filename_results = self.verify_filename_standards()
        code_results = self.verify_code_naming_standards()
        document_results = self.verify_document_standards()
        config_results = self.verify_configuration_standards()
        
        # ê²°ê³¼ í†µí•©
        all_results = filename_results + code_results + document_results + config_results
        self.results = all_results
        
        # í†µê³„ ê³„ì‚°
        stats = self._calculate_statistics(all_results)
        
        logger.info(f"=== ê²€ì¦ ì™„ë£Œ: ì´ {len(all_results)}ê°œ í•­ëª© ê²€ì¦ ===")
        logger.info(f"í†µê³¼: {stats['pass']}, ì‹¤íŒ¨: {stats['fail']}, ê²½ê³ : {stats['warning']}")
        
        return {
            'timestamp': datetime.now().isoformat(),
            'total_checks': len(all_results),
            'statistics': stats,
            'results': [asdict(result) for result in all_results],
            'summary': self._generate_summary(stats, all_results)
        }
    
    def _calculate_statistics(self, results: List[VerificationResult]) -> Dict[str, int]:
        """ê²€ì¦ ê²°ê³¼ í†µê³„ ê³„ì‚°"""
        stats = {'pass': 0, 'fail': 0, 'warning': 0}
        
        for result in results:
            stats[result.status] += 1
        
        return stats
    
    def _generate_summary(self, stats: Dict[str, int], results: List[VerificationResult]) -> Dict[str, Any]:
        """ê²€ì¦ ê²°ê³¼ ìš”ì•½ ìƒì„±"""
        total = sum(stats.values())
        
        # ì¹´í…Œê³ ë¦¬ë³„ í†µê³„
        category_stats = {}
        for result in results:
            if result.rule_type not in category_stats:
                category_stats[result.rule_type] = {'pass': 0, 'fail': 0, 'warning': 0}
            category_stats[result.rule_type][result.status] += 1
        
        # ì£¼ìš” ë¬¸ì œì  ì‹ë³„
        critical_issues = [r for r in results if r.status == 'fail']
        warnings = [r for r in results if r.status == 'warning']
        
        return {
            'overall_score': (stats['pass'] / total * 100) if total > 0 else 0,
            'compliance_rate': (stats['pass'] / total * 100) if total > 0 else 0,
            'category_breakdown': category_stats,
            'critical_issues_count': len(critical_issues),
            'warnings_count': len(warnings),
            'top_issues': self._get_top_issues(critical_issues),
            'recommendations': self._generate_recommendations(critical_issues, warnings)
        }
    
    def _get_top_issues(self, critical_issues: List[VerificationResult]) -> List[Dict[str, Any]]:
        """ì£¼ìš” ë¬¸ì œì  ìƒìœ„ 5ê°œ ì¶”ì¶œ"""
        issue_counts = {}
        
        for issue in critical_issues:
            key = f"{issue.rule_type}: {issue.message}"
            if key not in issue_counts:
                issue_counts[key] = {'count': 0, 'example': issue}
            issue_counts[key]['count'] += 1
        
        # ë¹ˆë„ìˆœ ì •ë ¬
        sorted_issues = sorted(issue_counts.items(), key=lambda x: x[1]['count'], reverse=True)
        
        return [
            {
                'issue_type': item[1]['example'].rule_type,
                'message': item[1]['example'].message,
                'count': item[1]['count'],
                'example_file': item[1]['example'].file_path
            }
            for item in sorted_issues[:5]
        ]
    
    def _generate_recommendations(self, critical_issues: List[VerificationResult], 
                                warnings: List[VerificationResult]) -> List[str]:
        """ê°œì„  ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        recommendations = []
        
        # íŒŒì¼ëª… ê´€ë ¨ ê¶Œì¥ì‚¬í•­
        filename_issues = [i for i in critical_issues if i.rule_type == 'filename']
        if filename_issues:
            recommendations.append(
                f"íŒŒì¼ëª… í‘œì¤€í™”: {len(filename_issues)}ê°œ íŒŒì¼ì˜ ì´ë¦„ì„ í‘œì¤€ ê·œì¹™ì— ë§ê²Œ ë³€ê²½í•˜ì„¸ìš”"
            )
        
        # ì½”ë“œ ë„¤ì´ë° ê´€ë ¨ ê¶Œì¥ì‚¬í•­
        code_issues = [i for i in critical_issues if i.rule_type == 'code_naming']
        if code_issues:
            recommendations.append(
                f"ì½”ë“œ ë„¤ì´ë° í‘œì¤€í™”: {len(code_issues)}ê°œ ì½”ë“œ ìš”ì†Œì˜ ì´ë¦„ì„ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”"
            )
        
        # ë¬¸ì„œ ê´€ë ¨ ê¶Œì¥ì‚¬í•­
        doc_issues = [i for i in critical_issues if i.rule_type == 'document']
        if doc_issues:
            recommendations.append(
                f"ë¬¸ì„œ í‘œì¤€í™”: {len(doc_issues)}ê°œ ë¬¸ì„œì˜ ë²„ì „ ì •ë³´ë¥¼ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”"
            )
        
        # ì„¤ì • íŒŒì¼ ê´€ë ¨ ê¶Œì¥ì‚¬í•­
        config_issues = [i for i in critical_issues if i.rule_type == 'configuration']
        if config_issues:
            recommendations.append(
                f"ì„¤ì • íŒŒì¼ í‘œì¤€í™”: {len(config_issues)}ê°œ ì„¤ì • í•­ëª©ì„ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”"
            )
        
        # ì „ë°˜ì ì¸ ê¶Œì¥ì‚¬í•­
        if len(critical_issues) > 10:
            recommendations.append("ìë™í™”ëœ ë„¤ì´ë° í‘œì¤€í™” ë„êµ¬ ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤")
        
        if len(warnings) > 5:
            recommendations.append("ê²½ê³  í•­ëª©ë“¤ë„ ê²€í† í•˜ì—¬ ì¼ê´€ì„±ì„ ë†’ì´ì„¸ìš”")
        
        return recommendations
    
    def generate_report(self, output_file: str = None) -> str:
        """ê²€ì¦ ê²°ê³¼ ë³´ê³ ì„œ ìƒì„±"""
        if not self.results:
            logger.warning("ê²€ì¦ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. run_full_verification()ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.")
            return ""
        
        verification_data = self.run_full_verification()
        
        # HTML ë³´ê³ ì„œ ìƒì„±
        html_report = self._generate_html_report(verification_data)
        
        # íŒŒì¼ ì €ì¥
        if output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"naming_verification_report_{timestamp}.html"
        
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_report)
            
            logger.info(f"ê²€ì¦ ë³´ê³ ì„œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: {output_file}")
            
            # JSON ê²°ê³¼ë„ ì €ì¥
            json_file = output_file.replace('.html', '.json')
            with open(json_file, 'w', encoding='utf-8') as f:
                json.dump(verification_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"JSON ê²°ê³¼ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {json_file}")
            
            return output_file
        
        except Exception as e:
            logger.error(f"ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨: {e}")
            return ""
    
    def _generate_html_report(self, data: Dict[str, Any]) -> str:
        """HTML ë³´ê³ ì„œ ìƒì„±"""
        html = f"""
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POSCO ë„¤ì´ë° í‘œì¤€í™” ê²€ì¦ ë³´ê³ ì„œ</title>
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .header {{ text-align: center; margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 10px; }}
        .stats {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 30px 0; }}
        .stat-card {{ background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff; }}
        .stat-number {{ font-size: 2em; font-weight: bold; color: #007bff; }}
        .stat-label {{ color: #6c757d; margin-top: 5px; }}
        .pass {{ color: #28a745; }}
        .fail {{ color: #dc3545; }}
        .warning {{ color: #ffc107; }}
        .section {{ margin: 30px 0; }}
        .section h2 {{ color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }}
        .results-table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        .results-table th, .results-table td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        .results-table th {{ background-color: #f8f9fa; font-weight: bold; }}
        .status-pass {{ background-color: #d4edda; color: #155724; }}
        .status-fail {{ background-color: #f8d7da; color: #721c24; }}
        .status-warning {{ background-color: #fff3cd; color: #856404; }}
        .recommendations {{ background: #e7f3ff; padding: 20px; border-radius: 8px; border-left: 4px solid #007bff; }}
        .recommendations ul {{ margin: 10px 0; padding-left: 20px; }}
        .progress-bar {{ width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; overflow: hidden; }}
        .progress-fill {{ height: 100%; background: linear-gradient(90deg, #28a745, #20c997); transition: width 0.3s ease; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” POSCO ë„¤ì´ë° í‘œì¤€í™” ê²€ì¦ ë³´ê³ ì„œ</h1>
            <p>WatchHamster v3.0 & POSCO News 250808 í‘œì¤€ ì¤€ìˆ˜ ê²€ì¦</p>
            <p>ìƒì„±ì¼ì‹œ: {data['timestamp']}</p>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š ì „ì²´ ìš”ì•½</h2>
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number">{data['total_checks']}</div>
                    <div class="stat-label">ì´ ê²€ì¦ í•­ëª©</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number pass">{data['statistics']['pass']}</div>
                    <div class="stat-label">í†µê³¼</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number fail">{data['statistics']['fail']}</div>
                    <div class="stat-label">ì‹¤íŒ¨</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number warning">{data['statistics']['warning']}</div>
                    <div class="stat-label">ê²½ê³ </div>
                </div>
            </div>
            
            <div style="margin: 20px 0;">
                <h3>ì¤€ìˆ˜ìœ¨: {data['summary']['compliance_rate']:.1f}%</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: {data['summary']['compliance_rate']:.1f}%"></div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“‹ ì¹´í…Œê³ ë¦¬ë³„ ê²°ê³¼</h2>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>ì¹´í…Œê³ ë¦¬</th>
                        <th>í†µê³¼</th>
                        <th>ì‹¤íŒ¨</th>
                        <th>ê²½ê³ </th>
                        <th>ì´ê³„</th>
                    </tr>
                </thead>
                <tbody>
        """
        
        for category, stats in data['summary']['category_breakdown'].items():
            total = stats['pass'] + stats['fail'] + stats['warning']
            html += f"""
                    <tr>
                        <td>{category}</td>
                        <td class="pass">{stats['pass']}</td>
                        <td class="fail">{stats['fail']}</td>
                        <td class="warning">{stats['warning']}</td>
                        <td>{total}</td>
                    </tr>
            """
        
        html += """
                </tbody>
            </table>
        </div>
        """
        
        # ì£¼ìš” ë¬¸ì œì 
        if data['summary']['top_issues']:
            html += """
        <div class="section">
            <h2>âš ï¸ ì£¼ìš” ë¬¸ì œì </h2>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>ë¬¸ì œ ìœ í˜•</th>
                        <th>ì„¤ëª…</th>
                        <th>ë°œìƒ íšŸìˆ˜</th>
                        <th>ì˜ˆì‹œ íŒŒì¼</th>
                    </tr>
                </thead>
                <tbody>
            """
            
            for issue in data['summary']['top_issues']:
                html += f"""
                    <tr>
                        <td>{issue['issue_type']}</td>
                        <td>{issue['message']}</td>
                        <td class="fail">{issue['count']}</td>
                        <td><code>{issue['example_file']}</code></td>
                    </tr>
                """
            
            html += """
                </tbody>
            </table>
        </div>
            """
        
        # ê¶Œì¥ì‚¬í•­
        if data['summary']['recommendations']:
            html += """
        <div class="section">
            <h2>ğŸ’¡ ê°œì„  ê¶Œì¥ì‚¬í•­</h2>
            <div class="recommendations">
                <ul>
            """
            
            for recommendation in data['summary']['recommendations']:
                html += f"<li>{recommendation}</li>"
            
            html += """
                </ul>
            </div>
        </div>
            """
        
        # ìƒì„¸ ê²°ê³¼ (ì‹¤íŒ¨ ë° ê²½ê³ ë§Œ)
        failed_results = [r for r in data['results'] if r['status'] in ['fail', 'warning']]
        if failed_results:
            html += """
        <div class="section">
            <h2>ğŸ” ìƒì„¸ ê²€ì¦ ê²°ê³¼ (ë¬¸ì œ í•­ëª©ë§Œ)</h2>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>íŒŒì¼</th>
                        <th>ìœ í˜•</th>
                        <th>ìƒíƒœ</th>
                        <th>ê¸°ëŒ€ê°’</th>
                        <th>ì‹¤ì œê°’</th>
                        <th>ë©”ì‹œì§€</th>
                    </tr>
                </thead>
                <tbody>
            """
            
            for result in failed_results[:50]:  # ìµœëŒ€ 50ê°œë§Œ í‘œì‹œ
                status_class = f"status-{result['status']}"
                html += f"""
                    <tr>
                        <td><code>{result['file_path']}</code></td>
                        <td>{result['rule_type']}</td>
                        <td class="{status_class}">{result['status'].upper()}</td>
                        <td>{result['expected']}</td>
                        <td>{result['actual']}</td>
                        <td>{result['message']}</td>
                    </tr>
                """
            
            if len(failed_results) > 50:
                html += f"""
                    <tr>
                        <td colspan="6" style="text-align: center; font-style: italic;">
                            ... ë° {len(failed_results) - 50}ê°œ ì¶”ê°€ í•­ëª© (JSON íŒŒì¼ì—ì„œ ì „ì²´ ê²°ê³¼ í™•ì¸)
                        </td>
                    </tr>
                """
            
            html += """
                </tbody>
            </table>
        </div>
            """
        
        html += """
        <div class="section">
            <h2>ğŸ“ ê²€ì¦ ì™„ë£Œ</h2>
            <p>ì´ ë³´ê³ ì„œëŠ” POSCO í”„ë¡œì íŠ¸ì˜ ë„¤ì´ë° ì»¨ë²¤ì…˜ í‘œì¤€í™” ìƒíƒœë¥¼ ê²€ì¦í•œ ê²°ê³¼ì…ë‹ˆë‹¤.</p>
            <p>ë¬¸ì œê°€ ë°œê²¬ëœ í•­ëª©ë“¤ì€ í•´ë‹¹ í‘œì¤€í™” ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ìë™ìœ¼ë¡œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        </div>
    </div>
</body>
</html>
        """
        
        return html

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ” POSCO ë„¤ì´ë° í‘œì¤€í™” ê²€ì¦ ì‹œìŠ¤í…œ")
    print("=" * 50)
    
    verifier = NamingStandardizationVerifier()
    
    try:
        # ì „ì²´ ê²€ì¦ ì‹¤í–‰
        verification_data = verifier.run_full_verification()
        
        # ë³´ê³ ì„œ ìƒì„±
        report_file = verifier.generate_report()
        
        print(f"\nâœ… ê²€ì¦ ì™„ë£Œ!")
        print(f"ğŸ“Š ì´ {verification_data['total_checks']}ê°œ í•­ëª© ê²€ì¦")
        print(f"âœ… í†µê³¼: {verification_data['statistics']['pass']}")
        print(f"âŒ ì‹¤íŒ¨: {verification_data['statistics']['fail']}")
        print(f"âš ï¸  ê²½ê³ : {verification_data['statistics']['warning']}")
        print(f"ğŸ“ˆ ì¤€ìˆ˜ìœ¨: {verification_data['summary']['compliance_rate']:.1f}%")
        
        if report_file:
            print(f"\nğŸ“‹ ë³´ê³ ì„œ ìƒì„±ë¨: {report_file}")
        
        # ì£¼ìš” ê¶Œì¥ì‚¬í•­ ì¶œë ¥
        if verification_data['summary']['recommendations']:
            print(f"\nğŸ’¡ ì£¼ìš” ê¶Œì¥ì‚¬í•­:")
            for i, rec in enumerate(verification_data['summary']['recommendations'][:3], 1):
                print(f"   {i}. {rec}")
        
        return verification_data['statistics']['fail'] == 0
        
    except Exception as e:
        logger.error(f"ê²€ì¦ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return False

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)