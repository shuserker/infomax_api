#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Performance Optimizer
POSCO 시스템 구성요소

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import os
import json
import logging
import psutil
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import statistics

class OptimizationCategory(Enum):
    """최적화 카테고리"""
    CPU = "cpu"
    MEMORY = "memory"
    DISK = "disk"
    NETWORK = "network"
    PROCESS = "process"
    CONFIGURATION = "configuration"

class OptimizationPriority(Enum):
    """최적화 우선순위"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class OptimizationRecommendation:
    """최적화 권장사항"""
    id: str
    category: OptimizationCategory
    priority: OptimizationPriority
    title: str
    description: str
    impact_description: str
    implementation_steps: List[str]
    estimated_improvement: str
    risk_level: str
    created_at: datetime
    applied: bool = False
    applied_at: Optional[datetime] = None

@dataclass
class PerformanceIssue:
    """성능 이슈"""
    issue_type: str
    severity: str
    description: str
    affected_components: List[str]
    metrics: Dict[str, float]
    detected_at: datetime
    recommendations: List[str]

class PerformanceOptimizer:
    """
    POSCO WatchHamster v3.0.0 성능 최적화 시스템
    
    시스템 성능을 분석하고 최적화 권장사항을 제공하는 클래스입니다.
    """
    
    def __init__(self, script_dir: str):
        """
        PerformanceOptimizer 초기화
        
        Args:
            script_dir (str): 스크립트 디렉토리 경로
        """
        self.script_dir = script_dir
        self.logger = logging.getLogger(__name__)
        
        # 최적화 권장사항 저장소
        self.recommendations: List[OptimizationRecommendation] = []
        self.applied_optimizations: List[str] = []
        
        # 성능 임계값
        self.thresholds = {
            'cpu_high': 70.0,
            'cpu_critical': 85.0,
            'memory_high': 75.0,
            'memory_critical': 90.0,
            'disk_high': 80.0,
            'disk_critical': 95.0,
            'response_time_slow': 3.0,
            'response_time_critical': 10.0,
            'process_count_high': 15,
            'process_count_critical': 25
        }
        
        # 최적화 히스토리 파일
        self.optimization_history_file = os.path.join(script_dir, 'optimization_history.json')
        
        # 기존 최적화 히스토리 로드
        self._load_optimization_history()
        
        self.logger.info("🔧 PerformanceOptimizer 초기화 완료")
    
    def analyze_system_performance(self, performance_data: Dict[str, Any]) -> List[PerformanceIssue]:
        """
        시스템 성능 분석 및 이슈 식별
        
        Args:
            performance_data (Dict): 성능 모니터링 데이터
            
        Returns:
            List[PerformanceIssue]: 식별된 성능 이슈 목록
        """
        try:
            issues = []
            current_time = datetime.now()
            
            # CPU 사용률 분석
            cpu_percent = performance_data.get('current', {}).get('cpu_percent', 0)
            if cpu_percent > self.thresholds['cpu_critical']:
                issues.append(PerformanceIssue(
                    issue_type="cpu_critical",
                    severity="critical",
                    description=f"CPU 사용률이 임계 수준입니다 ({cpu_percent:.1f}%)",
                    affected_components=["system", "all_processes"],
                    metrics={"cpu_percent": cpu_percent},
                    detected_at=current_time,
                    recommendations=["cpu_optimization", "process_reduction"]
                ))
            elif cpu_percent > self.thresholds['cpu_high']:
                issues.append(PerformanceIssue(
                    issue_type="cpu_high",
                    severity="warning",
                    description=f"CPU 사용률이 높습니다 ({cpu_percent:.1f}%)",
                    affected_components=["system"],
                    metrics={"cpu_percent": cpu_percent},
                    detected_at=current_time,
                    recommendations=["cpu_monitoring", "process_optimization"]
                ))
            
            # 메모리 사용률 분석
            memory_percent = performance_data.get('current', {}).get('memory_percent', 0)
            if memory_percent > self.thresholds['memory_critical']:
                issues.append(PerformanceIssue(
                    issue_type="memory_critical",
                    severity="critical",
                    description=f"메모리 사용률이 임계 수준입니다 ({memory_percent:.1f}%)",
                    affected_components=["system", "all_processes"],
                    metrics={"memory_percent": memory_percent},
                    detected_at=current_time,
                    recommendations=["memory_cleanup", "cache_optimization"]
                ))
            elif memory_percent > self.thresholds['memory_high']:
                issues.append(PerformanceIssue(
                    issue_type="memory_high",
                    severity="warning",
                    description=f"메모리 사용률이 높습니다 ({memory_percent:.1f}%)",
                    affected_components=["system"],
                    metrics={"memory_percent": memory_percent},
                    detected_at=current_time,
                    recommendations=["memory_monitoring", "log_cleanup"]
                ))
            
            # 디스크 사용률 분석
            disk_percent = performance_data.get('current', {}).get('disk_usage_percent', 0)
            if disk_percent > self.thresholds['disk_critical']:
                issues.append(PerformanceIssue(
                    issue_type="disk_critical",
                    severity="critical",
                    description=f"디스크 사용률이 임계 수준입니다 ({disk_percent:.1f}%)",
                    affected_components=["storage", "logging"],
                    metrics={"disk_percent": disk_percent},
                    detected_at=current_time,
                    recommendations=["disk_cleanup", "log_rotation"]
                ))
            elif disk_percent > self.thresholds['disk_high']:
                issues.append(PerformanceIssue(
                    issue_type="disk_high",
                    severity="warning",
                    description=f"디스크 사용률이 높습니다 ({disk_percent:.1f}%)",
                    affected_components=["storage"],
                    metrics={"disk_percent": disk_percent},
                    detected_at=current_time,
                    recommendations=["disk_monitoring", "file_cleanup"]
                ))
            
            # 프로세스 수 분석
            process_count = performance_data.get('current', {}).get('process_count', 0)
            if process_count > self.thresholds['process_count_critical']:
                issues.append(PerformanceIssue(
                    issue_type="process_count_critical",
                    severity="critical",
                    description=f"실행 중인 프로세스가 너무 많습니다 ({process_count}개)",
                    affected_components=["process_manager"],
                    metrics={"process_count": process_count},
                    detected_at=current_time,
                    recommendations=["process_cleanup", "service_optimization"]
                ))
            elif process_count > self.thresholds['process_count_high']:
                issues.append(PerformanceIssue(
                    issue_type="process_count_high",
                    severity="warning",
                    description=f"실행 중인 프로세스가 많습니다 ({process_count}개)",
                    affected_components=["process_manager"],
                    metrics={"process_count": process_count},
                    detected_at=current_time,
                    recommendations=["process_monitoring"]
                ))
            
            # 응답 시간 분석
            response_times = performance_data.get('response_times', {})
            for operation, stats in response_times.items():
                avg_time = stats.get('avg', 0)
                if avg_time > self.thresholds['response_time_critical']:
                    issues.append(PerformanceIssue(
                        issue_type="response_time_critical",
                        severity="critical",
                        description=f"{operation} 작업의 응답시간이 너무 깁니다 ({avg_time:.1f}초)",
                        affected_components=[operation],
                        metrics={"response_time": avg_time},
                        detected_at=current_time,
                        recommendations=["operation_optimization", "timeout_adjustment"]
                    ))
                elif avg_time > self.thresholds['response_time_slow']:
                    issues.append(PerformanceIssue(
                        issue_type="response_time_slow",
                        severity="warning",
                        description=f"{operation} 작업의 응답시간이 느립니다 ({avg_time:.1f}초)",
                        affected_components=[operation],
                        metrics={"response_time": avg_time},
                        detected_at=current_time,
                        recommendations=["performance_monitoring"]
                    ))
            
            self.logger.info(f"성능 분석 완료: {len(issues)}개 이슈 발견")
            return issues
            
        except Exception as e:
            self.logger.error(f"성능 분석 실패: {e}")
            return []
    
    def generate_optimization_recommendations(self, issues: List[PerformanceIssue]) -> List[OptimizationRecommendation]:
        """
        성능 이슈를 기반으로 최적화 권장사항 생성
        
        Args:
            issues (List[PerformanceIssue]): 성능 이슈 목록
            
        Returns:
            List[OptimizationRecommendation]: 최적화 권장사항 목록
        """
        try:
            recommendations = []
            current_time = datetime.now()
            
            # 이슈별 권장사항 생성
            for issue in issues:
                for rec_type in issue.recommendations:
                    recommendation = self._create_recommendation(rec_type, issue, current_time)
                    if recommendation:
                        recommendations.append(recommendation)
            
            # 중복 제거 및 우선순위 정렬
            unique_recommendations = self._deduplicate_recommendations(recommendations)
            sorted_recommendations = sorted(unique_recommendations, 
                                          key=lambda x: (x.priority.value, x.created_at), 
                                          reverse=True)
            
            # 권장사항 저장
            self.recommendations.extend(sorted_recommendations)
            self._save_optimization_history()
            
            self.logger.info(f"최적화 권장사항 생성 완료: {len(sorted_recommendations)}개")
            return sorted_recommendations
            
        except Exception as e:
            self.logger.error(f"최적화 권장사항 생성 실패: {e}")
            return []
    
    def _create_recommendation(self, rec_type: str, issue: PerformanceIssue, current_time: datetime) -> Optional[OptimizationRecommendation]:
        """개별 권장사항 생성"""
        
        recommendation_templates = {
            "cpu_optimization": {
                "category": OptimizationCategory.CPU,
                "priority": OptimizationPriority.HIGH,
                "title": "CPU 사용률 최적화",
                "description": "높은 CPU 사용률을 줄이기 위한 최적화 작업",
                "impact_description": "시스템 응답성 향상 및 전체적인 성능 개선",
                "implementation_steps": [
                    "CPU 사용률이 높은 프로세스 식별",
                    "불필요한 백그라운드 작업 중지",
                    "모니터링 간격 조정 (5분 → 10분)",
                    "프로세스 우선순위 조정"
                ],
                "estimated_improvement": "CPU 사용률 15-25% 감소 예상",
                "risk_level": "낮음"
            },
            "memory_cleanup": {
                "category": OptimizationCategory.MEMORY,
                "priority": OptimizationPriority.CRITICAL,
                "title": "메모리 정리 및 최적화",
                "description": "메모리 사용량을 줄이고 메모리 누수를 방지",
                "impact_description": "시스템 안정성 향상 및 OOM 오류 방지",
                "implementation_steps": [
                    "메모리 사용량이 높은 프로세스 식별",
                    "로그 파일 크기 제한 설정",
                    "캐시 크기 조정",
                    "가비지 컬렉션 최적화"
                ],
                "estimated_improvement": "메모리 사용률 20-30% 감소 예상",
                "risk_level": "낮음"
            },
            "disk_cleanup": {
                "category": OptimizationCategory.DISK,
                "priority": OptimizationPriority.HIGH,
                "title": "디스크 공간 정리",
                "description": "불필요한 파일 삭제 및 로그 로테이션 설정",
                "impact_description": "디스크 공간 확보 및 I/O 성능 향상",
                "implementation_steps": [
                    "오래된 로그 파일 삭제",
                    "임시 파일 정리",
                    "로그 로테이션 설정",
                    "압축 아카이브 생성"
                ],
                "estimated_improvement": "디스크 공간 30-50% 확보 예상",
                "risk_level": "낮음"
            },
            "process_optimization": {
                "category": OptimizationCategory.PROCESS,
                "priority": OptimizationPriority.MEDIUM,
                "title": "프로세스 최적화",
                "description": "불필요한 프로세스 제거 및 프로세스 관리 최적화",
                "impact_description": "시스템 리소스 절약 및 관리 효율성 향상",
                "implementation_steps": [
                    "실행 중인 프로세스 목록 검토",
                    "불필요한 모니터링 프로세스 비활성화",
                    "프로세스 시작 순서 최적화",
                    "리소스 제한 설정"
                ],
                "estimated_improvement": "프로세스 수 20-40% 감소 예상",
                "risk_level": "중간"
            },
            "log_rotation": {
                "category": OptimizationCategory.CONFIGURATION,
                "priority": OptimizationPriority.MEDIUM,
                "title": "로그 로테이션 설정",
                "description": "로그 파일 자동 로테이션 및 압축 설정",
                "impact_description": "디스크 공간 절약 및 로그 관리 자동화",
                "implementation_steps": [
                    "logrotate 설정 파일 생성",
                    "로그 파일 크기 제한 설정",
                    "압축 및 보관 정책 설정",
                    "자동 정리 스케줄 설정"
                ],
                "estimated_improvement": "로그 관리 자동화 및 공간 절약",
                "risk_level": "낮음"
            },
            "operation_optimization": {
                "category": OptimizationCategory.PROCESS,
                "priority": OptimizationPriority.HIGH,
                "title": "작업 응답시간 최적화",
                "description": "느린 작업의 성능을 개선하여 응답시간 단축",
                "impact_description": "사용자 경험 향상 및 시스템 효율성 증대",
                "implementation_steps": [
                    "느린 작업 식별 및 분석",
                    "병목 지점 제거",
                    "비동기 처리 도입",
                    "타임아웃 값 조정"
                ],
                "estimated_improvement": "응답시간 30-50% 단축 예상",
                "risk_level": "중간"
            }
        }
        
        template = recommendation_templates.get(rec_type)
        if not template:
            return None
        
        # 고유 ID 생성
        rec_id = f"{rec_type}_{current_time.strftime('%Y%m%d_%H%M%S')}"
        
        return OptimizationRecommendation(
            id=rec_id,
            category=template["category"],
            priority=template["priority"],
            title=template["title"],
            description=template["description"],
            impact_description=template["impact_description"],
            implementation_steps=template["implementation_steps"],
            estimated_improvement=template["estimated_improvement"],
            risk_level=template["risk_level"],
            created_at=current_time
        )
    
    def _deduplicate_recommendations(self, recommendations: List[OptimizationRecommendation]) -> List[OptimizationRecommendation]:
        """중복 권장사항 제거"""
        seen_titles = set()
        unique_recommendations = []
        
        for rec in recommendations:
            if rec.title not in seen_titles:
                seen_titles.add(rec.title)
                unique_recommendations.append(rec)
        
        return unique_recommendations
    
    def get_optimization_summary(self) -> Dict[str, Any]:
        """최적화 요약 정보 조회"""
        try:
            # 카테고리별 권장사항 수 계산
            category_counts = {}
            priority_counts = {}
            
            for rec in self.recommendations:
                category_counts[rec.category.value] = category_counts.get(rec.category.value, 0) + 1
                priority_counts[rec.priority.value] = priority_counts.get(rec.priority.value, 0) + 1
            
            # 적용된 최적화 수
            applied_count = sum(1 for rec in self.recommendations if rec.applied)
            
            summary = {
                'timestamp': datetime.now().isoformat(),
                'total_recommendations': len(self.recommendations),
                'applied_optimizations': applied_count,
                'pending_optimizations': len(self.recommendations) - applied_count,
                'category_breakdown': category_counts,
                'priority_breakdown': priority_counts,
                'recent_recommendations': [
                    {
                        'id': rec.id,
                        'title': rec.title,
                        'priority': rec.priority.value,
                        'category': rec.category.value,
                        'created_at': rec.created_at.isoformat(),
                        'applied': rec.applied
                    }
                    for rec in sorted(self.recommendations, key=lambda x: x.created_at, reverse=True)[:5]
                ]
            }
            
            return summary
            
        except Exception as e:
            self.logger.error(f"최적화 요약 조회 실패: {e}")
            return {'error': f'최적화 요약 조회 실패: {e}'}
    
    def apply_optimization(self, recommendation_id: str) -> bool:
        """
        최적화 권장사항 적용
        
        Args:
            recommendation_id (str): 적용할 권장사항 ID
            
        Returns:
            bool: 적용 성공 여부
        """
        try:
            # 권장사항 찾기
            recommendation = None
            for rec in self.recommendations:
                if rec.id == recommendation_id:
                    recommendation = rec
                    break
            
            if not recommendation:
                self.logger.error(f"권장사항을 찾을 수 없습니다: {recommendation_id}")
                return False
            
            if recommendation.applied:
                self.logger.warning(f"이미 적용된 권장사항입니다: {recommendation_id}")
                return True
            
            # 권장사항 적용 (실제 구현은 각 권장사항에 따라 다름)
            success = self._execute_optimization(recommendation)
            
            if success:
                recommendation.applied = True
                recommendation.applied_at = datetime.now()
                self.applied_optimizations.append(recommendation_id)
                
                # 히스토리 저장
                self._save_optimization_history()
                
                self.logger.info(f"최적화 적용 완료: {recommendation.title}")
                return True
            else:
                self.logger.error(f"최적화 적용 실패: {recommendation.title}")
                return False
            
        except Exception as e:
            self.logger.error(f"최적화 적용 중 오류 발생: {e}")
            return False
    
    def _execute_optimization(self, recommendation: OptimizationRecommendation) -> bool:
        """실제 최적화 실행 (시뮬레이션)"""
        try:
            # 실제 환경에서는 각 최적화 타입에 따라 구체적인 작업을 수행
            # 여기서는 시뮬레이션으로 처리
            
            self.logger.info(f"최적화 실행 시뮬레이션: {recommendation.title}")
            
            # 카테고리별 시뮬레이션 로직
            if recommendation.category == OptimizationCategory.CPU:
                self.logger.info("CPU 최적화 시뮬레이션: 모니터링 간격 조정")
                
            elif recommendation.category == OptimizationCategory.MEMORY:
                self.logger.info("메모리 최적화 시뮬레이션: 캐시 정리")
                
            elif recommendation.category == OptimizationCategory.DISK:
                self.logger.info("디스크 최적화 시뮬레이션: 로그 파일 정리")
                
            elif recommendation.category == OptimizationCategory.PROCESS:
                self.logger.info("프로세스 최적화 시뮬레이션: 프로세스 관리 개선")
                
            elif recommendation.category == OptimizationCategory.CONFIGURATION:
                self.logger.info("설정 최적화 시뮬레이션: 설정 파일 업데이트")
            
            # 시뮬레이션이므로 항상 성공으로 처리
            return True
            
        except Exception as e:
            self.logger.error(f"최적화 실행 실패: {e}")
            return False
    
    def _load_optimization_history(self):
        """최적화 히스토리 로드"""
        try:
            if os.path.exists(self.optimization_history_file):
                with open(self.optimization_history_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 권장사항 복원
                for rec_data in data.get('recommendations', []):
                    rec = OptimizationRecommendation(
                        id=rec_data['id'],
                        category=OptimizationCategory(rec_data['category']),
                        priority=OptimizationPriority(rec_data['priority']),
                        title=rec_data['title'],
                        description=rec_data['description'],
                        impact_description=rec_data['impact_description'],
                        implementation_steps=rec_data['implementation_steps'],
                        estimated_improvement=rec_data['estimated_improvement'],
                        risk_level=rec_data['risk_level'],
                        created_at=datetime.fromisoformat(rec_data['created_at']),
                        applied=rec_data.get('applied', False),
                        applied_at=datetime.fromisoformat(rec_data['applied_at']) if rec_data.get('applied_at') else None
                    )
                    self.recommendations.append(rec)
                
                # 적용된 최적화 목록 복원
                self.applied_optimizations = data.get('applied_optimizations', [])
                
                self.logger.info(f"최적화 히스토리 로드 완료: {len(self.recommendations)}개 권장사항")
            
        except Exception as e:
            self.logger.error(f"최적화 히스토리 로드 실패: {e}")
    
    def _save_optimization_history(self):
        """최적화 히스토리 저장"""
        try:
            data = {
                'last_updated': datetime.now().isoformat(),
                'recommendations': [
                    {
                        'id': rec.id,
                        'category': rec.category.value,
                        'priority': rec.priority.value,
                        'title': rec.title,
                        'description': rec.description,
                        'impact_description': rec.impact_description,
                        'implementation_steps': rec.implementation_steps,
                        'estimated_improvement': rec.estimated_improvement,
                        'risk_level': rec.risk_level,
                        'created_at': rec.created_at.isoformat(),
                        'applied': rec.applied,
                        'applied_at': rec.applied_at.isoformat() if rec.applied_at else None
                    }
                    for rec in self.recommendations
                ],
                'applied_optimizations': self.applied_optimizations
            }
            
            with open(self.optimization_history_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            self.logger.debug("최적화 히스토리 저장 완료")
            
        except Exception as e:
            self.logger.error(f"최적화 히스토리 저장 실패: {e}")
    
    def generate_optimization_report(self) -> str:
        """최적화 보고서 생성"""
        try:
            report_lines = []
            report_lines.append("=" * 60)
            report_lines.append("🔧 POSCO WatchHamster v3.0.0 성능 최적화 보고서")
            report_lines.append("=" * 60)
            report_lines.append(f"📅 생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            report_lines.append("")
            
            # 요약 정보
            summary = self.get_optimization_summary()
            report_lines.append("📊 최적화 요약")
            report_lines.append("-" * 30)
            report_lines.append(f"총 권장사항: {summary['total_recommendations']}개")
            report_lines.append(f"적용된 최적화: {summary['applied_optimizations']}개")
            report_lines.append(f"대기 중인 최적화: {summary['pending_optimizations']}개")
            report_lines.append("")
            
            # 카테고리별 분석
            if summary['category_breakdown']:
                report_lines.append("📋 카테고리별 분석")
                report_lines.append("-" * 30)
                for category, count in summary['category_breakdown'].items():
                    report_lines.append(f"{category.upper():12}: {count}개")
                report_lines.append("")
            
            # 우선순위별 분석
            if summary['priority_breakdown']:
                report_lines.append("⚡ 우선순위별 분석")
                report_lines.append("-" * 30)
                priority_order = ['critical', 'high', 'medium', 'low']
                for priority in priority_order:
                    count = summary['priority_breakdown'].get(priority, 0)
                    if count > 0:
                        emoji = {"critical": "🚨", "high": "⚠️", "medium": "📋", "low": "ℹ️"}
                        report_lines.append(f"{emoji.get(priority, '•')} {priority.upper():8}: {count}개")
                report_lines.append("")
            
            # 최근 권장사항
            if summary['recent_recommendations']:
                report_lines.append("🔍 최근 권장사항 (최대 5개)")
                report_lines.append("-" * 30)
                for rec in summary['recent_recommendations']:
                    status = "✅ 적용됨" if rec['applied'] else "⏳ 대기중"
                    priority_emoji = {"critical": "🚨", "high": "⚠️", "medium": "📋", "low": "ℹ️"}
                    emoji = priority_emoji.get(rec['priority'], '•')
                    
                    report_lines.append(f"{emoji} {rec['title']}")
                    report_lines.append(f"   카테고리: {rec['category']} | 우선순위: {rec['priority']} | 상태: {status}")
                    report_lines.append("")
            
            # 권장사항
            report_lines.append("💡 다음 단계 권장사항")
            report_lines.append("-" * 30)
            
            # 우선순위가 높은 미적용 권장사항 찾기
            high_priority_pending = [
                rec for rec in self.recommendations 
                if not rec.applied and rec.priority in [OptimizationPriority.CRITICAL, OptimizationPriority.HIGH]
            ]
            
            if high_priority_pending:
                report_lines.append("다음 최적화를 우선적으로 적용하는 것을 권장합니다:")
                for rec in sorted(high_priority_pending, key=lambda x: x.priority.value, reverse=True)[:3]:
                    report_lines.append(f"• {rec.title} ({rec.priority.value} 우선순위)")
                    report_lines.append(f"  예상 효과: {rec.estimated_improvement}")
            else:
                report_lines.append("• 현재 모든 고우선순위 최적화가 완료되었습니다.")
                report_lines.append("• 정기적인 성능 모니터링을 계속 진행하세요.")
            
            report_lines.append("")
            report_lines.append("=" * 60)
            
            return "\n".join(report_lines)
            
        except Exception as e:
            self.logger.error(f"최적화 보고서 생성 실패: {e}")
            return f"최적화 보고서 생성 실패: {e}"