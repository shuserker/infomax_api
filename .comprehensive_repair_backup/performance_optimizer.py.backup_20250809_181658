#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Performance Optimizer
POSCO ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import os
import json
import logging
import psutil
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import statistics

class OptimizationCategory(Enum):
    """ìµœì í™” ì¹´í…Œê³ ë¦¬"""
    CPU = "cpu"
    MEMORY = "memory"
    DISK = "disk"
    NETWORK = "network"
    PROCESS = "process"
    CONFIGURATION = "configuration"

class OptimizationPriority(Enum):
    """ìµœì í™” ìš°ì„ ìˆœìœ„"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class OptimizationRecommendation:
    """ìµœì í™” ê¶Œì¥ì‚¬í•­"""
    id: str
    category: OptimizationCategory
    priority: OptimizationPriority
    title: str
    description: str
    impact_description: str
    implementation_steps: List[str]
    estimated_improvement: str
    risk_level: str
    created_at: datetime
    applied: bool = False
    applied_at: Optional[datetime] = None

@dataclass
class PerformanceIssue:
    """ì„±ëŠ¥ ì´ìŠˆ"""
    issue_type: str
    severity: str
    description: str
    affected_components: List[str]
    metrics: Dict[str, float]
    detected_at: datetime
    recommendations: List[str]

class PerformanceOptimizer:
    """
    POSCO WatchHamster v3.0.0 ì„±ëŠ¥ ìµœì í™” ì‹œìŠ¤í…œ
    
    ì‹œìŠ¤í…œ ì„±ëŠ¥ì„ ë¶„ì„í•˜ê³  ìµœì í™” ê¶Œì¥ì‚¬í•­ì„ ì œê³µí•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
    """
    
    def __init__(self, script_dir: str):
        """
        PerformanceOptimizer ì´ˆê¸°í™”
        
        Args:
            script_dir (str): ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬ ê²½ë¡œ
        """
        self.script_dir = script_dir
        self.logger = logging.getLogger(__name__)
        
        # ìµœì í™” ê¶Œì¥ì‚¬í•­ ì €ì¥ì†Œ
        self.recommendations: List[OptimizationRecommendation] = []
        self.applied_optimizations: List[str] = []
        
        # ì„±ëŠ¥ ì„ê³„ê°’
        self.thresholds = {
            'cpu_high': 70.0,
            'cpu_critical': 85.0,
            'memory_high': 75.0,
            'memory_critical': 90.0,
            'disk_high': 80.0,
            'disk_critical': 95.0,
            'response_time_slow': 3.0,
            'response_time_critical': 10.0,
            'process_count_high': 15,
            'process_count_critical': 25
        }
        
        # ìµœì í™” íˆìŠ¤í† ë¦¬ íŒŒì¼
        self.optimization_history_file = os.path.join(script_dir, 'optimization_history.json')
        
        # ê¸°ì¡´ ìµœì í™” íˆìŠ¤í† ë¦¬ ë¡œë“œ
        self._load_optimization_history()
        
        self.logger.info("ğŸ”§ PerformanceOptimizer ì´ˆê¸°í™” ì™„ë£Œ")
    
    def analyze_system_performance(self, performance_data: Dict[str, Any]) -> List[PerformanceIssue]:
        """
        ì‹œìŠ¤í…œ ì„±ëŠ¥ ë¶„ì„ ë° ì´ìŠˆ ì‹ë³„
        
        Args:
            performance_data (Dict): ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë°ì´í„°
            
        Returns:
            List[PerformanceIssue]: ì‹ë³„ëœ ì„±ëŠ¥ ì´ìŠˆ ëª©ë¡
        """
        try:
            issues = []
            current_time = datetime.now()
            
            # CPU ì‚¬ìš©ë¥  ë¶„ì„
            cpu_percent = performance_data.get('current', {}).get('cpu_percent', 0)
            if cpu_percent > self.thresholds['cpu_critical']:
                issues.append(PerformanceIssue(
                    issue_type="cpu_critical",
                    severity="critical",
                    description=f"CPU ì‚¬ìš©ë¥ ì´ ì„ê³„ ìˆ˜ì¤€ì…ë‹ˆë‹¤ ({cpu_percent:.1f}%)",
                    affected_components=["system", "all_processes"],
                    metrics={"cpu_percent": cpu_percent},
                    detected_at=current_time,
                    recommendations=["cpu_optimization", "process_reduction"]
                ))
            elif cpu_percent > self.thresholds['cpu_high']:
                issues.append(PerformanceIssue(
                    issue_type="cpu_high",
                    severity="warning",
                    description=f"CPU ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤ ({cpu_percent:.1f}%)",
                    affected_components=["system"],
                    metrics={"cpu_percent": cpu_percent},
                    detected_at=current_time,
                    recommendations=["cpu_monitoring", "process_optimization"]
                ))
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ë¶„ì„
            memory_percent = performance_data.get('current', {}).get('memory_percent', 0)
            if memory_percent > self.thresholds['memory_critical']:
                issues.append(PerformanceIssue(
                    issue_type="memory_critical",
                    severity="critical",
                    description=f"ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ì„ê³„ ìˆ˜ì¤€ì…ë‹ˆë‹¤ ({memory_percent:.1f}%)",
                    affected_components=["system", "all_processes"],
                    metrics={"memory_percent": memory_percent},
                    detected_at=current_time,
                    recommendations=["memory_cleanup", "cache_optimization"]
                ))
            elif memory_percent > self.thresholds['memory_high']:
                issues.append(PerformanceIssue(
                    issue_type="memory_high",
                    severity="warning",
                    description=f"ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤ ({memory_percent:.1f}%)",
                    affected_components=["system"],
                    metrics={"memory_percent": memory_percent},
                    detected_at=current_time,
                    recommendations=["memory_monitoring", "log_cleanup"]
                ))
            
            # ë””ìŠ¤í¬ ì‚¬ìš©ë¥  ë¶„ì„
            disk_percent = performance_data.get('current', {}).get('disk_usage_percent', 0)
            if disk_percent > self.thresholds['disk_critical']:
                issues.append(PerformanceIssue(
                    issue_type="disk_critical",
                    severity="critical",
                    description=f"ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ì´ ì„ê³„ ìˆ˜ì¤€ì…ë‹ˆë‹¤ ({disk_percent:.1f}%)",
                    affected_components=["storage", "logging"],
                    metrics={"disk_percent": disk_percent},
                    detected_at=current_time,
                    recommendations=["disk_cleanup", "log_rotation"]
                ))
            elif disk_percent > self.thresholds['disk_high']:
                issues.append(PerformanceIssue(
                    issue_type="disk_high",
                    severity="warning",
                    description=f"ë””ìŠ¤í¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤ ({disk_percent:.1f}%)",
                    affected_components=["storage"],
                    metrics={"disk_percent": disk_percent},
                    detected_at=current_time,
                    recommendations=["disk_monitoring", "file_cleanup"]
                ))
            
            # í”„ë¡œì„¸ìŠ¤ ìˆ˜ ë¶„ì„
            process_count = performance_data.get('current', {}).get('process_count', 0)
            if process_count > self.thresholds['process_count_critical']:
                issues.append(PerformanceIssue(
                    issue_type="process_count_critical",
                    severity="critical",
                    description=f"ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤ ({process_count}ê°œ)",
                    affected_components=["process_manager"],
                    metrics={"process_count": process_count},
                    detected_at=current_time,
                    recommendations=["process_cleanup", "service_optimization"]
                ))
            elif process_count > self.thresholds['process_count_high']:
                issues.append(PerformanceIssue(
                    issue_type="process_count_high",
                    severity="warning",
                    description=f"ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ë§ìŠµë‹ˆë‹¤ ({process_count}ê°œ)",
                    affected_components=["process_manager"],
                    metrics={"process_count": process_count},
                    detected_at=current_time,
                    recommendations=["process_monitoring"]
                ))
            
            # ì‘ë‹µ ì‹œê°„ ë¶„ì„
            response_times = performance_data.get('response_times', {})
            for operation, stats in response_times.items():
                avg_time = stats.get('avg', 0)
                if avg_time > self.thresholds['response_time_critical']:
                    issues.append(PerformanceIssue(
                        issue_type="response_time_critical",
                        severity="critical",
                        description=f"{operation} ì‘ì—…ì˜ ì‘ë‹µì‹œê°„ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤ ({avg_time:.1f}ì´ˆ)",
                        affected_components=[operation],
                        metrics={"response_time": avg_time},
                        detected_at=current_time,
                        recommendations=["operation_optimization", "timeout_adjustment"]
                    ))
                elif avg_time > self.thresholds['response_time_slow']:
                    issues.append(PerformanceIssue(
                        issue_type="response_time_slow",
                        severity="warning",
                        description=f"{operation} ì‘ì—…ì˜ ì‘ë‹µì‹œê°„ì´ ëŠë¦½ë‹ˆë‹¤ ({avg_time:.1f}ì´ˆ)",
                        affected_components=[operation],
                        metrics={"response_time": avg_time},
                        detected_at=current_time,
                        recommendations=["performance_monitoring"]
                    ))
            
            self.logger.info(f"ì„±ëŠ¥ ë¶„ì„ ì™„ë£Œ: {len(issues)}ê°œ ì´ìŠˆ ë°œê²¬")
            return issues
            
        except Exception as e:
            self.logger.error(f"ì„±ëŠ¥ ë¶„ì„ ì‹¤íŒ¨: {e}")
            return []
    
    def generate_optimization_recommendations(self, issues: List[PerformanceIssue]) -> List[OptimizationRecommendation]:
        """
        ì„±ëŠ¥ ì´ìŠˆë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„±
        
        Args:
            issues (List[PerformanceIssue]): ì„±ëŠ¥ ì´ìŠˆ ëª©ë¡
            
        Returns:
            List[OptimizationRecommendation]: ìµœì í™” ê¶Œì¥ì‚¬í•­ ëª©ë¡
        """
        try:
            recommendations = []
            current_time = datetime.now()
            
            # ì´ìŠˆë³„ ê¶Œì¥ì‚¬í•­ ìƒì„±
            for issue in issues:
                for rec_type in issue.recommendations:
                    recommendation = self._create_recommendation(rec_type, issue, current_time)
                    if recommendation:
                        recommendations.append(recommendation)
            
            # ì¤‘ë³µ ì œê±° ë° ìš°ì„ ìˆœìœ„ ì •ë ¬
            unique_recommendations = self._deduplicate_recommendations(recommendations)
            sorted_recommendations = sorted(unique_recommendations, 
                                          key=lambda x: (x.priority.value, x.created_at), 
                                          reverse=True)
            
            # ê¶Œì¥ì‚¬í•­ ì €ì¥
            self.recommendations.extend(sorted_recommendations)
            self._save_optimization_history()
            
            self.logger.info(f"ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„± ì™„ë£Œ: {len(sorted_recommendations)}ê°œ")
            return sorted_recommendations
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” ê¶Œì¥ì‚¬í•­ ìƒì„± ì‹¤íŒ¨: {e}")
            return []
    
    def _create_recommendation(self, rec_type: str, issue: PerformanceIssue, current_time: datetime) -> Optional[OptimizationRecommendation]:
        """ê°œë³„ ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        
        recommendation_templates = {
            "cpu_optimization": {
                "category": OptimizationCategory.CPU,
                "priority": OptimizationPriority.HIGH,
                "title": "CPU ì‚¬ìš©ë¥  ìµœì í™”",
                "description": "ë†’ì€ CPU ì‚¬ìš©ë¥ ì„ ì¤„ì´ê¸° ìœ„í•œ ìµœì í™” ì‘ì—…",
                "impact_description": "ì‹œìŠ¤í…œ ì‘ë‹µì„± í–¥ìƒ ë° ì „ì²´ì ì¸ ì„±ëŠ¥ ê°œì„ ",
                "implementation_steps": [
                    "CPU ì‚¬ìš©ë¥ ì´ ë†’ì€ í”„ë¡œì„¸ìŠ¤ ì‹ë³„",
                    "ë¶ˆí•„ìš”í•œ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì¤‘ì§€",
                    "ëª¨ë‹ˆí„°ë§ ê°„ê²© ì¡°ì • (5ë¶„ â†’ 10ë¶„)",
                    "í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ì¡°ì •"
                ],
                "estimated_improvement": "CPU ì‚¬ìš©ë¥  15-25% ê°ì†Œ ì˜ˆìƒ",
                "risk_level": "ë‚®ìŒ"
            },
            "memory_cleanup": {
                "category": OptimizationCategory.MEMORY,
                "priority": OptimizationPriority.CRITICAL,
                "title": "ë©”ëª¨ë¦¬ ì •ë¦¬ ë° ìµœì í™”",
                "description": "ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê³  ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€",
                "impact_description": "ì‹œìŠ¤í…œ ì•ˆì •ì„± í–¥ìƒ ë° OOM ì˜¤ë¥˜ ë°©ì§€",
                "implementation_steps": [
                    "ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ì€ í”„ë¡œì„¸ìŠ¤ ì‹ë³„",
                    "ë¡œê·¸ íŒŒì¼ í¬ê¸° ì œí•œ ì„¤ì •",
                    "ìºì‹œ í¬ê¸° ì¡°ì •",
                    "ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ìµœì í™”"
                ],
                "estimated_improvement": "ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  20-30% ê°ì†Œ ì˜ˆìƒ",
                "risk_level": "ë‚®ìŒ"
            },
            "disk_cleanup": {
                "category": OptimizationCategory.DISK,
                "priority": OptimizationPriority.HIGH,
                "title": "ë””ìŠ¤í¬ ê³µê°„ ì •ë¦¬",
                "description": "ë¶ˆí•„ìš”í•œ íŒŒì¼ ì‚­ì œ ë° ë¡œê·¸ ë¡œí…Œì´ì…˜ ì„¤ì •",
                "impact_description": "ë””ìŠ¤í¬ ê³µê°„ í™•ë³´ ë° I/O ì„±ëŠ¥ í–¥ìƒ",
                "implementation_steps": [
                    "ì˜¤ë˜ëœ ë¡œê·¸ íŒŒì¼ ì‚­ì œ",
                    "ì„ì‹œ íŒŒì¼ ì •ë¦¬",
                    "ë¡œê·¸ ë¡œí…Œì´ì…˜ ì„¤ì •",
                    "ì••ì¶• ì•„ì¹´ì´ë¸Œ ìƒì„±"
                ],
                "estimated_improvement": "ë””ìŠ¤í¬ ê³µê°„ 30-50% í™•ë³´ ì˜ˆìƒ",
                "risk_level": "ë‚®ìŒ"
            },
            "process_optimization": {
                "category": OptimizationCategory.PROCESS,
                "priority": OptimizationPriority.MEDIUM,
                "title": "í”„ë¡œì„¸ìŠ¤ ìµœì í™”",
                "description": "ë¶ˆí•„ìš”í•œ í”„ë¡œì„¸ìŠ¤ ì œê±° ë° í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ìµœì í™”",
                "impact_description": "ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì ˆì•½ ë° ê´€ë¦¬ íš¨ìœ¨ì„± í–¥ìƒ",
                "implementation_steps": [
                    "ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ëª©ë¡ ê²€í† ",
                    "ë¶ˆí•„ìš”í•œ ëª¨ë‹ˆí„°ë§ í”„ë¡œì„¸ìŠ¤ ë¹„í™œì„±í™”",
                    "í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ìˆœì„œ ìµœì í™”",
                    "ë¦¬ì†ŒìŠ¤ ì œí•œ ì„¤ì •"
                ],
                "estimated_improvement": "í”„ë¡œì„¸ìŠ¤ ìˆ˜ 20-40% ê°ì†Œ ì˜ˆìƒ",
                "risk_level": "ì¤‘ê°„"
            },
            "log_rotation": {
                "category": OptimizationCategory.CONFIGURATION,
                "priority": OptimizationPriority.MEDIUM,
                "title": "ë¡œê·¸ ë¡œí…Œì´ì…˜ ì„¤ì •",
                "description": "ë¡œê·¸ íŒŒì¼ ìë™ ë¡œí…Œì´ì…˜ ë° ì••ì¶• ì„¤ì •",
                "impact_description": "ë””ìŠ¤í¬ ê³µê°„ ì ˆì•½ ë° ë¡œê·¸ ê´€ë¦¬ ìë™í™”",
                "implementation_steps": [
                    "logrotate ì„¤ì • íŒŒì¼ ìƒì„±",
                    "ë¡œê·¸ íŒŒì¼ í¬ê¸° ì œí•œ ì„¤ì •",
                    "ì••ì¶• ë° ë³´ê´€ ì •ì±… ì„¤ì •",
                    "ìë™ ì •ë¦¬ ìŠ¤ì¼€ì¤„ ì„¤ì •"
                ],
                "estimated_improvement": "ë¡œê·¸ ê´€ë¦¬ ìë™í™” ë° ê³µê°„ ì ˆì•½",
                "risk_level": "ë‚®ìŒ"
            },
            "operation_optimization": {
                "category": OptimizationCategory.PROCESS,
                "priority": OptimizationPriority.HIGH,
                "title": "ì‘ì—… ì‘ë‹µì‹œê°„ ìµœì í™”",
                "description": "ëŠë¦° ì‘ì—…ì˜ ì„±ëŠ¥ì„ ê°œì„ í•˜ì—¬ ì‘ë‹µì‹œê°„ ë‹¨ì¶•",
                "impact_description": "ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ ë° ì‹œìŠ¤í…œ íš¨ìœ¨ì„± ì¦ëŒ€",
                "implementation_steps": [
                    "ëŠë¦° ì‘ì—… ì‹ë³„ ë° ë¶„ì„",
                    "ë³‘ëª© ì§€ì  ì œê±°",
                    "ë¹„ë™ê¸° ì²˜ë¦¬ ë„ì…",
                    "íƒ€ì„ì•„ì›ƒ ê°’ ì¡°ì •"
                ],
                "estimated_improvement": "ì‘ë‹µì‹œê°„ 30-50% ë‹¨ì¶• ì˜ˆìƒ",
                "risk_level": "ì¤‘ê°„"
            }
        }
        
        template = recommendation_templates.get(rec_type)
        if not template:
            return None
        
        # ê³ ìœ  ID ìƒì„±
        rec_id = f"{rec_type}_{current_time.strftime('%Y%m%d_%H%M%S')}"
        
        return OptimizationRecommendation(
            id=rec_id,
            category=template["category"],
            priority=template["priority"],
            title=template["title"],
            description=template["description"],
            impact_description=template["impact_description"],
            implementation_steps=template["implementation_steps"],
            estimated_improvement=template["estimated_improvement"],
            risk_level=template["risk_level"],
            created_at=current_time
        )
    
    def _deduplicate_recommendations(self, recommendations: List[OptimizationRecommendation]) -> List[OptimizationRecommendation]:
        """ì¤‘ë³µ ê¶Œì¥ì‚¬í•­ ì œê±°"""
        seen_titles = set()
        unique_recommendations = []
        
        for rec in recommendations:
            if rec.title not in seen_titles:
                seen_titles.add(rec.title)
                unique_recommendations.append(rec)
        
        return unique_recommendations
    
    def get_optimization_summary(self) -> Dict[str, Any]:
        """ìµœì í™” ìš”ì•½ ì •ë³´ ì¡°íšŒ"""
        try:
            # ì¹´í…Œê³ ë¦¬ë³„ ê¶Œì¥ì‚¬í•­ ìˆ˜ ê³„ì‚°
            category_counts = {}
            priority_counts = {}
            
            for rec in self.recommendations:
                category_counts[rec.category.value] = category_counts.get(rec.category.value, 0) + 1
                priority_counts[rec.priority.value] = priority_counts.get(rec.priority.value, 0) + 1
            
            # ì ìš©ëœ ìµœì í™” ìˆ˜
            applied_count = sum(1 for rec in self.recommendations if rec.applied)
            
            summary = {
                'timestamp': datetime.now().isoformat(),
                'total_recommendations': len(self.recommendations),
                'applied_optimizations': applied_count,
                'pending_optimizations': len(self.recommendations) - applied_count,
                'category_breakdown': category_counts,
                'priority_breakdown': priority_counts,
                'recent_recommendations': [
                    {
                        'id': rec.id,
                        'title': rec.title,
                        'priority': rec.priority.value,
                        'category': rec.category.value,
                        'created_at': rec.created_at.isoformat(),
                        'applied': rec.applied
                    }
                    for rec in sorted(self.recommendations, key=lambda x: x.created_at, reverse=True)[:5]
                ]
            }
            
            return summary
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return {'error': f'ìµœì í™” ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨: {e}'}
    
    def apply_optimization(self, recommendation_id: str) -> bool:
        """
        ìµœì í™” ê¶Œì¥ì‚¬í•­ ì ìš©
        
        Args:
            recommendation_id (str): ì ìš©í•  ê¶Œì¥ì‚¬í•­ ID
            
        Returns:
            bool: ì ìš© ì„±ê³µ ì—¬ë¶€
        """
        try:
            # ê¶Œì¥ì‚¬í•­ ì°¾ê¸°
            recommendation = None
            for rec in self.recommendations:
                if rec.id == recommendation_id:
                    recommendation = rec
                    break
            
            if not recommendation:
                self.logger.error(f"ê¶Œì¥ì‚¬í•­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {recommendation_id}")
                return False
            
            if recommendation.applied:
                self.logger.warning(f"ì´ë¯¸ ì ìš©ëœ ê¶Œì¥ì‚¬í•­ì…ë‹ˆë‹¤: {recommendation_id}")
                return True
            
            # ê¶Œì¥ì‚¬í•­ ì ìš© (ì‹¤ì œ êµ¬í˜„ì€ ê° ê¶Œì¥ì‚¬í•­ì— ë”°ë¼ ë‹¤ë¦„)
            success = self._execute_optimization(recommendation)
            
            if success:
                recommendation.applied = True
                recommendation.applied_at = datetime.now()
                self.applied_optimizations.append(recommendation_id)
                
                # íˆìŠ¤í† ë¦¬ ì €ì¥
                self._save_optimization_history()
                
                self.logger.info(f"ìµœì í™” ì ìš© ì™„ë£Œ: {recommendation.title}")
                return True
            else:
                self.logger.error(f"ìµœì í™” ì ìš© ì‹¤íŒ¨: {recommendation.title}")
                return False
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” ì ìš© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return False
    
    def _execute_optimization(self, recommendation: OptimizationRecommendation) -> bool:
        """ì‹¤ì œ ìµœì í™” ì‹¤í–‰ (ì‹œë®¬ë ˆì´ì…˜)"""
        try:
            # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ê° ìµœì í™” íƒ€ì…ì— ë”°ë¼ êµ¬ì²´ì ì¸ ì‘ì—…ì„ ìˆ˜í–‰
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ì²˜ë¦¬
            
            self.logger.info(f"ìµœì í™” ì‹¤í–‰ ì‹œë®¬ë ˆì´ì…˜: {recommendation.title}")
            
            # ì¹´í…Œê³ ë¦¬ë³„ ì‹œë®¬ë ˆì´ì…˜ ë¡œì§
            if recommendation.category == OptimizationCategory.CPU:
                self.logger.info("CPU ìµœì í™” ì‹œë®¬ë ˆì´ì…˜: ëª¨ë‹ˆí„°ë§ ê°„ê²© ì¡°ì •")
                
            elif recommendation.category == OptimizationCategory.MEMORY:
                self.logger.info("ë©”ëª¨ë¦¬ ìµœì í™” ì‹œë®¬ë ˆì´ì…˜: ìºì‹œ ì •ë¦¬")
                
            elif recommendation.category == OptimizationCategory.DISK:
                self.logger.info("ë””ìŠ¤í¬ ìµœì í™” ì‹œë®¬ë ˆì´ì…˜: ë¡œê·¸ íŒŒì¼ ì •ë¦¬")
                
            elif recommendation.category == OptimizationCategory.PROCESS:
                self.logger.info("í”„ë¡œì„¸ìŠ¤ ìµœì í™” ì‹œë®¬ë ˆì´ì…˜: í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ê°œì„ ")
                
            elif recommendation.category == OptimizationCategory.CONFIGURATION:
                self.logger.info("ì„¤ì • ìµœì í™” ì‹œë®¬ë ˆì´ì…˜: ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸")
            
            # ì‹œë®¬ë ˆì´ì…˜ì´ë¯€ë¡œ í•­ìƒ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
            return True
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            return False
    
    def _load_optimization_history(self):
        """ìµœì í™” íˆìŠ¤í† ë¦¬ ë¡œë“œ"""
        try:
            if os.path.exists(self.optimization_history_file):
                with open(self.optimization_history_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # ê¶Œì¥ì‚¬í•­ ë³µì›
                for rec_data in data.get('recommendations', []):
                    rec = OptimizationRecommendation(
                        id=rec_data['id'],
                        category=OptimizationCategory(rec_data['category']),
                        priority=OptimizationPriority(rec_data['priority']),
                        title=rec_data['title'],
                        description=rec_data['description'],
                        impact_description=rec_data['impact_description'],
                        implementation_steps=rec_data['implementation_steps'],
                        estimated_improvement=rec_data['estimated_improvement'],
                        risk_level=rec_data['risk_level'],
                        created_at=datetime.fromisoformat(rec_data['created_at']),
                        applied=rec_data.get('applied', False),
                        applied_at=datetime.fromisoformat(rec_data['applied_at']) if rec_data.get('applied_at') else None
                    )
                    self.recommendations.append(rec)
                
                # ì ìš©ëœ ìµœì í™” ëª©ë¡ ë³µì›
                self.applied_optimizations = data.get('applied_optimizations', [])
                
                self.logger.info(f"ìµœì í™” íˆìŠ¤í† ë¦¬ ë¡œë“œ ì™„ë£Œ: {len(self.recommendations)}ê°œ ê¶Œì¥ì‚¬í•­")
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” íˆìŠ¤í† ë¦¬ ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    def _save_optimization_history(self):
        """ìµœì í™” íˆìŠ¤í† ë¦¬ ì €ì¥"""
        try:
            data = {
                'last_updated': datetime.now().isoformat(),
                'recommendations': [
                    {
                        'id': rec.id,
                        'category': rec.category.value,
                        'priority': rec.priority.value,
                        'title': rec.title,
                        'description': rec.description,
                        'impact_description': rec.impact_description,
                        'implementation_steps': rec.implementation_steps,
                        'estimated_improvement': rec.estimated_improvement,
                        'risk_level': rec.risk_level,
                        'created_at': rec.created_at.isoformat(),
                        'applied': rec.applied,
                        'applied_at': rec.applied_at.isoformat() if rec.applied_at else None
                    }
                    for rec in self.recommendations
                ],
                'applied_optimizations': self.applied_optimizations
            }
            
            with open(self.optimization_history_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            self.logger.debug("ìµœì í™” íˆìŠ¤í† ë¦¬ ì €ì¥ ì™„ë£Œ")
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def generate_optimization_report(self) -> str:
        """ìµœì í™” ë³´ê³ ì„œ ìƒì„±"""
        try:
            report_lines = []
            report_lines.append("=" * 60)
            report_lines.append("ğŸ”§ POSCO WatchHamster v3.0.0 ì„±ëŠ¥ ìµœì í™” ë³´ê³ ì„œ")
            report_lines.append("=" * 60)
            report_lines.append(f"ğŸ“… ìƒì„± ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            report_lines.append("")
            
            # ìš”ì•½ ì •ë³´
            summary = self.get_optimization_summary()
            report_lines.append("ğŸ“Š ìµœì í™” ìš”ì•½")
            report_lines.append("-" * 30)
            report_lines.append(f"ì´ ê¶Œì¥ì‚¬í•­: {summary['total_recommendations']}ê°œ")
            report_lines.append(f"ì ìš©ëœ ìµœì í™”: {summary['applied_optimizations']}ê°œ")
            report_lines.append(f"ëŒ€ê¸° ì¤‘ì¸ ìµœì í™”: {summary['pending_optimizations']}ê°œ")
            report_lines.append("")
            
            # ì¹´í…Œê³ ë¦¬ë³„ ë¶„ì„
            if summary['category_breakdown']:
                report_lines.append("ğŸ“‹ ì¹´í…Œê³ ë¦¬ë³„ ë¶„ì„")
                report_lines.append("-" * 30)
                for category, count in summary['category_breakdown'].items():
                    report_lines.append(f"{category.upper():12}: {count}ê°œ")
                report_lines.append("")
            
            # ìš°ì„ ìˆœìœ„ë³„ ë¶„ì„
            if summary['priority_breakdown']:
                report_lines.append("âš¡ ìš°ì„ ìˆœìœ„ë³„ ë¶„ì„")
                report_lines.append("-" * 30)
                priority_order = ['critical', 'high', 'medium', 'low']
                for priority in priority_order:
                    count = summary['priority_breakdown'].get(priority, 0)
                    if count > 0:
                        emoji = {"critical": "ğŸš¨", "high": "âš ï¸", "medium": "ğŸ“‹", "low": "â„¹ï¸"}
                        report_lines.append(f"{emoji.get(priority, 'â€¢')} {priority.upper():8}: {count}ê°œ")
                report_lines.append("")
            
            # ìµœê·¼ ê¶Œì¥ì‚¬í•­
            if summary['recent_recommendations']:
                report_lines.append("ğŸ” ìµœê·¼ ê¶Œì¥ì‚¬í•­ (ìµœëŒ€ 5ê°œ)")
                report_lines.append("-" * 30)
                for rec in summary['recent_recommendations']:
                    status = "âœ… ì ìš©ë¨" if rec['applied'] else "â³ ëŒ€ê¸°ì¤‘"
                    priority_emoji = {"critical": "ğŸš¨", "high": "âš ï¸", "medium": "ğŸ“‹", "low": "â„¹ï¸"}
                    emoji = priority_emoji.get(rec['priority'], 'â€¢')
                    
                    report_lines.append(f"{emoji} {rec['title']}")
                    report_lines.append(f"   ì¹´í…Œê³ ë¦¬: {rec['category']} | ìš°ì„ ìˆœìœ„: {rec['priority']} | ìƒíƒœ: {status}")
                    report_lines.append("")
            
            # ê¶Œì¥ì‚¬í•­
            report_lines.append("ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„ ê¶Œì¥ì‚¬í•­")
            report_lines.append("-" * 30)
            
            # ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ë¯¸ì ìš© ê¶Œì¥ì‚¬í•­ ì°¾ê¸°
            high_priority_pending = [
                rec for rec in self.recommendations 
                if not rec.applied and rec.priority in [OptimizationPriority.CRITICAL, OptimizationPriority.HIGH]
            ]
            
            if high_priority_pending:
                report_lines.append("ë‹¤ìŒ ìµœì í™”ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤:")
                for rec in sorted(high_priority_pending, key=lambda x: x.priority.value, reverse=True)[:3]:
                    report_lines.append(f"â€¢ {rec.title} ({rec.priority.value} ìš°ì„ ìˆœìœ„)")
                    report_lines.append(f"  ì˜ˆìƒ íš¨ê³¼: {rec.estimated_improvement}")
            else:
                report_lines.append("â€¢ í˜„ì¬ ëª¨ë“  ê³ ìš°ì„ ìˆœìœ„ ìµœì í™”ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
                report_lines.append("â€¢ ì •ê¸°ì ì¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì„ ê³„ì† ì§„í–‰í•˜ì„¸ìš”.")
            
            report_lines.append("")
            report_lines.append("=" * 60)
            
            return "\n".join(report_lines)
            
        except Exception as e:
            self.logger.error(f"ìµœì í™” ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨: {e}")
            return f"ìµœì í™” ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨: {e}"