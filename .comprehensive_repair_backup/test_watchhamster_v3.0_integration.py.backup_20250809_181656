#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test Watchhamster V3.0 Integration
POSCO ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import os
import sys
import unittest
import subprocess
import time
import signal
import threading
import tempfile
import shutil
import json
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch, Mock
import psutil

# í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ê²½ë¡œ ì„¤ì •
current_dir = os.path.dirname(os.path.abspath(__file__))
POSCO News 250808_mini')
sys.path.insert(0, posco_mini_dir)

class TestWatchHamster v3.00ComponentInitialization(unittest.TestCase):
    """v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        # í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (í…ŒìŠ¤íŠ¸ìš©)
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # í…ŒìŠ¤íŠ¸ìš© ì„ì‹œ ë””ë ‰í† ë¦¬ ìƒì„±
        self.test_dir = tempfile.mkdtemp()
        self.original_cwd = os.getcwd()
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        # ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
        os.chdir(self.original_cwd)
        
    def test_v2_components_import(self):
        """v2 ì»´í¬ë„ŒíŠ¸ import í…ŒìŠ¤íŠ¸"""
        try:
            # v2 ì»´í¬ë„ŒíŠ¸ë“¤ì´ ì˜¬ë°”ë¥´ê²Œ importë˜ëŠ”ì§€ í™•ì¸
            v2_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0')
            
            # ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
            self.assertTrue(os.path.exists(v2_path), "v2 ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            
            # core ë””ë ‰í† ë¦¬ í™•ì¸
            core_path = os.path.join(v2_path, 'core')
            self.assertTrue(os.path.exists(core_path), "v2 core ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            
            # modules.json íŒŒì¼ í™•ì¸
            modules_json = os.path.join(v2_path, 'modules.json')
            self.assertTrue(os.path.exists(modules_json), "modules.json íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            
            # ê°œë³„ ì»´í¬ë„ŒíŠ¸ íŒŒì¼ í™•ì¸
            components = [
                'enhanced_process_manager.py',
                'module_registry.py', 
                'notification_manager.py'
            ]
            
            for component in components:
                component_path = os.path.join(core_path, component)
                self.assertTrue(os.path.exists(component_path), 
                              f"{component} íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            
            print("âœ… v2 ì»´í¬ë„ŒíŠ¸ íŒŒì¼ êµ¬ì¡° ê²€ì¦ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"v2 ì»´í¬ë„ŒíŠ¸ import í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_watchhamster_initialization(self):
        """WatchHamster v3.0 ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸"""
        try:
            # config ëª¨ë“ˆ mock (í…ŒìŠ¤íŠ¸ìš©)
            import sys
            from unittest.mock import MagicMock
            
            # config ëª¨ë“ˆ mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            # core ëª¨ë“ˆë“¤ mock
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            sys.modules['core.colorful_ui'] = MagicMock()
            
            # WatchHamster v3.0 ì´ˆê¸°í™”
            from monitor_WatchHamster import WatchHamster v3.00Monitor
            
            # ì›Œì¹˜í–„ìŠ¤í„° ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
            watchhamster = WatchHamster v3.00Monitor()
            
            # ê¸°ë³¸ ì†ì„± í™•ì¸
            self.assertIsNotNone(watchhamster.script_dir)
            self.assertIsNotNone(watchhamster.log_file)
            self.assertIsNotNone(watchhamster.status_file)
            
            # v2 í†µí•© ìƒíƒœ í™•ì¸
            self.assertIsInstance(watchhamster.v3_0_enabled, bool)
            self.assertIsInstance(watchhamster.v3_0_components, dict)
            
            # ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ëª©ë¡ í™•ì¸
            self.assertIsInstance(watchhamster.managed_processes, list)
            self.assertGreater(len(watchhamster.managed_processes), 0)
            
            print(f"âœ… WatchHamster v3.0 ì´ˆê¸°í™” ì™„ë£Œ")
            print(f"   - v2 í™œì„±í™”: {watchhamster.v3_0_enabled}")
            print(f"   - ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤: {len(watchhamster.managed_processes)}ê°œ")
            print(f"   - í´ë°± ì‚¬ìœ : {watchhamster.fallback_reason}")
            
            # v2 í†µí•© ìƒíƒœ ì •ë³´ ì¡°íšŒ
            integration_status = watchhamster.get_v2_integration_status()
            self.assertIsInstance(integration_status, dict)
            self.assertIn('v3_0_enabled', integration_status)
            
            print("âœ… v2 í†µí•© ìƒíƒœ ì¡°íšŒ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"WatchHamster v3.0 ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_v2_fallback_mechanism(self):
        """v2 í´ë°± ë©”ì»¤ë‹ˆì¦˜ í…ŒìŠ¤íŠ¸"""
        try:
            # v2 ë””ë ‰í† ë¦¬ë¥¼ ì„ì‹œë¡œ ìˆ¨ê²¨ì„œ í´ë°± í…ŒìŠ¤íŠ¸
            v2_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0')
            temp_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0_temp')
            
            # ì‹¤ì œ íŒŒì¼ ì‹œìŠ¤í…œ ì¡°ì‘ ëŒ€ì‹  mockì„ ì‚¬ìš©
            import sys
            from unittest.mock import MagicMock, patch
            
            # config ëª¨ë“ˆ mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            # core ëª¨ë“ˆë“¤ mock
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # os.path.existsë¥¼ mockí•˜ì—¬ v2 ë””ë ‰í† ë¦¬ê°€ ì—†ëŠ” ê²ƒì²˜ëŸ¼ ì‹œë®¬ë ˆì´ì…˜
            with patch('os.path.exists') as mock_exists:
                def side_effect(path):
                    if 'WatchHamster_v3.0' in path:
                        return False  # v2 ë””ë ‰í† ë¦¬ê°€ ì—†ëŠ” ê²ƒì²˜ëŸ¼
                    return True  # ë‹¤ë¥¸ ê²½ë¡œëŠ” ì •ìƒ
                
                mock_exists.side_effect = side_effect
                
                from monitor_WatchHamster import WatchHamster v3.00Monitor
                watchhamster = WatchHamster v3.00Monitor()
                
                # í´ë°±ì´ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í–ˆëŠ”ì§€ í™•ì¸
                self.assertFalse(watchhamster.v3_0_enabled)
                self.assertIsNotNone(watchhamster.fallback_reason)
                self.assertIn('ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', watchhamster.fallback_reason)
                
                print("âœ… v2 í´ë°± ë©”ì»¤ë‹ˆì¦˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                print(f"   - í´ë°± ì‚¬ìœ : {watchhamster.fallback_reason}")
                
        except Exception as e:
            self.fail(f"v2 í´ë°± ë©”ì»¤ë‹ˆì¦˜ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_process_management_integration(self):
        """í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config ë° core ëª¨ë“ˆ mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 ì»´í¬ë„ŒíŠ¸ mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ProcessManager mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_system_status.return_value = {
                            'timestamp': '2025-01-01T00:00:00',
                            'process_details': {}
                        }
                        process_manager_mock.perform_health_check.return_value = {
                            'posco_main_notifier': True,
                            'realtime_news_monitor': True
                        }
                        process_manager_mock.auto_recovery.return_value = True
                        
                        # v2 ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {
                            'posco_main_notifier': MagicMock(),
                            'realtime_news_monitor': MagicMock()
                        }
                        module_registry_mock.get_startup_order.return_value = [
                            'POSCO News 250808_monitor'
                        ]
                        
                        # v2 NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.get_notification_stats.return_value = {
                            'total_notifications': 0
                        }
                        
                        # mock ëª¨ë“ˆ ì„¤ì •
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # v2 í†µí•© ìƒíƒœ í™•ì¸
                        self.assertTrue(watchhamster.v3_0_enabled)
                        self.assertIsNotNone(watchhamster.v3_0_components['process_manager'])
                        self.assertIsNotNone(watchhamster.v3_0_components['module_registry'])
                        self.assertIsNotNone(watchhamster.v3_0_components['notification_manager'])
                        
                        # í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
                        watchhamster.handle_process_failure_v2('test_process')
                        
                        # í—¬ìŠ¤ì²´í¬ í…ŒìŠ¤íŠ¸
                        health_results = watchhamster.v3_0_components['process_manager'].perform_health_check()
                        self.assertIsInstance(health_results, dict)
                        
                        print("âœ… í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        print(f"   - v2 ProcessManager ì—°ë™: âœ…")
                        print(f"   - 3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ: âœ…")
                        print(f"   - í—¬ìŠ¤ì²´í¬ ì‹œìŠ¤í…œ: âœ…")
                        
        except Exception as e:
            self.fail(f"í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_three_stage_recovery_system(self):
        """3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config ë° core ëª¨ë“ˆ mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 ì»´í¬ë„ŒíŠ¸ mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # ProcessInfo mock
                        process_info_mock = MagicMock()
                        process_info_mock.restart_count = 1
                        process_info_mock.last_error = "Test error"
                        process_info_mock.pid = 12345
                        
                        # v2 ProcessManager mock (3ë‹¨ê³„ ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜)
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_process_info.return_value = process_info_mock
                        
                        # ë³µêµ¬ ì‹œë‚˜ë¦¬ì˜¤ë³„ í…ŒìŠ¤íŠ¸
                        recovery_scenarios = [
                            (True, "1ë‹¨ê³„ ì¦‰ì‹œ ë³µêµ¬ ì„±ê³µ"),
                            (False, "ëª¨ë“  ë³µêµ¬ ë‹¨ê³„ ì‹¤íŒ¨")
                        ]
                        
                        for recovery_success, scenario_name in recovery_scenarios:
                            process_manager_mock.auto_recovery.return_value = recovery_success
                            
                            # v2 ModuleRegistry mock
                            module_registry_mock = MagicMock()
                            module_registry_mock.list_modules.return_value = {'test_process': MagicMock()}
                            
                            # v2 NotificationManager mock
                            notification_manager_mock = MagicMock()
                            notification_manager_mock.send_recovery_success = MagicMock()
                            notification_manager_mock.send_critical_alert = MagicMock()
                            
                            # mock ëª¨ë“ˆ ì„¤ì •
                            mock_module_obj = MagicMock()
                            mock_module_obj.ProcessManager = lambda x: process_manager_mock
                            mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                            mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                            
                            mock_spec.return_value = MagicMock()
                            mock_module.return_value = mock_module_obj
                            
                            from monitor_WatchHamster import WatchHamster v3.00Monitor
                            watchhamster = WatchHamster v3.00Monitor()
                            
                            # 3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
                            watchhamster.handle_process_failure_v2('test_process')
                            
                            # ë³µêµ¬ ê²°ê³¼ì— ë”°ë¥¸ ì•Œë¦¼ í˜¸ì¶œ í™•ì¸
                            if recovery_success:
                                notification_manager_mock.send_recovery_success.assert_called()
                                print(f"âœ… {scenario_name} í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                            else:
                                notification_manager_mock.send_critical_alert.assert_called()
                                print(f"âœ… {scenario_name} í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
                        print("âœ… 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        print("   - 1ë‹¨ê³„: ì¦‰ì‹œ ì¬ì‹œì‘ âœ…")
                        print("   - 2ë‹¨ê³„: 5ë¶„ í›„ ì¬ì‹œë„ âœ…")
                        print("   - 3ë‹¨ê³„: ìµœì¢… ì¬ì‹œë„ âœ…")
                        print("   - ë³µêµ¬ ì‹¤íŒ¨ ì‹œ ì•Œë¦¼ âœ…")
                        
        except Exception as e:
            self.fail(f"3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_process_lifecycle_management(self):
        """í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í…ŒìŠ¤íŠ¸"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config ë° core ëª¨ë“ˆ mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 ì»´í¬ë„ŒíŠ¸ mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ProcessManager mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.start_process.return_value = True
                        process_manager_mock.stop_process.return_value = True
                        process_manager_mock.is_process_running.return_value = True
                        
                        # ëª¨ë“ˆ ì„¤ì • mock
                        module_config_mock = MagicMock()
                        module_config_mock.auto_start = True
                        module_config_mock.script_path = 'test_script.py'
                        module_config_mock.working_directory = '.'
                        module_config_mock.priority = 1
                        
                        # v2 ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.get_modules_by_dependency_order.return_value = [
                            'POSCO News 250808_monitor'
                        ]
                        module_registry_mock.get_module_config.return_value = module_config_mock
                        
                        # v2 NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_startup_notification = MagicMock()
                        
                        # mock ëª¨ë“ˆ ì„¤ì •
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # í”„ë¡œì„¸ìŠ¤ ì‹œì‘ í…ŒìŠ¤íŠ¸
                        start_result = watchhamster._start_processes_v2()
                        self.assertTrue(start_result)
                        
                        # ProcessManager ë©”ì„œë“œ í˜¸ì¶œ í™•ì¸
                        process_manager_mock.start_process.assert_called()
                        
                        # ì•Œë¦¼ ì „ì†¡ í™•ì¸
                        notification_manager_mock.send_startup_notification.assert_called()
                        
                        print("âœ… í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        print("   - ì˜ì¡´ì„± ìˆœì„œ ì‹œì‘: âœ…")
                        print("   - í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¶”ì : âœ…")
                        print("   - ì‹œì‘ ì•Œë¦¼ ì „ì†¡: âœ…")
                        
        except Exception as e:
            self.fail(f"í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class TestWatchHamster v3.00Communication(unittest.TestCase):
    """WatchHamster v3.0.0 ì»´í¬ë„ŒíŠ¸ í†µì‹  í†µí•© í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # Mock ì„¤ì •
        self.setup_mocks()
        
    def setup_mocks(self):
        """Mock ê°ì²´ ì„¤ì •"""
        # config ëª¨ë“ˆ mock
        config_mock = MagicMock()
        config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
        config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
        config_mock.API_CONFIG = {}
        sys.modules['config'] = config_mock
        
        # core ëª¨ë“ˆë“¤ mock
        core_mock = MagicMock()
        sys.modules['core'] = core_mock
        sys.modules['core.state_manager'] = MagicMock()
        sys.modules['core.process_manager'] = MagicMock()
        sys.modules['core.colorful_ui'] = MagicMock()
    
    def test_watchhamster_v3_0_component_communication(self):
        """WatchHamster v3.0.0 ì»´í¬ë„ŒíŠ¸ ê°„ í†µì‹  í…ŒìŠ¤íŠ¸"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ì»´í¬ë„ŒíŠ¸ mock ì„¤ì •
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_system_status.return_value = {
                            'timestamp': datetime.now().isoformat(),
                            'process_details': {'test_process': {'status': 'running'}}
                        }
                        
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {
                            'posco_main_notifier': {'config': MagicMock(), 'status': 'active'}
                        }
                        
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_notification.return_value = True
                        
                        # mock ëª¨ë“ˆ ì„¤ì •
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # í†µì‹  í…ŒìŠ¤íŠ¸
                        self.assertTrue(watchhamster.v3_0_enabled)
                        
                        # ProcessManager í†µì‹  í…ŒìŠ¤íŠ¸
                        status = watchhamster.v3_0_components['process_manager'].get_system_status()
                        self.assertIsInstance(status, dict)
                        self.assertIn('timestamp', status)
                        
                        # ModuleRegistry í†µì‹  í…ŒìŠ¤íŠ¸
                        modules = watchhamster.v3_0_components['module_registry'].list_modules()
                        self.assertIsInstance(modules, dict)
                        
                        # NotificationManager í†µì‹  í…ŒìŠ¤íŠ¸
                        result = watchhamster.v3_0_components['notification_manager'].send_notification("Test message")
                        self.assertTrue(result)
                        
                        print("âœ… WatchHamster v3.0.0 ì»´í¬ë„ŒíŠ¸ í†µì‹  í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
        except Exception as e:
            self.fail(f"WatchHamster v3.0.0 ì»´í¬ë„ŒíŠ¸ í†µì‹  í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_v2_integration_status_reporting(self):
        """v2 í†µí•© ìƒíƒœ ë³´ê³  í…ŒìŠ¤íŠ¸"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ì»´í¬ë„ŒíŠ¸ mock ì„¤ì •
                        process_manager_mock = MagicMock()
                        module_registry_mock = MagicMock()
                        notification_manager_mock = MagicMock()
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # v2 í†µí•© ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸
                        integration_status = watchhamster.get_v2_integration_status()
                        
                        self.assertIsInstance(integration_status, dict)
                        self.assertIn('v3_0_enabled', integration_status)
                        self.assertIn('components_loaded', integration_status)
                        self.assertIn('initialization_time', integration_status)
                        
                        print("âœ… v2 í†µí•© ìƒíƒœ ë³´ê³  í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
        except Exception as e:
            self.fail(f"v2 í†µí•© ìƒíƒœ ë³´ê³  í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class TestWatchHamster v3.00ProcessLifecycleManagement(unittest.TestCase):
    """í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ (ì‹œì‘/ì¤‘ì§€/ì¬ì‹œì‘)"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # í…ŒìŠ¤íŠ¸ìš© ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
        self.test_script_dir = tempfile.mkdtemp()
        self.test_script_path = os.path.join(self.test_script_dir, 'test_process.py')
        
        # ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
        test_script_content = '''#!/usr/bin/env python3
import time
import sys
import signal

def signal_handler(signum, frame):
    print("Process terminated gracefully")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print("Test process started")
try:
    while True:
        time.sleep(1)
        print("Test process running...")
except KeyboardInterrupt:
    print("Process interrupted")
    sys.exit(0)
'''
        with open(self.test_script_path, 'w') as f:
            f.write(test_script_content)
        os.chmod(self.test_script_path, 0o755)
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        if os.path.exists(self.test_script_dir):
            shutil.rmtree(self.test_script_dir)
    
    def test_process_start_stop_lifecycle(self):
        """í”„ë¡œì„¸ìŠ¤ ì‹œì‘/ì¤‘ì§€ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸"""
        try:
            # í…ŒìŠ¤íŠ¸ìš© í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
            time.sleep(2)
            self.assertIsNone(process.poll(), "í”„ë¡œì„¸ìŠ¤ê°€ ì˜ˆìƒì¹˜ ëª»í•˜ê²Œ ì¢…ë£Œë¨")
            
            # í”„ë¡œì„¸ìŠ¤ PID í™•ì¸
            pid = process.pid
            self.assertIsNotNone(pid)
            self.assertTrue(psutil.pid_exists(pid), "í”„ë¡œì„¸ìŠ¤ PIDê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ")
            
            # í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ
            process.terminate()
            
            # ì¢…ë£Œ ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
            try:
                process.wait(timeout=5)
                print("âœ… í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ ì™„ë£Œ")
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
                print("âš ï¸ í”„ë¡œì„¸ìŠ¤ ê°•ì œ ì¢…ë£Œë¨")
            
            # í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
            self.assertIsNotNone(process.poll(), "í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì§€ ì•ŠìŒ")
            
            print("âœ… í”„ë¡œì„¸ìŠ¤ ì‹œì‘/ì¤‘ì§€ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"í”„ë¡œì„¸ìŠ¤ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_process_restart_scenario(self):
        """í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸"""
        try:
            processes = []
            
            # ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process1 = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            processes.append(process1)
            
            time.sleep(2)
            pid1 = process1.pid
            self.assertTrue(psutil.pid_exists(pid1), "ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            
            # ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            process1.terminate()
            process1.wait(timeout=5)
            
            # ì¬ì‹œì‘ (ë‘ ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤)
            time.sleep(1)
            process2 = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            processes.append(process2)
            
            time.sleep(2)
            pid2 = process2.pid
            self.assertTrue(psutil.pid_exists(pid2), "ì¬ì‹œì‘ëœ í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            self.assertNotEqual(pid1, pid2, "ì¬ì‹œì‘ëœ í”„ë¡œì„¸ìŠ¤ì˜ PIDê°€ ë™ì¼í•¨")
            
            # ì •ë¦¬
            for process in processes:
                if process.poll() is None:
                    process.terminate()
                    try:
                        process.wait(timeout=3)
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
            
            print("âœ… í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_multiple_process_management(self):
        """ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸"""
        try:
            processes = []
            process_count = 3
            
            # ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ ë™ì‹œ ì‹œì‘
            for i in range(process_count):
                process = subprocess.Popen([
                    sys.executable, self.test_script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                processes.append(process)
                time.sleep(0.5)  # ì‹œì‘ ê°„ê²©
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
            time.sleep(2)
            running_count = 0
            for process in processes:
                if process.poll() is None:
                    running_count += 1
            
            self.assertEqual(running_count, process_count, f"ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ìˆ˜ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦„: {running_count}/{process_count}")
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            for process in processes:
                if process.poll() is None:
                    process.terminate()
            
            # ì¢…ë£Œ ëŒ€ê¸°
            for process in processes:
                try:
                    process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait()
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
            terminated_count = 0
            for process in processes:
                if process.poll() is not None:
                    terminated_count += 1
            
            self.assertEqual(terminated_count, process_count, f"ì¢…ë£Œëœ í”„ë¡œì„¸ìŠ¤ ìˆ˜ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦„: {terminated_count}/{process_count}")
            
            print(f"âœ… ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ ({process_count}ê°œ í”„ë¡œì„¸ìŠ¤)")
            
        except Exception as e:
            self.fail(f"ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class TestAutoRecoverySimulation(unittest.TestCase):
    """ìë™ ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜ ë° ê²€ì¦ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # Mock ì„¤ì •
        self.setup_mocks()
        
    def setup_mocks(self):
        """Mock ê°ì²´ ì„¤ì •"""
        config_mock = MagicMock()
        config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
        config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
        config_mock.API_CONFIG = {}
        sys.modules['config'] = config_mock
        
        core_mock = MagicMock()
        sys.modules['core'] = core_mock
        sys.modules['core.state_manager'] = MagicMock()
        sys.modules['core.process_manager'] = MagicMock()
        sys.modules['core.colorful_ui'] = MagicMock()
    
    def test_three_stage_recovery_simulation(self):
        """3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # ë³µêµ¬ ì‹œë‚˜ë¦¬ì˜¤ë³„ í…ŒìŠ¤íŠ¸ ë°ì´í„°
                        recovery_scenarios = [
                            {
                                'name': '1ë‹¨ê³„ ì¦‰ì‹œ ë³µêµ¬ ì„±ê³µ',
                                'stage_1_success': True,
                                'stage_2_success': False,
                                'stage_3_success': False,
                                'expected_result': True
                            },
                            {
                                'name': '2ë‹¨ê³„ ë³µêµ¬ ì„±ê³µ',
                                'stage_1_success': False,
                                'stage_2_success': True,
                                'stage_3_success': False,
                                'expected_result': True
                            },
                            {
                                'name': '3ë‹¨ê³„ ë³µêµ¬ ì„±ê³µ',
                                'stage_1_success': False,
                                'stage_2_success': False,
                                'stage_3_success': True,
                                'expected_result': True
                            },
                            {
                                'name': 'ëª¨ë“  ë³µêµ¬ ë‹¨ê³„ ì‹¤íŒ¨',
                                'stage_1_success': False,
                                'stage_2_success': False,
                                'stage_3_success': False,
                                'expected_result': False
                            }
                        ]
                        
                        for scenario in recovery_scenarios:
                            with self.subTest(scenario=scenario['name']):
                                # ProcessManager mock ì„¤ì •
                                process_manager_mock = MagicMock()
                                
                                # ë³µêµ¬ ë‹¨ê³„ë³„ ê²°ê³¼ ì‹œë®¬ë ˆì´ì…˜
                                def auto_recovery_side_effect(process_name):
                                    # ì‹¤ì œ ë³µêµ¬ ë¡œì§ ì‹œë®¬ë ˆì´ì…˜
                                    if scenario['stage_1_success']:
                                        return True
                                    elif scenario['stage_2_success']:
                                        return True
                                    elif scenario['stage_3_success']:
                                        return True
                                    else:
                                        return False
                                
                                process_manager_mock.auto_recovery.side_effect = auto_recovery_side_effect
                                
                                # ProcessInfo mock
                                process_info_mock = MagicMock()
                                process_info_mock.restart_count = 0
                                process_info_mock.last_error = "Simulated process failure"
                                process_manager_mock.get_process_info.return_value = process_info_mock
                                
                                # NotificationManager mock
                                notification_manager_mock = MagicMock()
                                notification_manager_mock.send_recovery_success = MagicMock()
                                notification_manager_mock.send_critical_alert = MagicMock()
                                
                                # ModuleRegistry mock
                                module_registry_mock = MagicMock()
                                module_registry_mock.list_modules.return_value = {'test_process': MagicMock()}
                                
                                # mock ëª¨ë“ˆ ì„¤ì •
                                mock_module_obj = MagicMock()
                                mock_module_obj.ProcessManager = lambda x: process_manager_mock
                                mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                                mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                                
                                mock_spec.return_value = MagicMock()
                                mock_module.return_value = mock_module_obj
                                
                                from monitor_WatchHamster import WatchHamster v3.00Monitor
                                watchhamster = WatchHamster v3.00Monitor()
                                
                                # ë³µêµ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
                                watchhamster.handle_process_failure_v2('test_process')
                                
                                # ë³µêµ¬ ê²°ê³¼ ê²€ì¦
                                if scenario['expected_result']:
                                    notification_manager_mock.send_recovery_success.assert_called()
                                    print(f"âœ… {scenario['name']} ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ")
                                else:
                                    notification_manager_mock.send_critical_alert.assert_called()
                                    print(f"âœ… {scenario['name']} ì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ")
                        
                        print("âœ… 3ë‹¨ê³„ ì§€ëŠ¥ì  ë³µêµ¬ ì‹œìŠ¤í…œ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
        except Exception as e:
            self.fail(f"3ë‹¨ê³„ ë³µêµ¬ ì‹œìŠ¤í…œ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_recovery_notification_system(self):
        """ë³µêµ¬ ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # NotificationManager mock ì„¤ì •
                        notification_manager_mock = MagicMock()
                        
                        # ì•Œë¦¼ ë©”ì„œë“œë“¤ mock
                        notification_manager_mock.send_recovery_success = MagicMock(return_value=True)
                        notification_manager_mock.send_critical_alert = MagicMock(return_value=True)
                        notification_manager_mock.send_startup_notification = MagicMock(return_value=True)
                        
                        # ê¸°íƒ€ ì»´í¬ë„ŒíŠ¸ mock
                        process_manager_mock = MagicMock()
                        module_registry_mock = MagicMock()
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # ë‹¤ì–‘í•œ ì•Œë¦¼ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
                        test_scenarios = [
                            ('startup', 'send_startup_notification'),
                            ('recovery_success', 'send_recovery_success'),
                            ('critical_alert', 'send_critical_alert')
                        ]
                        
                        for scenario_name, method_name in test_scenarios:
                            if hasattr(notification_manager_mock, method_name):
                                method = getattr(notification_manager_mock, method_name)
                                method('test_process', 'Test message')
                                method.assert_called()
                                print(f"âœ… {scenario_name} ì•Œë¦¼ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
                        print("âœ… ë³µêµ¬ ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
        except Exception as e:
            self.fail(f"ë³µêµ¬ ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_recovery_failure_handling(self):
        """ë³µêµ¬ ì‹¤íŒ¨ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # ë³µêµ¬ ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤ mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.auto_recovery.return_value = False  # ë³µêµ¬ ì‹¤íŒ¨
                        
                        # ProcessInfo mock (ë³µêµ¬ ì‹¤íŒ¨ ìƒíƒœ)
                        process_info_mock = MagicMock()
                        process_info_mock.restart_count = 3  # ìµœëŒ€ ì¬ì‹œì‘ íšŸìˆ˜ ì´ˆê³¼
                        process_info_mock.last_error = "Maximum restart attempts exceeded"
                        process_manager_mock.get_process_info.return_value = process_info_mock
                        
                        # NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_critical_alert = MagicMock(return_value=True)
                        
                        # ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {'failed_process': MagicMock()}
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # ë³µêµ¬ ì‹¤íŒ¨ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
                        watchhamster.handle_process_failure_v2('failed_process')
                        
                        # ê¸´ê¸‰ ì•Œë¦¼ì´ ì „ì†¡ë˜ì—ˆëŠ”ì§€ í™•ì¸
                        notification_manager_mock.send_critical_alert.assert_called()
                        
                        # í”„ë¡œì„¸ìŠ¤ ì •ë³´ ì—…ë°ì´íŠ¸ í™•ì¸
                        process_manager_mock.get_process_info.assert_called_with('failed_process')
                        
                        print("âœ… ë³µêµ¬ ì‹¤íŒ¨ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
                        
        except Exception as e:
            self.fail(f"ë³µêµ¬ ì‹¤íŒ¨ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class TestControlCenterIntegration(unittest.TestCase):
    """ì œì–´ì„¼í„° í†µí•© í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.control_center_script = os.path.join(current_dir, 'watchhamster_control_center.sh')
        
    def test_control_center_script_syntax(self):
        """ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ê²€ì‚¬"""
        try:
            if not os.path.exists(self.control_center_script):
                self.skipTest("ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            
            # bash ë¬¸ë²• ê²€ì‚¬
            result = subprocess.run([
                'bash', '-n', self.control_center_script
            ], capture_output=True, text=True)
            
            self.assertEqual(result.returncode, 0, f"ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ì˜¤ë¥˜: {result.stderr}")
            
            print("âœ… ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ê²€ì‚¬ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²• ê²€ì‚¬ ì‹¤íŒ¨: {e}")
    
    def test_control_center_functions_exist(self):
        """ì œì–´ì„¼í„° ì£¼ìš” í•¨ìˆ˜ ì¡´ì¬ í™•ì¸"""
        try:
            if not os.path.exists(self.control_center_script):
                self.skipTest("ì œì–´ì„¼í„° ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            
            with open(self.control_center_script, 'r') as f:
                script_content = f.read()
            
            # í•„ìˆ˜ í•¨ìˆ˜ë“¤ í™•ì¸
            required_functions = [
                'start_watchhamster',
                'stop_watchhamster',
                'check_watchhamster_status',
                'manage_modules',
                'check_managed_processes'
            ]
            
            for function_name in required_functions:
                self.assertIn(f'{function_name}()', script_content, 
                            f"í•„ìˆ˜ í•¨ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤: {function_name}")
            
            print(f"âœ… ì œì–´ì„¼í„° í•„ìˆ˜ í•¨ìˆ˜ í™•ì¸ ì™„ë£Œ ({len(required_functions)}ê°œ)")
            
        except Exception as e:
            self.fail(f"ì œì–´ì„¼í„° í•¨ìˆ˜ ì¡´ì¬ í™•ì¸ ì‹¤íŒ¨: {e}")


def run_comprehensive_tests():
    """ì¢…í•©ì ì¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    print("ğŸ§ª POSCO WatchHamster v3.0 ì¢…í•© í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ ì‹œì‘")
    print("=" * 80)
    
    # í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ êµ¬ì„±
    test_classes = [
        TestV2ComponentInitialization,
        TestWatchHamster v3.0Communication,
        TestProcessLifecycleManagement,
        TestAutoRecoverySimulation,
        TestControlCenterIntegration
    ]
    
    total_tests = 0
    passed_tests = 0
    failed_tests = 0
    
    for test_class in test_classes:
        print(f"\nğŸ“‹ {test_class.__name__} ì‹¤í–‰ ì¤‘...")
        print("-" * 60)
        
        # í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ ìƒì„± ë° ì‹¤í–‰
        suite = unittest.TestLoader().loadTestsFromTestCase(test_class)
        runner = unittest.TextTestRunner(verbosity=2, stream=sys.stdout)
        result = runner.run(suite)
        
        # ê²°ê³¼ ì§‘ê³„
        total_tests += result.testsRun
        passed_tests += result.testsRun - len(result.failures) - len(result.errors)
        failed_tests += len(result.failures) + len(result.errors)
        
        # ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ ìƒì„¸ ì •ë³´
        if result.failures or result.errors:
            print(f"\nâŒ {test_class.__name__} ì‹¤íŒ¨ ìƒì„¸:")
            for test, traceback in result.failures + result.errors:
                print(f"  â€¢ {test}: {traceback.split('AssertionError:')[-1].strip() if 'AssertionError:' in traceback else 'Unknown error'}")
    
    # ìµœì¢… ê²°ê³¼ ìš”ì•½
    print("\n" + "=" * 80)
    print("ğŸ¯ ì¢…í•© í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
    print("=" * 80)
    print(f"ğŸ“Š ì´ í…ŒìŠ¤íŠ¸: {total_tests}ê°œ")
    print(f"âœ… í†µê³¼: {passed_tests}ê°œ")
    print(f"âŒ ì‹¤íŒ¨: {failed_tests}ê°œ")
    print(f"ğŸ“ˆ ì„±ê³µë¥ : {(passed_tests/total_tests*100):.1f}%" if total_tests > 0 else "ğŸ“ˆ ì„±ê³µë¥ : 0%")
    
    if failed_tests == 0:
        print("\nğŸ‰ ëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
        print("âœ… v2 í†µí•© ì‹œìŠ¤í…œì´ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.")
        return True
    else:
        print(f"\nâš ï¸ {failed_tests}ê°œì˜ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        print("ğŸ”§ ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ë¥¼ ê²€í† í•˜ê³  ìˆ˜ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.")
        return False


if __name__ == '__main__':
    success = run_comprehensive_tests()
    sys.exit(0 if success else 1)