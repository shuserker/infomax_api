#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test Watchhamster V3.0 Integration
POSCO 시스템 테스트

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import os
import sys
import unittest
import subprocess
import time
import signal
import threading
import tempfile
import shutil
import json
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch, Mock
import psutil

# 테스트를 위해 경로 설정
current_dir = os.path.dirname(os.path.abspath(__file__))
POSCO News 250808_mini')
sys.path.insert(0, posco_mini_dir)

class TestWatchHamster v3.00ComponentInitialization(unittest.TestCase):
    """v2 컴포넌트 초기화 단위 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        # 환경 변수 설정 (테스트용)
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # 테스트용 임시 디렉토리 생성
        self.test_dir = tempfile.mkdtemp()
        self.original_cwd = os.getcwd()
        
    def tearDown(self):
        """테스트 정리"""
        # 임시 디렉토리 정리
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
        os.chdir(self.original_cwd)
        
    def test_v2_components_import(self):
        """v2 컴포넌트 import 테스트"""
        try:
            # v2 컴포넌트들이 올바르게 import되는지 확인
            v2_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0')
            
            # 디렉토리 존재 확인
            self.assertTrue(os.path.exists(v2_path), "v2 디렉토리가 존재하지 않습니다")
            
            # core 디렉토리 확인
            core_path = os.path.join(v2_path, 'core')
            self.assertTrue(os.path.exists(core_path), "v2 core 디렉토리가 존재하지 않습니다")
            
            # modules.json 파일 확인
            modules_json = os.path.join(v2_path, 'modules.json')
            self.assertTrue(os.path.exists(modules_json), "modules.json 파일이 존재하지 않습니다")
            
            # 개별 컴포넌트 파일 확인
            components = [
                'enhanced_process_manager.py',
                'module_registry.py', 
                'notification_manager.py'
            ]
            
            for component in components:
                component_path = os.path.join(core_path, component)
                self.assertTrue(os.path.exists(component_path), 
                              f"{component} 파일이 존재하지 않습니다")
            
            print("✅ v2 컴포넌트 파일 구조 검증 완료")
            
        except Exception as e:
            self.fail(f"v2 컴포넌트 import 테스트 실패: {e}")
    
    def test_watchhamster_initialization(self):
        """WatchHamster v3.0 초기화 테스트"""
        try:
            # config 모듈 mock (테스트용)
            import sys
            from unittest.mock import MagicMock
            
            # config 모듈 mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            # core 모듈들 mock
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            sys.modules['core.colorful_ui'] = MagicMock()
            
            # WatchHamster v3.0 초기화
            from monitor_WatchHamster import WatchHamster v3.00Monitor
            
            # 워치햄스터 인스턴스 생성
            watchhamster = WatchHamster v3.00Monitor()
            
            # 기본 속성 확인
            self.assertIsNotNone(watchhamster.script_dir)
            self.assertIsNotNone(watchhamster.log_file)
            self.assertIsNotNone(watchhamster.status_file)
            
            # v2 통합 상태 확인
            self.assertIsInstance(watchhamster.v3_0_enabled, bool)
            self.assertIsInstance(watchhamster.v3_0_components, dict)
            
            # 관리 대상 프로세스 목록 확인
            self.assertIsInstance(watchhamster.managed_processes, list)
            self.assertGreater(len(watchhamster.managed_processes), 0)
            
            print(f"✅ WatchHamster v3.0 초기화 완료")
            print(f"   - v2 활성화: {watchhamster.v3_0_enabled}")
            print(f"   - 관리 프로세스: {len(watchhamster.managed_processes)}개")
            print(f"   - 폴백 사유: {watchhamster.fallback_reason}")
            
            # v2 통합 상태 정보 조회
            integration_status = watchhamster.get_v2_integration_status()
            self.assertIsInstance(integration_status, dict)
            self.assertIn('v3_0_enabled', integration_status)
            
            print("✅ v2 통합 상태 조회 완료")
            
        except Exception as e:
            self.fail(f"WatchHamster v3.0 초기화 테스트 실패: {e}")
    
    def test_v2_fallback_mechanism(self):
        """v2 폴백 메커니즘 테스트"""
        try:
            # v2 디렉토리를 임시로 숨겨서 폴백 테스트
            v2_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0')
            temp_path = os.path.join(current_dir, 'Monitoring', 'WatchHamster_v3.0_temp')
            
            # 실제 파일 시스템 조작 대신 mock을 사용
            import sys
            from unittest.mock import MagicMock, patch
            
            # config 모듈 mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            # core 모듈들 mock
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # os.path.exists를 mock하여 v2 디렉토리가 없는 것처럼 시뮬레이션
            with patch('os.path.exists') as mock_exists:
                def side_effect(path):
                    if 'WatchHamster_v3.0' in path:
                        return False  # v2 디렉토리가 없는 것처럼
                    return True  # 다른 경로는 정상
                
                mock_exists.side_effect = side_effect
                
                from monitor_WatchHamster import WatchHamster v3.00Monitor
                watchhamster = WatchHamster v3.00Monitor()
                
                # 폴백이 올바르게 동작했는지 확인
                self.assertFalse(watchhamster.v3_0_enabled)
                self.assertIsNotNone(watchhamster.fallback_reason)
                self.assertIn('찾을 수 없습니다', watchhamster.fallback_reason)
                
                print("✅ v2 폴백 메커니즘 테스트 완료")
                print(f"   - 폴백 사유: {watchhamster.fallback_reason}")
                
        except Exception as e:
            self.fail(f"v2 폴백 메커니즘 테스트 실패: {e}")
    
    def test_process_management_integration(self):
        """프로세스 관리 통합 테스트"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config 및 core 모듈 mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 컴포넌트 mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ProcessManager mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_system_status.return_value = {
                            'timestamp': '2025-01-01T00:00:00',
                            'process_details': {}
                        }
                        process_manager_mock.perform_health_check.return_value = {
                            'posco_main_notifier': True,
                            'realtime_news_monitor': True
                        }
                        process_manager_mock.auto_recovery.return_value = True
                        
                        # v2 ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {
                            'posco_main_notifier': MagicMock(),
                            'realtime_news_monitor': MagicMock()
                        }
                        module_registry_mock.get_startup_order.return_value = [
                            'POSCO News 250808_monitor'
                        ]
                        
                        # v2 NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.get_notification_stats.return_value = {
                            'total_notifications': 0
                        }
                        
                        # mock 모듈 설정
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # v2 통합 상태 확인
                        self.assertTrue(watchhamster.v3_0_enabled)
                        self.assertIsNotNone(watchhamster.v3_0_components['process_manager'])
                        self.assertIsNotNone(watchhamster.v3_0_components['module_registry'])
                        self.assertIsNotNone(watchhamster.v3_0_components['notification_manager'])
                        
                        # 프로세스 실패 처리 테스트
                        watchhamster.handle_process_failure_v2('test_process')
                        
                        # 헬스체크 테스트
                        health_results = watchhamster.v3_0_components['process_manager'].perform_health_check()
                        self.assertIsInstance(health_results, dict)
                        
                        print("✅ 프로세스 관리 통합 테스트 완료")
                        print(f"   - v2 ProcessManager 연동: ✅")
                        print(f"   - 3단계 복구 시스템: ✅")
                        print(f"   - 헬스체크 시스템: ✅")
                        
        except Exception as e:
            self.fail(f"프로세스 관리 통합 테스트 실패: {e}")
    
    def test_three_stage_recovery_system(self):
        """3단계 지능적 복구 시스템 테스트"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config 및 core 모듈 mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 컴포넌트 mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # ProcessInfo mock
                        process_info_mock = MagicMock()
                        process_info_mock.restart_count = 1
                        process_info_mock.last_error = "Test error"
                        process_info_mock.pid = 12345
                        
                        # v2 ProcessManager mock (3단계 복구 시뮬레이션)
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_process_info.return_value = process_info_mock
                        
                        # 복구 시나리오별 테스트
                        recovery_scenarios = [
                            (True, "1단계 즉시 복구 성공"),
                            (False, "모든 복구 단계 실패")
                        ]
                        
                        for recovery_success, scenario_name in recovery_scenarios:
                            process_manager_mock.auto_recovery.return_value = recovery_success
                            
                            # v2 ModuleRegistry mock
                            module_registry_mock = MagicMock()
                            module_registry_mock.list_modules.return_value = {'test_process': MagicMock()}
                            
                            # v2 NotificationManager mock
                            notification_manager_mock = MagicMock()
                            notification_manager_mock.send_recovery_success = MagicMock()
                            notification_manager_mock.send_critical_alert = MagicMock()
                            
                            # mock 모듈 설정
                            mock_module_obj = MagicMock()
                            mock_module_obj.ProcessManager = lambda x: process_manager_mock
                            mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                            mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                            
                            mock_spec.return_value = MagicMock()
                            mock_module.return_value = mock_module_obj
                            
                            from monitor_WatchHamster import WatchHamster v3.00Monitor
                            watchhamster = WatchHamster v3.00Monitor()
                            
                            # 3단계 복구 시스템 테스트
                            watchhamster.handle_process_failure_v2('test_process')
                            
                            # 복구 결과에 따른 알림 호출 확인
                            if recovery_success:
                                notification_manager_mock.send_recovery_success.assert_called()
                                print(f"✅ {scenario_name} 테스트 완료")
                            else:
                                notification_manager_mock.send_critical_alert.assert_called()
                                print(f"✅ {scenario_name} 테스트 완료")
                        
                        print("✅ 3단계 지능적 복구 시스템 테스트 완료")
                        print("   - 1단계: 즉시 재시작 ✅")
                        print("   - 2단계: 5분 후 재시도 ✅")
                        print("   - 3단계: 최종 재시도 ✅")
                        print("   - 복구 실패 시 알림 ✅")
                        
        except Exception as e:
            self.fail(f"3단계 복구 시스템 테스트 실패: {e}")
    
    def test_process_lifecycle_management(self):
        """프로세스 생명주기 관리 테스트"""
        try:
            import sys
            from unittest.mock import MagicMock, patch
            
            # config 및 core 모듈 mock
            config_mock = MagicMock()
            config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
            config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
            config_mock.API_CONFIG = {}
            sys.modules['config'] = config_mock
            
            core_mock = MagicMock()
            sys.modules['core'] = core_mock
            sys.modules['core.state_manager'] = MagicMock()
            sys.modules['core.process_manager'] = MagicMock()
            
            # v2 컴포넌트 mock
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 ProcessManager mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.start_process.return_value = True
                        process_manager_mock.stop_process.return_value = True
                        process_manager_mock.is_process_running.return_value = True
                        
                        # 모듈 설정 mock
                        module_config_mock = MagicMock()
                        module_config_mock.auto_start = True
                        module_config_mock.script_path = 'test_script.py'
                        module_config_mock.working_directory = '.'
                        module_config_mock.priority = 1
                        
                        # v2 ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.get_modules_by_dependency_order.return_value = [
                            'POSCO News 250808_monitor'
                        ]
                        module_registry_mock.get_module_config.return_value = module_config_mock
                        
                        # v2 NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_startup_notification = MagicMock()
                        
                        # mock 모듈 설정
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # 프로세스 시작 테스트
                        start_result = watchhamster._start_processes_v2()
                        self.assertTrue(start_result)
                        
                        # ProcessManager 메서드 호출 확인
                        process_manager_mock.start_process.assert_called()
                        
                        # 알림 전송 확인
                        notification_manager_mock.send_startup_notification.assert_called()
                        
                        print("✅ 프로세스 생명주기 관리 테스트 완료")
                        print("   - 의존성 순서 시작: ✅")
                        print("   - 프로세스 상태 추적: ✅")
                        print("   - 시작 알림 전송: ✅")
                        
        except Exception as e:
            self.fail(f"프로세스 생명주기 관리 테스트 실패: {e}")


class TestWatchHamster v3.00Communication(unittest.TestCase):
    """WatchHamster v3.0.0 컴포넌트 통신 통합 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # Mock 설정
        self.setup_mocks()
        
    def setup_mocks(self):
        """Mock 객체 설정"""
        # config 모듈 mock
        config_mock = MagicMock()
        config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
        config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
        config_mock.API_CONFIG = {}
        sys.modules['config'] = config_mock
        
        # core 모듈들 mock
        core_mock = MagicMock()
        sys.modules['core'] = core_mock
        sys.modules['core.state_manager'] = MagicMock()
        sys.modules['core.process_manager'] = MagicMock()
        sys.modules['core.colorful_ui'] = MagicMock()
    
    def test_watchhamster_v3_0_component_communication(self):
        """WatchHamster v3.0.0 컴포넌트 간 통신 테스트"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 컴포넌트 mock 설정
                        process_manager_mock = MagicMock()
                        process_manager_mock.get_system_status.return_value = {
                            'timestamp': datetime.now().isoformat(),
                            'process_details': {'test_process': {'status': 'running'}}
                        }
                        
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {
                            'posco_main_notifier': {'config': MagicMock(), 'status': 'active'}
                        }
                        
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_notification.return_value = True
                        
                        # mock 모듈 설정
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # 통신 테스트
                        self.assertTrue(watchhamster.v3_0_enabled)
                        
                        # ProcessManager 통신 테스트
                        status = watchhamster.v3_0_components['process_manager'].get_system_status()
                        self.assertIsInstance(status, dict)
                        self.assertIn('timestamp', status)
                        
                        # ModuleRegistry 통신 테스트
                        modules = watchhamster.v3_0_components['module_registry'].list_modules()
                        self.assertIsInstance(modules, dict)
                        
                        # NotificationManager 통신 테스트
                        result = watchhamster.v3_0_components['notification_manager'].send_notification("Test message")
                        self.assertTrue(result)
                        
                        print("✅ WatchHamster v3.0.0 컴포넌트 통신 테스트 완료")
                        
        except Exception as e:
            self.fail(f"WatchHamster v3.0.0 컴포넌트 통신 테스트 실패: {e}")
    
    def test_v2_integration_status_reporting(self):
        """v2 통합 상태 보고 테스트"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # v2 컴포넌트 mock 설정
                        process_manager_mock = MagicMock()
                        module_registry_mock = MagicMock()
                        notification_manager_mock = MagicMock()
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # v2 통합 상태 조회 테스트
                        integration_status = watchhamster.get_v2_integration_status()
                        
                        self.assertIsInstance(integration_status, dict)
                        self.assertIn('v3_0_enabled', integration_status)
                        self.assertIn('components_loaded', integration_status)
                        self.assertIn('initialization_time', integration_status)
                        
                        print("✅ v2 통합 상태 보고 테스트 완료")
                        
        except Exception as e:
            self.fail(f"v2 통합 상태 보고 테스트 실패: {e}")


class TestWatchHamster v3.00ProcessLifecycleManagement(unittest.TestCase):
    """프로세스 생명주기 테스트 (시작/중지/재시작)"""
    
    def setUp(self):
        """테스트 설정"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # 테스트용 스크립트 생성
        self.test_script_dir = tempfile.mkdtemp()
        self.test_script_path = os.path.join(self.test_script_dir, 'test_process.py')
        
        # 간단한 테스트 스크립트 생성
        test_script_content = '''#!/usr/bin/env python3
import time
import sys
import signal

def signal_handler(signum, frame):
    print("Process terminated gracefully")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print("Test process started")
try:
    while True:
        time.sleep(1)
        print("Test process running...")
except KeyboardInterrupt:
    print("Process interrupted")
    sys.exit(0)
'''
        with open(self.test_script_path, 'w') as f:
            f.write(test_script_content)
        os.chmod(self.test_script_path, 0o755)
        
    def tearDown(self):
        """테스트 정리"""
        if os.path.exists(self.test_script_dir):
            shutil.rmtree(self.test_script_dir)
    
    def test_process_start_stop_lifecycle(self):
        """프로세스 시작/중지 생명주기 테스트"""
        try:
            # 테스트용 프로세스 시작
            process = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # 프로세스가 시작되었는지 확인
            time.sleep(2)
            self.assertIsNone(process.poll(), "프로세스가 예상치 못하게 종료됨")
            
            # 프로세스 PID 확인
            pid = process.pid
            self.assertIsNotNone(pid)
            self.assertTrue(psutil.pid_exists(pid), "프로세스 PID가 존재하지 않음")
            
            # 프로세스 정상 종료
            process.terminate()
            
            # 종료 대기 (최대 5초)
            try:
                process.wait(timeout=5)
                print("✅ 프로세스 정상 종료 완료")
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
                print("⚠️ 프로세스 강제 종료됨")
            
            # 프로세스가 종료되었는지 확인
            self.assertIsNotNone(process.poll(), "프로세스가 종료되지 않음")
            
            print("✅ 프로세스 시작/중지 생명주기 테스트 완료")
            
        except Exception as e:
            self.fail(f"프로세스 생명주기 테스트 실패: {e}")
    
    def test_process_restart_scenario(self):
        """프로세스 재시작 시나리오 테스트"""
        try:
            processes = []
            
            # 첫 번째 프로세스 시작
            process1 = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            processes.append(process1)
            
            time.sleep(2)
            pid1 = process1.pid
            self.assertTrue(psutil.pid_exists(pid1), "첫 번째 프로세스가 시작되지 않음")
            
            # 첫 번째 프로세스 종료
            process1.terminate()
            process1.wait(timeout=5)
            
            # 재시작 (두 번째 프로세스)
            time.sleep(1)
            process2 = subprocess.Popen([
                sys.executable, self.test_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            processes.append(process2)
            
            time.sleep(2)
            pid2 = process2.pid
            self.assertTrue(psutil.pid_exists(pid2), "재시작된 프로세스가 시작되지 않음")
            self.assertNotEqual(pid1, pid2, "재시작된 프로세스의 PID가 동일함")
            
            # 정리
            for process in processes:
                if process.poll() is None:
                    process.terminate()
                    try:
                        process.wait(timeout=3)
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
            
            print("✅ 프로세스 재시작 시나리오 테스트 완료")
            
        except Exception as e:
            self.fail(f"프로세스 재시작 테스트 실패: {e}")
    
    def test_multiple_process_management(self):
        """다중 프로세스 관리 테스트"""
        try:
            processes = []
            process_count = 3
            
            # 여러 프로세스 동시 시작
            for i in range(process_count):
                process = subprocess.Popen([
                    sys.executable, self.test_script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                processes.append(process)
                time.sleep(0.5)  # 시작 간격
            
            # 모든 프로세스가 시작되었는지 확인
            time.sleep(2)
            running_count = 0
            for process in processes:
                if process.poll() is None:
                    running_count += 1
            
            self.assertEqual(running_count, process_count, f"실행 중인 프로세스 수가 예상과 다름: {running_count}/{process_count}")
            
            # 모든 프로세스 종료
            for process in processes:
                if process.poll() is None:
                    process.terminate()
            
            # 종료 대기
            for process in processes:
                try:
                    process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait()
            
            # 모든 프로세스가 종료되었는지 확인
            terminated_count = 0
            for process in processes:
                if process.poll() is not None:
                    terminated_count += 1
            
            self.assertEqual(terminated_count, process_count, f"종료된 프로세스 수가 예상과 다름: {terminated_count}/{process_count}")
            
            print(f"✅ 다중 프로세스 관리 테스트 완료 ({process_count}개 프로세스)")
            
        except Exception as e:
            self.fail(f"다중 프로세스 관리 테스트 실패: {e}")


class TestAutoRecoverySimulation(unittest.TestCase):
    """자동 복구 시뮬레이션 및 검증 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        
        # Mock 설정
        self.setup_mocks()
        
    def setup_mocks(self):
        """Mock 객체 설정"""
        config_mock = MagicMock()
        config_mock.WATCHHAMSTER_WEBHOOK_URL = 'https://test.webhook.url'
        config_mock.BOT_PROFILE_IMAGE_URL = 'https://test.image.url'
        config_mock.API_CONFIG = {}
        sys.modules['config'] = config_mock
        
        core_mock = MagicMock()
        sys.modules['core'] = core_mock
        sys.modules['core.state_manager'] = MagicMock()
        sys.modules['core.process_manager'] = MagicMock()
        sys.modules['core.colorful_ui'] = MagicMock()
    
    def test_three_stage_recovery_simulation(self):
        """3단계 지능적 복구 시스템 시뮬레이션 테스트"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # 복구 시나리오별 테스트 데이터
                        recovery_scenarios = [
                            {
                                'name': '1단계 즉시 복구 성공',
                                'stage_1_success': True,
                                'stage_2_success': False,
                                'stage_3_success': False,
                                'expected_result': True
                            },
                            {
                                'name': '2단계 복구 성공',
                                'stage_1_success': False,
                                'stage_2_success': True,
                                'stage_3_success': False,
                                'expected_result': True
                            },
                            {
                                'name': '3단계 복구 성공',
                                'stage_1_success': False,
                                'stage_2_success': False,
                                'stage_3_success': True,
                                'expected_result': True
                            },
                            {
                                'name': '모든 복구 단계 실패',
                                'stage_1_success': False,
                                'stage_2_success': False,
                                'stage_3_success': False,
                                'expected_result': False
                            }
                        ]
                        
                        for scenario in recovery_scenarios:
                            with self.subTest(scenario=scenario['name']):
                                # ProcessManager mock 설정
                                process_manager_mock = MagicMock()
                                
                                # 복구 단계별 결과 시뮬레이션
                                def auto_recovery_side_effect(process_name):
                                    # 실제 복구 로직 시뮬레이션
                                    if scenario['stage_1_success']:
                                        return True
                                    elif scenario['stage_2_success']:
                                        return True
                                    elif scenario['stage_3_success']:
                                        return True
                                    else:
                                        return False
                                
                                process_manager_mock.auto_recovery.side_effect = auto_recovery_side_effect
                                
                                # ProcessInfo mock
                                process_info_mock = MagicMock()
                                process_info_mock.restart_count = 0
                                process_info_mock.last_error = "Simulated process failure"
                                process_manager_mock.get_process_info.return_value = process_info_mock
                                
                                # NotificationManager mock
                                notification_manager_mock = MagicMock()
                                notification_manager_mock.send_recovery_success = MagicMock()
                                notification_manager_mock.send_critical_alert = MagicMock()
                                
                                # ModuleRegistry mock
                                module_registry_mock = MagicMock()
                                module_registry_mock.list_modules.return_value = {'test_process': MagicMock()}
                                
                                # mock 모듈 설정
                                mock_module_obj = MagicMock()
                                mock_module_obj.ProcessManager = lambda x: process_manager_mock
                                mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                                mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                                
                                mock_spec.return_value = MagicMock()
                                mock_module.return_value = mock_module_obj
                                
                                from monitor_WatchHamster import WatchHamster v3.00Monitor
                                watchhamster = WatchHamster v3.00Monitor()
                                
                                # 복구 시스템 테스트
                                watchhamster.handle_process_failure_v2('test_process')
                                
                                # 복구 결과 검증
                                if scenario['expected_result']:
                                    notification_manager_mock.send_recovery_success.assert_called()
                                    print(f"✅ {scenario['name']} 시뮬레이션 완료")
                                else:
                                    notification_manager_mock.send_critical_alert.assert_called()
                                    print(f"✅ {scenario['name']} 시뮬레이션 완료")
                        
                        print("✅ 3단계 지능적 복구 시스템 시뮬레이션 테스트 완료")
                        
        except Exception as e:
            self.fail(f"3단계 복구 시스템 시뮬레이션 테스트 실패: {e}")
    
    def test_recovery_notification_system(self):
        """복구 알림 시스템 테스트"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # NotificationManager mock 설정
                        notification_manager_mock = MagicMock()
                        
                        # 알림 메서드들 mock
                        notification_manager_mock.send_recovery_success = MagicMock(return_value=True)
                        notification_manager_mock.send_critical_alert = MagicMock(return_value=True)
                        notification_manager_mock.send_startup_notification = MagicMock(return_value=True)
                        
                        # 기타 컴포넌트 mock
                        process_manager_mock = MagicMock()
                        module_registry_mock = MagicMock()
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # 다양한 알림 시나리오 테스트
                        test_scenarios = [
                            ('startup', 'send_startup_notification'),
                            ('recovery_success', 'send_recovery_success'),
                            ('critical_alert', 'send_critical_alert')
                        ]
                        
                        for scenario_name, method_name in test_scenarios:
                            if hasattr(notification_manager_mock, method_name):
                                method = getattr(notification_manager_mock, method_name)
                                method('test_process', 'Test message')
                                method.assert_called()
                                print(f"✅ {scenario_name} 알림 테스트 완료")
                        
                        print("✅ 복구 알림 시스템 테스트 완료")
                        
        except Exception as e:
            self.fail(f"복구 알림 시스템 테스트 실패: {e}")
    
    def test_recovery_failure_handling(self):
        """복구 실패 처리 테스트"""
        try:
            with patch('os.path.exists', return_value=True):
                with patch('importlib.util.spec_from_file_location') as mock_spec:
                    with patch('importlib.util.module_from_spec') as mock_module:
                        # 복구 실패 시나리오 mock
                        process_manager_mock = MagicMock()
                        process_manager_mock.auto_recovery.return_value = False  # 복구 실패
                        
                        # ProcessInfo mock (복구 실패 상태)
                        process_info_mock = MagicMock()
                        process_info_mock.restart_count = 3  # 최대 재시작 횟수 초과
                        process_info_mock.last_error = "Maximum restart attempts exceeded"
                        process_manager_mock.get_process_info.return_value = process_info_mock
                        
                        # NotificationManager mock
                        notification_manager_mock = MagicMock()
                        notification_manager_mock.send_critical_alert = MagicMock(return_value=True)
                        
                        # ModuleRegistry mock
                        module_registry_mock = MagicMock()
                        module_registry_mock.list_modules.return_value = {'failed_process': MagicMock()}
                        
                        mock_module_obj = MagicMock()
                        mock_module_obj.ProcessManager = lambda x: process_manager_mock
                        mock_module_obj.ModuleRegistry = lambda x: module_registry_mock
                        mock_module_obj.NotificationManager = lambda x, y: notification_manager_mock
                        
                        mock_spec.return_value = MagicMock()
                        mock_module.return_value = mock_module_obj
                        
                        from monitor_WatchHamster import WatchHamster v3.00Monitor
                        watchhamster = WatchHamster v3.00Monitor()
                        
                        # 복구 실패 처리 테스트
                        watchhamster.handle_process_failure_v2('failed_process')
                        
                        # 긴급 알림이 전송되었는지 확인
                        notification_manager_mock.send_critical_alert.assert_called()
                        
                        # 프로세스 정보 업데이트 확인
                        process_manager_mock.get_process_info.assert_called_with('failed_process')
                        
                        print("✅ 복구 실패 처리 테스트 완료")
                        
        except Exception as e:
            self.fail(f"복구 실패 처리 테스트 실패: {e}")


class TestControlCenterIntegration(unittest.TestCase):
    """제어센터 통합 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        self.control_center_script = os.path.join(current_dir, 'watchhamster_control_center.sh')
        
    def test_control_center_script_syntax(self):
        """제어센터 스크립트 문법 검사"""
        try:
            if not os.path.exists(self.control_center_script):
                self.skipTest("제어센터 스크립트를 찾을 수 없습니다")
            
            # bash 문법 검사
            result = subprocess.run([
                'bash', '-n', self.control_center_script
            ], capture_output=True, text=True)
            
            self.assertEqual(result.returncode, 0, f"제어센터 스크립트 문법 오류: {result.stderr}")
            
            print("✅ 제어센터 스크립트 문법 검사 완료")
            
        except Exception as e:
            self.fail(f"제어센터 스크립트 문법 검사 실패: {e}")
    
    def test_control_center_functions_exist(self):
        """제어센터 주요 함수 존재 확인"""
        try:
            if not os.path.exists(self.control_center_script):
                self.skipTest("제어센터 스크립트를 찾을 수 없습니다")
            
            with open(self.control_center_script, 'r') as f:
                script_content = f.read()
            
            # 필수 함수들 확인
            required_functions = [
                'start_watchhamster',
                'stop_watchhamster',
                'check_watchhamster_status',
                'manage_modules',
                'check_managed_processes'
            ]
            
            for function_name in required_functions:
                self.assertIn(f'{function_name}()', script_content, 
                            f"필수 함수가 없습니다: {function_name}")
            
            print(f"✅ 제어센터 필수 함수 확인 완료 ({len(required_functions)}개)")
            
        except Exception as e:
            self.fail(f"제어센터 함수 존재 확인 실패: {e}")


def run_comprehensive_tests():
    """종합적인 테스트 실행"""
    print("🧪 POSCO WatchHamster v3.0 종합 테스트 프레임워크 시작")
    print("=" * 80)
    
    # 테스트 스위트 구성
    test_classes = [
        TestV2ComponentInitialization,
        TestWatchHamster v3.0Communication,
        TestProcessLifecycleManagement,
        TestAutoRecoverySimulation,
        TestControlCenterIntegration
    ]
    
    total_tests = 0
    passed_tests = 0
    failed_tests = 0
    
    for test_class in test_classes:
        print(f"\n📋 {test_class.__name__} 실행 중...")
        print("-" * 60)
        
        # 테스트 스위트 생성 및 실행
        suite = unittest.TestLoader().loadTestsFromTestCase(test_class)
        runner = unittest.TextTestRunner(verbosity=2, stream=sys.stdout)
        result = runner.run(suite)
        
        # 결과 집계
        total_tests += result.testsRun
        passed_tests += result.testsRun - len(result.failures) - len(result.errors)
        failed_tests += len(result.failures) + len(result.errors)
        
        # 실패한 테스트 상세 정보
        if result.failures or result.errors:
            print(f"\n❌ {test_class.__name__} 실패 상세:")
            for test, traceback in result.failures + result.errors:
                print(f"  • {test}: {traceback.split('AssertionError:')[-1].strip() if 'AssertionError:' in traceback else 'Unknown error'}")
    
    # 최종 결과 요약
    print("\n" + "=" * 80)
    print("🎯 종합 테스트 결과 요약")
    print("=" * 80)
    print(f"📊 총 테스트: {total_tests}개")
    print(f"✅ 통과: {passed_tests}개")
    print(f"❌ 실패: {failed_tests}개")
    print(f"📈 성공률: {(passed_tests/total_tests*100):.1f}%" if total_tests > 0 else "📈 성공률: 0%")
    
    if failed_tests == 0:
        print("\n🎉 모든 테스트가 성공적으로 완료되었습니다!")
        print("✅ v2 통합 시스템이 올바르게 동작합니다.")
        return True
    else:
        print(f"\n⚠️ {failed_tests}개의 테스트가 실패했습니다.")
        print("🔧 실패한 테스트를 검토하고 수정이 필요합니다.")
        return False


if __name__ == '__main__':
    success = run_comprehensive_tests()
    sys.exit(0 if success else 1)