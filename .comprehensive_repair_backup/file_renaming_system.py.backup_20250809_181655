#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File Renaming System
POSCO 시스템 구성요소

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import os
import json
import shutil
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set
from dataclasses import dataclass, asdict
from enum import Enum

from naming_convention_manager import NamingConventionManager, ComponentType, ConversionResult


class OperationType(Enum):
    """파일 작업 타입"""
    RENAME_FILE = "rename_file"
    RENAME_FOLDER = "rename_folder"
    MOVE_FILE = "move_file"
    CREATE_FOLDER = "create_folder"


@dataclass
class FileOperation:
    """파일 작업 정보"""
    operation_id: str
    operation_type: OperationType
    source_path: str
    target_path: str
    component: ComponentType
    timestamp: datetime
    success: bool = False
    error_message: str = ""
    rollback_completed: bool = False


@dataclass
class MappingEntry:
    """파일 매핑 엔트리"""
    original_path: str
    new_path: str
    component: ComponentType
    file_type: str  # "file" or "folder"
    exists: bool
    size_bytes: int = 0
    last_modified: Optional[datetime] = None


class FileRenamingSystem:
    """
    파일 및 폴더명 자동 변경 시스템
    
    기존 파일들의 네이밍 패턴을 분석하고 매핑 테이블을 생성하여
    표준화된 네이밍 컨벤션으로 일괄 변경합니다.
    """
    
    def __init__(self, workspace_root: str = "."):
        """
        파일 리네이밍 시스템 초기화
        
        Args:
            workspace_root: 작업 공간 루트 디렉토리
        """
        self.workspace_root = Path(workspace_root).resolve()
        self.naming_manager = NamingConventionManager()
        self.operations_log: List[FileOperation] = []
        self.mapping_table: List[MappingEntry] = []
        
        # 로그 설정
        self.setup_logging()
        
        # 백업 디렉토리 설정
        self.backup_dir = self.workspace_root / ".naming_backup"
        self.backup_dir.mkdir(exist_ok=True)
        
        # 작업 로그 파일
        self.operations_log_file = self.backup_dir / "operations_log.json"
        self.mapping_table_file = self.backup_dir / "mapping_table.json"
        
    def setup_logging(self):
        """로깅 설정"""
        log_file = self.workspace_root / "file_renaming.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def analyze_existing_files(self) -> Dict[ComponentType, List[MappingEntry]]:
        """
        기존 파일들의 네이밍 패턴 분석 및 매핑 테이블 생성
        
        Returns:
            Dict[ComponentType, List[MappingEntry]]: 컴포넌트별 매핑 엔트리
        """
        self.logger.info("기존 파일들의 네이밍 패턴 분석 시작")
        
        # 분석할 파일 패턴들
        file_patterns = [
            "**/*.py", "**/*.bat", "**/*.sh", "**/*.command", "**/*.md",
            "**/*.json", "**/*.log", "**/*.html", "**/*.css", "**/*.js"
        ]
        
        # 제외할 디렉토리들
        exclude_dirs = {
            ".git", "__pycache__", ".kiro", "node_modules", 
            ".vscode", "backup_archive_*", ".naming_backup"
        }
        
        mapping_by_component = {
            ComponentType.WATCHHAMSTER: [],
            ComponentType.POSCO News 250808: [],
            ComponentType.UNKNOWN: []
        }
        
        # 파일 분석
        for pattern in file_patterns:
            for file_path in self.workspace_root.glob(pattern):
                if self._should_exclude_path(file_path, exclude_dirs):
                    continue
                    
                relative_path = file_path.relative_to(self.workspace_root)
                mapping_entry = self._create_mapping_entry(file_path, "file")
                
                if mapping_entry:
                    mapping_by_component[mapping_entry.component].append(mapping_entry)
                    self.mapping_table.append(mapping_entry)
        
        # 폴더 분석
        for dir_path in self.workspace_root.rglob("*"):
            if not dir_path.is_dir() or self._should_exclude_path(dir_path, exclude_dirs):
                continue
                
            mapping_entry = self._create_mapping_entry(dir_path, "folder")
            if mapping_entry and mapping_entry.original_path != mapping_entry.new_path:
                mapping_by_component[mapping_entry.component].append(mapping_entry)
                self.mapping_table.append(mapping_entry)
        
        # 매핑 테이블 저장
        self._save_mapping_table()
        
        self.logger.info(f"분석 완료: 총 {len(self.mapping_table)}개 항목")
        for component, entries in mapping_by_component.items():
            if entries:
                self.logger.info(f"  {component.value}: {len(entries)}개")
        
        return mapping_by_component
    
    def _should_exclude_path(self, path: Path, exclude_dirs: Set[str]) -> bool:
        """경로가 제외 대상인지 확인"""
        path_parts = path.parts
        for exclude_dir in exclude_dirs:
            if exclude_dir.endswith("*"):
                prefix = exclude_dir[:-1]
                if any(part.startswith(prefix) for part in path_parts):
                    return True
            elif exclude_dir in path_parts:
                return True
        return False
    
    def _create_mapping_entry(self, path: Path, file_type: str) -> Optional[MappingEntry]:
        """매핑 엔트리 생성"""
        relative_path = str(path.relative_to(self.workspace_root))
        
        if file_type == "file":
            conversion_result = self.naming_manager.standardize_filename(path.name)
            if conversion_result.success:
                new_relative_path = str(path.parent / conversion_result.converted)
                if path.parent != Path("."):
                    new_relative_path = str(path.parent.relative_to(self.workspace_root) / conversion_result.converted)
                else:
                    new_relative_path = conversion_result.converted
            else:
                new_relative_path = relative_path
        else:  # folder
            conversion_result = self.naming_manager.standardize_foldername(path.name)
            if conversion_result.success:
                new_relative_path = str(path.parent / conversion_result.converted)
                if path.parent != self.workspace_root:
                    new_relative_path = str(path.parent.relative_to(self.workspace_root) / conversion_result.converted)
                else:
                    new_relative_path = conversion_result.converted
            else:
                new_relative_path = relative_path
        
        # 변경이 필요한 경우에만 매핑 엔트리 생성
        if relative_path != new_relative_path:
            return MappingEntry(
                original_path=relative_path,
                new_path=new_relative_path,
                component=conversion_result.component,
                file_type=file_type,
                exists=path.exists(),
                size_bytes=path.stat().st_size if path.is_file() else 0,
                last_modified=datetime.fromtimestamp(path.stat().st_mtime) if path.exists() else None
            )
        
        return None
    
    def rename_watchhamster_files(self, dry_run: bool = False) -> List[FileOperation]:
        """
        WatchHamster v3.0.0 형식으로 일괄 변경
        
        Args:
            dry_run: True면 실제 변경하지 않고 시뮬레이션만 수행
            
        Returns:
            List[FileOperation]: 수행된 작업 목록
        """
        self.logger.info(f"워치햄스터 파일 이름 변경 시작 (dry_run={dry_run})")
        
        watchhamster_entries = [
            entry for entry in self.mapping_table 
            if entry.component == ComponentType.WATCHHAMSTER
        ]
        
        operations = []
        for entry in watchhamster_entries:
            operation = self._perform_rename_operation(entry, dry_run)
            operations.append(operation)
            
        self.logger.info(f"워치햄스터 파일 변경 완료: {len(operations)}개 작업")
        return operations
    
    def rename_POSCO News 250808_files(self, dry_run: bool = False) -> List[FileOperation]:
        """
        POSCO News 250808 관련 파일들을 250808 형식으로 일괄 변경
        
        Args:
            dry_run: True면 실제 변경하지 않고 시뮬레이션만 수행
            
        Returns:
            List[FileOperation]: 수행된 작업 목록
        """
        self.logger.info(f"POSCO News 250808 시작 (dry_run={dry_run})")
        
        POSCO News 250808_entries = [
            entry for entry in self.mapping_table 
            if entry.component == ComponentType.POSCO News 250808
        ]
        
        operations = []
        for entry in POSCO News 250808_entries:
            operation = self._perform_rename_operation(entry, dry_run)
            operations.append(operation)
            
        self.logger.info(f"POSCO News 250808 파일 변경 완료: {len(operations)}개 작업")
        return operations
    
    def _perform_rename_operation(self, entry: MappingEntry, dry_run: bool) -> FileOperation:
        """개별 이름 변경 작업 수행"""
        operation_id = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{len(self.operations_log)}"
        
        source_path = self.workspace_root / entry.original_path
        target_path = self.workspace_root / entry.new_path
        
        operation_type = OperationType.RENAME_FOLDER if entry.file_type == "folder" else OperationType.RENAME_FILE
        
        operation = FileOperation(
            operation_id=operation_id,
            operation_type=operation_type,
            source_path=str(source_path),
            target_path=str(target_path),
            component=entry.component,
            timestamp=datetime.now()
        )
        
        if dry_run:
            operation.success = True
            self.logger.info(f"[DRY RUN] {entry.original_path} → {entry.new_path}")
        else:
            try:
                # 백업 생성
                self._create_backup(source_path, operation_id)
                
                # 대상 디렉토리 생성
                target_path.parent.mkdir(parents=True, exist_ok=True)
                
                # 이름 변경 수행
                source_path.rename(target_path)
                
                operation.success = True
                self.logger.info(f"성공: {entry.original_path} → {entry.new_path}")
                
            except Exception as e:
                operation.success = False
                operation.error_message = str(e)
                self.logger.error(f"실패: {entry.original_path} → {entry.new_path}, 오류: {e}")
        
        self.operations_log.append(operation)
        return operation
    
    def _create_backup(self, source_path: Path, operation_id: str):
        """백업 파일 생성"""
        if not source_path.exists():
            return
            
        backup_path = self.backup_dir / f"{operation_id}_{source_path.name}"
        
        try:
            if source_path.is_file():
                shutil.copy2(source_path, backup_path)
            elif source_path.is_dir():
                shutil.copytree(source_path, backup_path)
                
            self.logger.debug(f"백업 생성: {backup_path}")
        except Exception as e:
            self.logger.warning(f"백업 생성 실패: {source_path}, 오류: {e}")
    
    def rollback_operations(self, operation_ids: Optional[List[str]] = None) -> bool:
        """
        작업 롤백 수행
        
        Args:
            operation_ids: 롤백할 작업 ID 목록 (None이면 모든 작업 롤백)
            
        Returns:
            bool: 롤백 성공 여부
        """
        if operation_ids is None:
            operations_to_rollback = [op for op in self.operations_log if op.success and not op.rollback_completed]
        else:
            operations_to_rollback = [
                op for op in self.operations_log 
                if op.operation_id in operation_ids and op.success and not op.rollback_completed
            ]
        
        self.logger.info(f"롤백 시작: {len(operations_to_rollback)}개 작업")
        
        rollback_success = True
        
        # 역순으로 롤백 (최신 작업부터)
        for operation in reversed(operations_to_rollback):
            try:
                source_path = Path(operation.target_path)
                target_path = Path(operation.source_path)
                
                if source_path.exists():
                    # 대상 디렉토리 생성
                    target_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # 이름 복원
                    source_path.rename(target_path)
                    
                    operation.rollback_completed = True
                    self.logger.info(f"롤백 성공: {operation.target_path} → {operation.source_path}")
                else:
                    self.logger.warning(f"롤백 대상 파일 없음: {operation.target_path}")
                    
            except Exception as e:
                rollback_success = False
                self.logger.error(f"롤백 실패: {operation.operation_id}, 오류: {e}")
        
        # 작업 로그 저장
        self._save_operations_log()
        
        return rollback_success
    
    def _save_mapping_table(self):
        """매핑 테이블 저장"""
        try:
            mapping_data = [asdict(entry) for entry in self.mapping_table]
            # datetime 객체를 문자열로 변환
            for entry_data in mapping_data:
                if entry_data['last_modified']:
                    entry_data['last_modified'] = entry_data['last_modified'].isoformat()
                entry_data['component'] = entry_data['component'].value
            
            with open(self.mapping_table_file, 'w', encoding='utf-8') as f:
                json.dump(mapping_data, f, ensure_ascii=False, indent=2)
                
            self.logger.debug(f"매핑 테이블 저장: {self.mapping_table_file}")
        except Exception as e:
            self.logger.error(f"매핑 테이블 저장 실패: {e}")
    
    def _save_operations_log(self):
        """작업 로그 저장"""
        try:
            operations_data = []
            for operation in self.operations_log:
                op_data = asdict(operation)
                op_data['operation_type'] = op_data['operation_type'].value
                op_data['component'] = op_data['component'].value
                op_data['timestamp'] = op_data['timestamp'].isoformat()
                operations_data.append(op_data)
            
            with open(self.operations_log_file, 'w', encoding='utf-8') as f:
                json.dump(operations_data, f, ensure_ascii=False, indent=2)
                
            self.logger.debug(f"작업 로그 저장: {self.operations_log_file}")
        except Exception as e:
            self.logger.error(f"작업 로그 저장 실패: {e}")
    
    def load_previous_operations(self) -> bool:
        """이전 작업 로그 로드"""
        try:
            if self.operations_log_file.exists():
                with open(self.operations_log_file, 'r', encoding='utf-8') as f:
                    operations_data = json.load(f)
                
                self.operations_log = []
                for op_data in operations_data:
                    operation = FileOperation(
                        operation_id=op_data['operation_id'],
                        operation_type=OperationType(op_data['operation_type']),
                        source_path=op_data['source_path'],
                        target_path=op_data['target_path'],
                        component=ComponentType(op_data['component']),
                        timestamp=datetime.fromisoformat(op_data['timestamp']),
                        success=op_data['success'],
                        error_message=op_data['error_message'],
                        rollback_completed=op_data['rollback_completed']
                    )
                    self.operations_log.append(operation)
                
                self.logger.info(f"이전 작업 로그 로드: {len(self.operations_log)}개 작업")
                return True
        except Exception as e:
            self.logger.error(f"작업 로그 로드 실패: {e}")
        
        return False
    
    def generate_operations_report(self) -> str:
        """작업 보고서 생성"""
        total_operations = len(self.operations_log)
        successful_operations = sum(1 for op in self.operations_log if op.success)
        failed_operations = total_operations - successful_operations
        rollback_completed = sum(1 for op in self.operations_log if op.rollback_completed)
        
        watchhamster_ops = sum(1 for op in self.operations_log if op.component == ComponentType.WATCHHAMSTER)
        POSCO News 250808_ops = sum(1 for op in self.operations_log if op.component == ComponentType.POSCO News 250808)
        
        report = f"""
POSCO 파일 리네이밍 작업 보고서
===============================

작업 통계:
- 총 작업 수: {total_operations}
- 성공한 작업: {successful_operations}
- 실패한 작업: {failed_operations}
- 롤백 완료: {rollback_completed}

컴포넌트별 작업:
- WatchHamster v3.0: {watchhamster_ops}
- POSCO News 250808: {POSCO News 250808_ops}

작업 세부 내역:
"""
        
        for operation in self.operations_log:
            status = "✓" if operation.success else "✗"
            rollback_status = " (롤백됨)" if operation.rollback_completed else ""
            
            report += f"{status} [{operation.operation_type.value}] {operation.source_path} → {operation.target_path}{rollback_status}\n"
            
            if not operation.success and operation.error_message:
                report += f"   오류: {operation.error_message}\n"
        
        return report
    
    def get_mapping_summary(self) -> Dict[str, int]:
        """매핑 테이블 요약 정보"""
        return {
            "total_mappings": len(self.mapping_table),
            "watchhamster_mappings": sum(1 for entry in self.mapping_table if entry.component == ComponentType.WATCHHAMSTER),
            "POSCO News 250808_mappings": sum(1 for entry in self.mapping_table if entry.component == ComponentType.POSCO News 250808),
            "file_mappings": sum(1 for entry in self.mapping_table if entry.file_type == "file"),
            "folder_mappings": sum(1 for entry in self.mapping_table if entry.file_type == "folder"),
        }


def main():
    """메인 실행 함수"""
    print("POSCO 파일 및 폴더명 자동 변경 시스템")
    print("=" * 50)
    
    # 시스템 초기화
    renaming_system = FileRenamingSystem()
    
    # 이전 작업 로그 로드
    renaming_system.load_previous_operations()
    
    # 기존 파일 분석
    print("\n1. 기존 파일 분석 중...")
    mapping_by_component = renaming_system.analyze_existing_files()
    
    # 매핑 요약 출력
    summary = renaming_system.get_mapping_summary()
    print(f"\n매핑 분석 결과:")
    for key, value in summary.items():
        print(f"  {key}: {value}")
    
    # 사용자 선택
    print("\n작업 선택:")
    print("1. WatchHamster v3.0.0)")
    print("2. POSCO News 250808 파일 이름 변경 (250808)")
    print("3. 모든 파일 이름 변경")
    print("4. 드라이 런 (시뮬레이션)")
    print("5. 롤백")
    print("6. 보고서 생성")
    
    choice = input("\n선택하세요 (1-6): ").strip()
    
    if choice == "1":
        operations = renaming_system.rename_watchhamster_files(dry_run=False)
        print(f"\n워치햄스터 파일 변경 완료: {len(operations)}개 작업")
        
    elif choice == "2":
        operations = renaming_system.rename_POSCO News 250808_files(dry_run=False)
        print(f"\nPOSCO News 250808 파일 변경 완료: {len(operations)}개 작업")
        
    elif choice == "3":
        wh_operations = renaming_system.rename_watchhamster_files(dry_run=False)
        pn_operations = renaming_system.rename_POSCO News 250808_files(dry_run=False)
        print(f"\n모든 파일 변경 완료: {len(wh_operations + pn_operations)}개 작업")
        
    elif choice == "4":
        print("\n드라이 런 실행 중...")
        wh_operations = renaming_system.rename_watchhamster_files(dry_run=True)
        pn_operations = renaming_system.rename_POSCO News 250808_files(dry_run=True)
        print(f"\n시뮬레이션 완료: {len(wh_operations + pn_operations)}개 작업 예정")
        
    elif choice == "5":
        success = renaming_system.rollback_operations()
        print(f"\n롤백 {'성공' if success else '실패'}")
        
    elif choice == "6":
        report = renaming_system.generate_operations_report()
        print(report)
        
        # 보고서 파일로 저장
        report_file = renaming_system.workspace_root / "file_renaming_report.txt"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report)
        print(f"\n보고서 저장: {report_file}")
    
    else:
        print("잘못된 선택입니다.")
    
    # 작업 로그 저장
    renaming_system._save_operations_log()


if __name__ == "__main__":
    main()