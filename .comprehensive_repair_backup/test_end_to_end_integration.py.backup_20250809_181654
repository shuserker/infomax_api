#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test End To End Integration
POSCO 시스템 테스트

WatchHamster v3.0 및 POSCO News 250808 호환
Created: 2025-08-08
"""

import os
import sys
import unittest
import subprocess
import time
import signal
import threading
import tempfile
import shutil
import json
import psutil
import concurrent.futures
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch, Mock
from typing import List, Dict, Tuple, Optional

# 테스트를 위해 경로 설정
current_dir = os.path.dirname(os.path.abspath(__file__))
POSCO News 250808_mini')
sys.path.insert(0, posco_mini_dir)


class EndToEndSystemTest(unittest.TestCase):
    """전체 시스템 시작 및 종료 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        self.watchhamster_process = None
        
        # 환경 변수 설정
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        os.environ['TEST_MODE'] = '1'
        
    def tearDown(self):
        """테스트 정리"""
        # 모든 테스트 프로세스 종료
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=5)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        # 워치햄스터 프로세스 종료
        if self.watchhamster_process and self.watchhamster_process.poll() is None:
            try:
                self.watchhamster_process.terminate()
                self.watchhamster_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.watchhamster_process.kill()
                self.watchhamster_process.wait()
        
        # 임시 디렉토리 정리
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_mock_watchhamster_script(self) -> str:
        """Mock 워치햄스터 스크립트 생성"""
        script_path = os.path.join(self.test_dir, 'mock_watchhamster.py')
        
        content = '''#!/usr/bin/env python3
import time
import sys
import signal
import json
import os
from datetime import datetime

class MockWatchHamster v3.00:
    def __init__(self):
        self.running = True
        self.managed_processes = []
        self.v3_0_enabled = True
        
        # 시그널 핸들러 설정
        signal.signal(signal.SIGTERM, self.signal_handler)
        signal.signal(signal.SIGINT, self.signal_handler)
        
    def signal_handler(self, signum, frame):
        print(f"[{datetime.now()}] WatchHamster received signal {signum}")
        self.running = False
        sys.exit(0)
    
    def start_managed_processes(self):
        """관리 대상 프로세스 시작 시뮬레이션"""
        processes = ['POSCO News 250808_monitor', 'integrated_report_scheduler']
        
        for process_name in processes:
            print(f"[{datetime.now()}] Starting {process_name}...")
            # 실제로는 subprocess를 시작하지만, 테스트에서는 시뮬레이션
            self.managed_processes.append({
                'name': process_name,
                'pid': os.getpid() + len(self.managed_processes) + 1,
                'status': 'running',
                'start_time': datetime.now().isoformat()
            })
            time.sleep(0.5)
        
        print(f"[{datetime.now()}] All managed processes started: {len(self.managed_processes)}")
    
    def monitor_processes(self):
        """프로세스 모니터링 루프"""
        counter = 0
        while self.running:
            counter += 1
            
            # 상태 파일 업데이트
            status = {
                'timestamp': datetime.now().isoformat(),
                'counter': counter,
                'v3_0_enabled': self.v3_0_enabled,
                'managed_processes': self.managed_processes,
                'status': 'running'
            }
            
            with open('watchhamster_status.json', 'w') as f:
                json.dump(status, f, indent=2)
            
            print(f"[{datetime.now()}] WatchHamster monitoring cycle {counter}")
            time.sleep(2)
    
    def run(self):
        """메인 실행 루프"""
        print(f"[{datetime.now()}] Mock WatchHamster starting...")
        
        # v2 컴포넌트 초기화 시뮬레이션
        print(f"[{datetime.now()}] Initializing v2 components...")
        time.sleep(1)
        print(f"[{datetime.now()}] v2 components initialized successfully")
        
        # 관리 프로세스 시작
        self.start_managed_processes()
        
        # 모니터링 시작
        self.monitor_processes()

if __name__ == '__main__':
    watchhamster = MockWatchHamster()
    try:
        watchhamster.run()
    except KeyboardInterrupt:
        print(f"[{datetime.now()}] WatchHamster interrupted")
        sys.exit(0)
'''
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_full_system_startup_shutdown(self):
        """전체 시스템 시작 및 종료 테스트"""
        print("🧪 전체 시스템 시작 및 종료 테스트...")
        
        try:
            # Mock 워치햄스터 스크립트 생성
            mock_script = self.create_mock_watchhamster_script()
            
            # 시스템 시작
            print("🚀 시스템 시작 중...")
            self.watchhamster_process = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
            cwd=self.test_dir)
            
            # 시작 대기 및 확인
            time.sleep(5)
            self.assertIsNone(self.watchhamster_process.poll(), "워치햄스터가 예상치 못하게 종료됨")
            
            # 상태 파일 확인
            status_file = os.path.join(self.test_dir, 'watchhamster_status.json')
            self.assertTrue(os.path.exists(status_file), "상태 파일이 생성되지 않음")
            
            with open(status_file, 'r') as f:
                status = json.load(f)
            
            self.assertTrue(status['v3_0_enabled'], "v2가 활성화되지 않음")
            self.assertGreater(len(status['managed_processes']), 0, "관리 프로세스가 시작되지 않음")
            self.assertEqual(status['status'], 'running', "시스템 상태가 running이 아님")
            
            print(f"✅ 시스템 시작 성공 (관리 프로세스: {len(status['managed_processes'])}개)")
            
            # 정상 종료 테스트
            print("🛑 시스템 정상 종료 중...")
            self.watchhamster_process.terminate()
            
            # 종료 대기
            exit_code = self.watchhamster_process.wait(timeout=10)
            self.assertEqual(exit_code, 0, f"비정상 종료 코드: {exit_code}")
            
            print("✅ 시스템 정상 종료 완료")
            
        except Exception as e:
            self.fail(f"전체 시스템 시작/종료 테스트 실패: {e}")
    
    def test_system_restart_scenario(self):
        """시스템 재시작 시나리오 테스트"""
        print("🧪 시스템 재시작 시나리오 테스트...")
        
        try:
            mock_script = self.create_mock_watchhamster_script()
            
            # 첫 번째 시작
            print("🚀 첫 번째 시스템 시작...")
            process1 = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            time.sleep(3)
            pid1 = process1.pid
            self.assertIsNone(process1.poll(), "첫 번째 시스템이 시작되지 않음")
            
            # 첫 번째 종료
            print("🛑 첫 번째 시스템 종료...")
            process1.terminate()
            process1.wait(timeout=5)
            
            # 재시작
            print("🔄 시스템 재시작...")
            time.sleep(1)
            
            process2 = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            time.sleep(3)
            pid2 = process2.pid
            self.assertIsNone(process2.poll(), "재시작된 시스템이 시작되지 않음")
            self.assertNotEqual(pid1, pid2, "재시작된 시스템의 PID가 동일함")
            
            # 정리
            process2.terminate()
            process2.wait(timeout=5)
            
            print("✅ 시스템 재시작 시나리오 테스트 완료")
            
        except Exception as e:
            self.fail(f"시스템 재시작 테스트 실패: {e}")


class StressTest(unittest.TestCase):
    """다중 동시 프로세스 스트레스 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        
    def tearDown(self):
        """테스트 정리"""
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=3)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_load_test_script(self, script_name: str, load_type: str = 'cpu') -> str:
        """부하 테스트 스크립트 생성"""
        script_path = os.path.join(self.test_dir, script_name)
        
        if load_type == 'cpu':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
import math
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] CPU load test {script_name} started")

try:
    counter = 0
    while True:
        # CPU 집약적 작업
        for i in range(10000):
            math.sqrt(i * counter)
        
        counter += 1
        if counter % 100 == 0:
            print(f"[{datetime.now()}] {script_name} CPU cycles: {counter}")
        
        time.sleep(0.01)  # 짧은 휴식
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif load_type == 'memory':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] Memory load test {script_name} started")

try:
    data_chunks = []
    counter = 0
    
    while True:
        # 메모리 할당 (1MB씩)
        chunk = bytearray(1024 * 1024)  # 1MB
        data_chunks.append(chunk)
        
        counter += 1
        if counter % 10 == 0:
            print(f"[{datetime.now()}] {script_name} allocated: {counter}MB")
            
        # 메모리 사용량 제한 (100MB)
        if len(data_chunks) > 100:
            data_chunks.pop(0)
        
        time.sleep(0.1)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif load_type == 'io':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
import os
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] I/O load test {script_name} started")

try:
    counter = 0
    while True:
        # 파일 I/O 작업
        filename = f"test_io_{counter}.tmp"
        
        # 쓰기
        with open(filename, 'w') as f:
            f.write(f"Test data {counter} " * 1000)
        
        # 읽기
        with open(filename, 'r') as f:
            data = f.read()
        
        # 삭제
        os.remove(filename)
        
        counter += 1
        if counter % 50 == 0:
            print(f"[{datetime.now()}] {script_name} I/O operations: {counter}")
        
        time.sleep(0.05)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_concurrent_process_management(self):
        """동시 다중 프로세스 관리 테스트"""
        print("🧪 동시 다중 프로세스 관리 테스트...")
        
        try:
            process_count = 5
            processes = []
            
            # 다양한 유형의 프로세스 시작
            load_types = ['cpu', 'memory', 'io']
            
            for i in range(process_count):
                load_type = load_types[i % len(load_types)]
                script_path = self.create_load_test_script(f'load_test_{i}.py', load_type)
                
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                processes.append({
                    'process': process,
                    'name': f'load_test_{i}',
                    'type': load_type,
                    'start_time': time.time()
                })
                self.test_processes.append(process)
                
                time.sleep(0.5)  # 시작 간격
            
            print(f"🚀 {process_count}개 프로세스 시작 완료")
            
            # 모든 프로세스 실행 확인
            time.sleep(5)
            running_count = 0
            
            for proc_info in processes:
                process = proc_info['process']
                if process.poll() is None:
                    running_count += 1
                    
                    # 리소스 사용량 확인
                    if psutil.pid_exists(process.pid):
                        ps_process = psutil.Process(process.pid)
                        cpu_percent = ps_process.cpu_percent()
                        memory_mb = ps_process.memory_info().rss / 1024 / 1024
                        
                        print(f"✅ {proc_info['name']} ({proc_info['type']}) - "
                              f"CPU: {cpu_percent:.1f}%, MEM: {memory_mb:.1f}MB")
                else:
                    print(f"❌ {proc_info['name']} 종료됨")
            
            self.assertEqual(running_count, process_count, 
                           f"일부 프로세스가 실행되지 않음 ({running_count}/{process_count})")
            
            # 부하 테스트 실행 (10초간)
            print("⚡ 부하 테스트 실행 중 (10초)...")
            time.sleep(10)
            
            # 시스템 리소스 모니터링
            system_cpu = psutil.cpu_percent(interval=1)
            system_memory = psutil.virtual_memory().percent
            
            print(f"📊 시스템 리소스 사용률 - CPU: {system_cpu:.1f}%, MEM: {system_memory:.1f}%")
            
            # 모든 프로세스가 여전히 실행 중인지 확인
            still_running = 0
            for proc_info in processes:
                if proc_info['process'].poll() is None:
                    still_running += 1
            
            self.assertGreaterEqual(still_running, process_count * 0.8,  # 80% 이상 실행 중
                                  f"너무 많은 프로세스가 종료됨 ({still_running}/{process_count})")
            
            # 순차적 종료
            print("🛑 프로세스 순차 종료 중...")
            for proc_info in processes:
                process = proc_info['process']
                if process.poll() is None:
                    process.terminate()
                    try:
                        process.wait(timeout=3)
                        print(f"✅ {proc_info['name']} 정상 종료")
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
                        print(f"⚠️ {proc_info['name']} 강제 종료")
            
            print("✅ 동시 다중 프로세스 관리 테스트 완료")
            
        except Exception as e:
            self.fail(f"동시 프로세스 관리 테스트 실패: {e}")
    
    def test_high_load_stability(self):
        """고부하 안정성 테스트"""
        print("🧪 고부하 안정성 테스트...")
        
        try:
            # 시스템 리소스 기준선 측정
            baseline_cpu = psutil.cpu_percent(interval=1)
            baseline_memory = psutil.virtual_memory().percent
            
            print(f"📊 기준선 - CPU: {baseline_cpu:.1f}%, MEM: {baseline_memory:.1f}%")
            
            # 고부하 프로세스 시작
            high_load_processes = []
            
            for i in range(3):  # CPU 집약적 프로세스
                script_path = self.create_load_test_script(f'high_cpu_{i}.py', 'cpu')
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                high_load_processes.append(process)
                self.test_processes.append(process)
            
            for i in range(2):  # 메모리 집약적 프로세스
                script_path = self.create_load_test_script(f'high_mem_{i}.py', 'memory')
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                high_load_processes.append(process)
                self.test_processes.append(process)
            
            print(f"🚀 고부하 프로세스 {len(high_load_processes)}개 시작")
            
            # 부하 안정화 대기
            time.sleep(5)
            
            # 고부하 상태에서 안정성 확인 (30초간)
            stability_checks = []
            
            for check_round in range(6):  # 5초 간격으로 6번 체크
                time.sleep(5)
                
                # 프로세스 생존 확인
                alive_count = sum(1 for p in high_load_processes if p.poll() is None)
                
                # 시스템 리소스 확인
                current_cpu = psutil.cpu_percent(interval=1)
                current_memory = psutil.virtual_memory().percent
                
                stability_check = {
                    'round': check_round + 1,
                    'alive_processes': alive_count,
                    'total_processes': len(high_load_processes),
                    'cpu_percent': current_cpu,
                    'memory_percent': current_memory,
                    'stable': alive_count >= len(high_load_processes) * 0.8  # 80% 이상 생존
                }
                
                stability_checks.append(stability_check)
                
                print(f"📊 안정성 체크 {check_round + 1}/6 - "
                      f"생존: {alive_count}/{len(high_load_processes)}, "
                      f"CPU: {current_cpu:.1f}%, MEM: {current_memory:.1f}%")
            
            # 안정성 평가
            stable_rounds = sum(1 for check in stability_checks if check['stable'])
            stability_rate = stable_rounds / len(stability_checks) * 100
            
            print(f"📈 안정성 평가: {stable_rounds}/{len(stability_checks)} 라운드 안정 ({stability_rate:.1f}%)")
            
            # 80% 이상의 라운드에서 안정적이어야 함
            self.assertGreaterEqual(stability_rate, 80.0, 
                                  f"시스템이 고부하에서 불안정함 (안정성: {stability_rate:.1f}%)")
            
            print("✅ 고부하 안정성 테스트 완료")
            
        except Exception as e:
            self.fail(f"고부하 안정성 테스트 실패: {e}")


class FailureSimulationTest(unittest.TestCase):
    """다양한 오류 조건 실패 시뮬레이션 테스트"""
    
    def setUp(self):
        """테스트 설정"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        
    def tearDown(self):
        """테스트 정리"""
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=3)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_failure_script(self, script_name: str, failure_type: str) -> str:
        """실패 시뮬레이션 스크립트 생성"""
        script_path = os.path.join(self.test_dir, script_name)
        
        if failure_type == 'immediate_crash':
            content = '''#!/usr/bin/env python3
import sys
from datetime import datetime

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} simulating immediate crash")
sys.exit(1)  # 즉시 크래시
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'delayed_crash':
            content = '''#!/usr/bin/env python3
import time
import sys
from datetime import datetime

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} running normally...")

# 5초 후 크래시
time.sleep(5)
print(f"[{datetime.now()}] {script_name} simulating delayed crash")
sys.exit(1)
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'memory_leak':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] {script_name} starting with memory leak simulation...")

try:
    memory_hog = []
    counter = 0
    
    while True:
        # 메모리 누수 시뮬레이션 (계속 할당, 해제 안함)
        chunk = bytearray(1024 * 1024)  # 1MB
        memory_hog.append(chunk)
        
        counter += 1
        if counter % 10 == 0:
            print(f"[{datetime.now()}] {script_name} leaked: {counter}MB")
        
        time.sleep(0.1)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'infinite_loop':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} entering infinite loop...")

try:
    counter = 0
    while True:
        counter += 1
        # CPU를 많이 사용하는 무한 루프
        for i in range(100000):
            pass
        
        if counter % 1000 == 0:
            print(f"[{datetime.now()}] {script_name} loop iteration: {counter}")
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_immediate_crash_handling(self):
        """즉시 크래시 처리 테스트"""
        print("🧪 즉시 크래시 처리 테스트...")
        
        try:
            # 즉시 크래시하는 스크립트 생성
            crash_script = self.create_failure_script('immediate_crash.py', 'immediate_crash')
            
            # 프로세스 시작
            process = subprocess.Popen([
                sys.executable, crash_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # 크래시 대기
            exit_code = process.wait(timeout=5)
            
            # 크래시 확인
            self.assertNotEqual(exit_code, 0, "프로세스가 정상 종료됨 (크래시 예상)")
            print(f"✅ 즉시 크래시 감지 (exit_code: {exit_code})")
            
            # 복구 시뮬레이션
            print("🔄 자동 복구 시뮬레이션...")
            
            # 정상 스크립트로 재시작
            recovery_script_path = os.path.join(self.test_dir, 'recovery_test.py')
            recovery_content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] Recovery process terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] Recovery process started successfully")

try:
    for i in range(5):
        print(f"[{datetime.now()}] Recovery process running... {i+1}/5")
        time.sleep(1)
    
    print(f"[{datetime.now()}] Recovery process completed")
    
except KeyboardInterrupt:
    sys.exit(0)
'''
            
            with open(recovery_script_path, 'w') as f:
                f.write(recovery_content)
            os.chmod(recovery_script_path, 0o755)
            
            # 복구 프로세스 시작
            recovery_process = subprocess.Popen([
                sys.executable, recovery_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(recovery_process)
            
            # 복구 확인
            time.sleep(3)
            self.assertIsNone(recovery_process.poll(), "복구 프로세스가 시작되지 않음")
            
            # 복구 프로세스 정상 종료 대기
            exit_code = recovery_process.wait(timeout=10)
            self.assertEqual(exit_code, 0, "복구 프로세스가 정상 완료되지 않음")
            
            print("✅ 즉시 크래시 처리 및 복구 테스트 완료")
            
        except Exception as e:
            self.fail(f"즉시 크래시 처리 테스트 실패: {e}")
    
    def test_delayed_failure_detection(self):
        """지연된 실패 감지 테스트"""
        print("🧪 지연된 실패 감지 테스트...")
        
        try:
            # 지연 크래시 스크립트 생성
            delayed_crash_script = self.create_failure_script('delayed_crash.py', 'delayed_crash')
            
            # 프로세스 시작
            process = subprocess.Popen([
                sys.executable, delayed_crash_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # 초기에는 정상 실행 확인
            time.sleep(2)
            self.assertIsNone(process.poll(), "프로세스가 예상보다 일찍 종료됨")
            print("✅ 초기 정상 실행 확인")
            
            # 크래시 대기 (5초 후 크래시 예상)
            exit_code = process.wait(timeout=10)
            
            # 지연된 크래시 확인
            self.assertNotEqual(exit_code, 0, "프로세스가 정상 종료됨 (크래시 예상)")
            print(f"✅ 지연된 크래시 감지 (exit_code: {exit_code})")
            
            print("✅ 지연된 실패 감지 테스트 완료")
            
        except Exception as e:
            self.fail(f"지연된 실패 감지 테스트 실패: {e}")
    
    def test_resource_exhaustion_handling(self):
        """리소스 고갈 처리 테스트"""
        print("🧪 리소스 고갈 처리 테스트...")
        
        try:
            # 메모리 누수 스크립트 생성
            memory_leak_script = self.create_failure_script('memory_leak.py', 'memory_leak')
            
            # 프로세스 시작
            process = subprocess.Popen([
                sys.executable, memory_leak_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # 메모리 사용량 모니터링
            initial_memory = psutil.virtual_memory().percent
            print(f"📊 초기 메모리 사용률: {initial_memory:.1f}%")
            
            # 메모리 누수 진행 모니터링 (최대 20초)
            max_memory_increase = 0
            monitoring_duration = 20
            
            for i in range(monitoring_duration):
                time.sleep(1)
                
                # 프로세스가 여전히 실행 중인지 확인
                if process.poll() is not None:
                    print(f"⚠️ 프로세스가 {i+1}초 후 종료됨")
                    break
                
                # 메모리 사용량 확인
                current_memory = psutil.virtual_memory().percent
                memory_increase = current_memory - initial_memory
                max_memory_increase = max(max_memory_increase, memory_increase)
                
                if i % 5 == 0:  # 5초마다 출력
                    print(f"📊 메모리 사용률: {current_memory:.1f}% (+{memory_increase:.1f}%)")
                
                # 메모리 사용률이 너무 높아지면 프로세스 종료
                if current_memory > 90:  # 90% 이상 사용 시
                    print("⚠️ 메모리 사용률이 위험 수준에 도달, 프로세스 종료")
                    process.terminate()
                    break
            
            # 프로세스 정리
            if process.poll() is None:
                process.terminate()
                process.wait(timeout=5)
            
            print(f"📊 최대 메모리 증가량: {max_memory_increase:.1f}%")
            
            # 메모리 누수가 감지되었는지 확인
            self.assertGreater(max_memory_increase, 1.0, "메모리 누수가 감지되지 않음")
            
            print("✅ 리소스 고갈 처리 테스트 완료")
            
        except Exception as e:
            self.fail(f"리소스 고갈 처리 테스트 실패: {e}")


class ContinuousIntegrationTest(unittest.TestCase):
    """지속적인 검증을 위한 연속 통합 테스트 스위트"""
    
    def setUp(self):
        """테스트 설정"""
        self.test_results = []
        self.start_time = datetime.now()
        
    def tearDown(self):
        """테스트 정리"""
        self.end_time = datetime.now()
        self.generate_ci_report()
    
    def run_test_suite(self, test_class, test_name: str) -> Dict:
        """테스트 스위트 실행"""
        print(f"🧪 {test_name} 실행 중...")
        
        suite = unittest.TestLoader().loadTestsFromTestCase(test_class)
        runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
        
        start_time = time.time()
        result = runner.run(suite)
        end_time = time.time()
        
        test_result = {
            'name': test_name,
            'duration': end_time - start_time,
            'tests_run': result.testsRun,
            'failures': len(result.failures),
            'errors': len(result.errors),
            'success': result.wasSuccessful(),
            'success_rate': ((result.testsRun - len(result.failures) - len(result.errors)) / result.testsRun * 100) if result.testsRun > 0 else 0
        }
        
        status = "✅ 성공" if test_result['success'] else "❌ 실패"
        print(f"{status} {test_name} - "
              f"{test_result['tests_run']}개 테스트, "
              f"성공률: {test_result['success_rate']:.1f}%, "
              f"소요시간: {test_result['duration']:.2f}초")
        
        return test_result
    
    def test_continuous_integration_suite(self):
        """연속 통합 테스트 스위트"""
        print("🚀 연속 통합 테스트 스위트 시작")
        print("=" * 80)
        
        # 개별 테스트 스위트 실행
        test_suites = [
            (EndToEndSystemTest, "전체 시스템 테스트"),
            (StressTest, "스트레스 테스트"),
            (FailureSimulationTest, "실패 시뮬레이션 테스트")
        ]
        
        for test_class, test_name in test_suites:
            try:
                result = self.run_test_suite(test_class, test_name)
                self.test_results.append(result)
            except Exception as e:
                print(f"❌ {test_name} 실행 중 오류: {e}")
                self.test_results.append({
                    'name': test_name,
                    'duration': 0,
                    'tests_run': 0,
                    'failures': 1,
                    'errors': 1,
                    'success': False,
                    'success_rate': 0,
                    'error': str(e)
                })
        
        # 전체 결과 평가
        total_suites = len(self.test_results)
        successful_suites = sum(1 for r in self.test_results if r['success'])
        
        print("\n" + "=" * 80)
        print("📊 연속 통합 테스트 결과 요약")
        print("=" * 80)
        
        for result in self.test_results:
            status = "✅" if result['success'] else "❌"
            print(f"{status} {result['name']}: {result['success_rate']:.1f}% 성공률")
        
        overall_success_rate = (successful_suites / total_suites * 100) if total_suites > 0 else 0
        print(f"\n🎯 전체 성공률: {overall_success_rate:.1f}% ({successful_suites}/{total_suites} 스위트)")
        
        # CI 통과 기준: 80% 이상의 스위트가 성공
        ci_threshold = 80.0
        if overall_success_rate >= ci_threshold:
            print(f"🎉 연속 통합 테스트 통과! (기준: {ci_threshold}%)")
            self.assertTrue(True)
        else:
            print(f"❌ 연속 통합 테스트 실패 (기준: {ci_threshold}%, 실제: {overall_success_rate:.1f}%)")
            self.fail(f"CI 테스트 실패: {overall_success_rate:.1f}% < {ci_threshold}%")
    
    def generate_ci_report(self):
        """CI 보고서 생성"""
        if not hasattr(self, 'end_time'):
            self.end_time = datetime.now()
        
        total_duration = (self.end_time - self.start_time).total_seconds()
        
        report = f"""
# 연속 통합 테스트 보고서

## 실행 정보
- 시작 시간: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}
- 종료 시간: {self.end_time.strftime('%Y-%m-%d %H:%M:%S')}
- 총 소요 시간: {total_duration:.2f}초

## 테스트 결과
"""
        
        for result in self.test_results:
            status = "✅ PASS" if result['success'] else "❌ FAIL"
            report += f"""
### {result['name']} {status}
- 실행된 테스트: {result['tests_run']}개
- 실패: {result['failures']}개
- 오류: {result['errors']}개
- 성공률: {result['success_rate']:.1f}%
- 소요시간: {result['duration']:.2f}초
"""
            
            if 'error' in result:
                report += f"- 오류 메시지: {result['error']}\n"
        
        # CI 보고서 파일 저장
        report_file = os.path.join(current_dir, 'ci_test_report.md')
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report)
            print(f"📄 CI 보고서 저장: {report_file}")
        except Exception as e:
            print(f"⚠️ CI 보고서 저장 실패: {e}")


def main():
    """메인 함수"""
    print("🚀 POSCO WatchHamster v3.0 엔드투엔드 통합 테스트 시작")
    print("=" * 80)
    
    # 테스트 스위트 구성
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # 개별 테스트 클래스 추가
    suite.addTests(loader.loadTestsFromTestCase(EndToEndSystemTest))
    suite.addTests(loader.loadTestsFromTestCase(StressTest))
    suite.addTests(loader.loadTestsFromTestCase(FailureSimulationTest))
    suite.addTests(loader.loadTestsFromTestCase(ContinuousIntegrationTest))
    
    # 테스트 실행
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # 결과 출력
    print("\n" + "=" * 80)
    print("📊 엔드투엔드 통합 테스트 최종 결과")
    print("=" * 80)
    
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    success_count = total_tests - failures - errors
    success_rate = (success_count / total_tests * 100) if total_tests > 0 else 0
    
    print(f"총 테스트: {total_tests}개")
    print(f"성공: {success_count}개")
    print(f"실패: {failures}개")
    print(f"오류: {errors}개")
    print(f"성공률: {success_rate:.1f}%")
    
    if result.wasSuccessful():
        print("\n🎉 모든 엔드투엔드 통합 테스트가 성공했습니다!")
        return 0
    else:
        print("\n❌ 일부 엔드투엔드 통합 테스트가 실패했습니다.")
        return 1


if __name__ == '__main__':
    sys.exit(main())