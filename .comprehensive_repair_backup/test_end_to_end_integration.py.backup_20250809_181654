#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test End To End Integration
POSCO ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

WatchHamster v3.0 ë° POSCO News 250808 í˜¸í™˜
Created: 2025-08-08
"""

import os
import sys
import unittest
import subprocess
import time
import signal
import threading
import tempfile
import shutil
import json
import psutil
import concurrent.futures
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch, Mock
from typing import List, Dict, Tuple, Optional

# í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ê²½ë¡œ ì„¤ì •
current_dir = os.path.dirname(os.path.abspath(__file__))
POSCO News 250808_mini')
sys.path.insert(0, posco_mini_dir)


class EndToEndSystemTest(unittest.TestCase):
    """ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘ ë° ì¢…ë£Œ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        self.watchhamster_process = None
        
        # í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
        os.environ['WATCHHAMSTER_WEBHOOK_URL'] = 'https://test.webhook.url'
        os.environ['BOT_PROFILE_IMAGE_URL'] = 'https://test.image.url'
        os.environ['TEST_MODE'] = '1'
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        # ëª¨ë“  í…ŒìŠ¤íŠ¸ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=5)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        # ì›Œì¹˜í–„ìŠ¤í„° í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        if self.watchhamster_process and self.watchhamster_process.poll() is None:
            try:
                self.watchhamster_process.terminate()
                self.watchhamster_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.watchhamster_process.kill()
                self.watchhamster_process.wait()
        
        # ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_mock_watchhamster_script(self) -> str:
        """Mock ì›Œì¹˜í–„ìŠ¤í„° ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        script_path = os.path.join(self.test_dir, 'mock_watchhamster.py')
        
        content = '''#!/usr/bin/env python3
import time
import sys
import signal
import json
import os
from datetime import datetime

class MockWatchHamster v3.00:
    def __init__(self):
        self.running = True
        self.managed_processes = []
        self.v3_0_enabled = True
        
        # ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •
        signal.signal(signal.SIGTERM, self.signal_handler)
        signal.signal(signal.SIGINT, self.signal_handler)
        
    def signal_handler(self, signum, frame):
        print(f"[{datetime.now()}] WatchHamster received signal {signum}")
        self.running = False
        sys.exit(0)
    
    def start_managed_processes(self):
        """ê´€ë¦¬ ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì‹œë®¬ë ˆì´ì…˜"""
        processes = ['POSCO News 250808_monitor', 'integrated_report_scheduler']
        
        for process_name in processes:
            print(f"[{datetime.now()}] Starting {process_name}...")
            # ì‹¤ì œë¡œëŠ” subprocessë¥¼ ì‹œì‘í•˜ì§€ë§Œ, í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            self.managed_processes.append({
                'name': process_name,
                'pid': os.getpid() + len(self.managed_processes) + 1,
                'status': 'running',
                'start_time': datetime.now().isoformat()
            })
            time.sleep(0.5)
        
        print(f"[{datetime.now()}] All managed processes started: {len(self.managed_processes)}")
    
    def monitor_processes(self):
        """í”„ë¡œì„¸ìŠ¤ ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        counter = 0
        while self.running:
            counter += 1
            
            # ìƒíƒœ íŒŒì¼ ì—…ë°ì´íŠ¸
            status = {
                'timestamp': datetime.now().isoformat(),
                'counter': counter,
                'v3_0_enabled': self.v3_0_enabled,
                'managed_processes': self.managed_processes,
                'status': 'running'
            }
            
            with open('watchhamster_status.json', 'w') as f:
                json.dump(status, f, indent=2)
            
            print(f"[{datetime.now()}] WatchHamster monitoring cycle {counter}")
            time.sleep(2)
    
    def run(self):
        """ë©”ì¸ ì‹¤í–‰ ë£¨í”„"""
        print(f"[{datetime.now()}] Mock WatchHamster starting...")
        
        # v2 ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹œë®¬ë ˆì´ì…˜
        print(f"[{datetime.now()}] Initializing v2 components...")
        time.sleep(1)
        print(f"[{datetime.now()}] v2 components initialized successfully")
        
        # ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        self.start_managed_processes()
        
        # ëª¨ë‹ˆí„°ë§ ì‹œì‘
        self.monitor_processes()

if __name__ == '__main__':
    watchhamster = MockWatchHamster()
    try:
        watchhamster.run()
    except KeyboardInterrupt:
        print(f"[{datetime.now()}] WatchHamster interrupted")
        sys.exit(0)
'''
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_full_system_startup_shutdown(self):
        """ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘ ë° ì¢…ë£Œ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘ ë° ì¢…ë£Œ í…ŒìŠ¤íŠ¸...")
        
        try:
            # Mock ì›Œì¹˜í–„ìŠ¤í„° ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            mock_script = self.create_mock_watchhamster_script()
            
            # ì‹œìŠ¤í…œ ì‹œì‘
            print("ğŸš€ ì‹œìŠ¤í…œ ì‹œì‘ ì¤‘...")
            self.watchhamster_process = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
            cwd=self.test_dir)
            
            # ì‹œì‘ ëŒ€ê¸° ë° í™•ì¸
            time.sleep(5)
            self.assertIsNone(self.watchhamster_process.poll(), "ì›Œì¹˜í–„ìŠ¤í„°ê°€ ì˜ˆìƒì¹˜ ëª»í•˜ê²Œ ì¢…ë£Œë¨")
            
            # ìƒíƒœ íŒŒì¼ í™•ì¸
            status_file = os.path.join(self.test_dir, 'watchhamster_status.json')
            self.assertTrue(os.path.exists(status_file), "ìƒíƒœ íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•ŠìŒ")
            
            with open(status_file, 'r') as f:
                status = json.load(f)
            
            self.assertTrue(status['v3_0_enabled'], "v2ê°€ í™œì„±í™”ë˜ì§€ ì•ŠìŒ")
            self.assertGreater(len(status['managed_processes']), 0, "ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            self.assertEqual(status['status'], 'running', "ì‹œìŠ¤í…œ ìƒíƒœê°€ runningì´ ì•„ë‹˜")
            
            print(f"âœ… ì‹œìŠ¤í…œ ì‹œì‘ ì„±ê³µ (ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤: {len(status['managed_processes'])}ê°œ)")
            
            # ì •ìƒ ì¢…ë£Œ í…ŒìŠ¤íŠ¸
            print("ğŸ›‘ ì‹œìŠ¤í…œ ì •ìƒ ì¢…ë£Œ ì¤‘...")
            self.watchhamster_process.terminate()
            
            # ì¢…ë£Œ ëŒ€ê¸°
            exit_code = self.watchhamster_process.wait(timeout=10)
            self.assertEqual(exit_code, 0, f"ë¹„ì •ìƒ ì¢…ë£Œ ì½”ë“œ: {exit_code}")
            
            print("âœ… ì‹œìŠ¤í…œ ì •ìƒ ì¢…ë£Œ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘/ì¢…ë£Œ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_system_restart_scenario(self):
        """ì‹œìŠ¤í…œ ì¬ì‹œì‘ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ì‹œìŠ¤í…œ ì¬ì‹œì‘ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸...")
        
        try:
            mock_script = self.create_mock_watchhamster_script()
            
            # ì²« ë²ˆì§¸ ì‹œì‘
            print("ğŸš€ ì²« ë²ˆì§¸ ì‹œìŠ¤í…œ ì‹œì‘...")
            process1 = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            time.sleep(3)
            pid1 = process1.pid
            self.assertIsNone(process1.poll(), "ì²« ë²ˆì§¸ ì‹œìŠ¤í…œì´ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            
            # ì²« ë²ˆì§¸ ì¢…ë£Œ
            print("ğŸ›‘ ì²« ë²ˆì§¸ ì‹œìŠ¤í…œ ì¢…ë£Œ...")
            process1.terminate()
            process1.wait(timeout=5)
            
            # ì¬ì‹œì‘
            print("ğŸ”„ ì‹œìŠ¤í…œ ì¬ì‹œì‘...")
            time.sleep(1)
            
            process2 = subprocess.Popen([
                sys.executable, mock_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            time.sleep(3)
            pid2 = process2.pid
            self.assertIsNone(process2.poll(), "ì¬ì‹œì‘ëœ ì‹œìŠ¤í…œì´ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            self.assertNotEqual(pid1, pid2, "ì¬ì‹œì‘ëœ ì‹œìŠ¤í…œì˜ PIDê°€ ë™ì¼í•¨")
            
            # ì •ë¦¬
            process2.terminate()
            process2.wait(timeout=5)
            
            print("âœ… ì‹œìŠ¤í…œ ì¬ì‹œì‘ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ì‹œìŠ¤í…œ ì¬ì‹œì‘ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class StressTest(unittest.TestCase):
    """ë‹¤ì¤‘ ë™ì‹œ í”„ë¡œì„¸ìŠ¤ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=3)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_load_test_script(self, script_name: str, load_type: str = 'cpu') -> str:
        """ë¶€í•˜ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        script_path = os.path.join(self.test_dir, script_name)
        
        if load_type == 'cpu':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
import math
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] CPU load test {script_name} started")

try:
    counter = 0
    while True:
        # CPU ì§‘ì•½ì  ì‘ì—…
        for i in range(10000):
            math.sqrt(i * counter)
        
        counter += 1
        if counter % 100 == 0:
            print(f"[{datetime.now()}] {script_name} CPU cycles: {counter}")
        
        time.sleep(0.01)  # ì§§ì€ íœ´ì‹
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif load_type == 'memory':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] Memory load test {script_name} started")

try:
    data_chunks = []
    counter = 0
    
    while True:
        # ë©”ëª¨ë¦¬ í• ë‹¹ (1MBì”©)
        chunk = bytearray(1024 * 1024)  # 1MB
        data_chunks.append(chunk)
        
        counter += 1
        if counter % 10 == 0:
            print(f"[{datetime.now()}] {script_name} allocated: {counter}MB")
            
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì œí•œ (100MB)
        if len(data_chunks) > 100:
            data_chunks.pop(0)
        
        time.sleep(0.1)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif load_type == 'io':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
import os
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] I/O load test {script_name} started")

try:
    counter = 0
    while True:
        # íŒŒì¼ I/O ì‘ì—…
        filename = f"test_io_{counter}.tmp"
        
        # ì“°ê¸°
        with open(filename, 'w') as f:
            f.write(f"Test data {counter} " * 1000)
        
        # ì½ê¸°
        with open(filename, 'r') as f:
            data = f.read()
        
        # ì‚­ì œ
        os.remove(filename)
        
        counter += 1
        if counter % 50 == 0:
            print(f"[{datetime.now()}] {script_name} I/O operations: {counter}")
        
        time.sleep(0.05)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_concurrent_process_management(self):
        """ë™ì‹œ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ë™ì‹œ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸...")
        
        try:
            process_count = 5
            processes = []
            
            # ë‹¤ì–‘í•œ ìœ í˜•ì˜ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            load_types = ['cpu', 'memory', 'io']
            
            for i in range(process_count):
                load_type = load_types[i % len(load_types)]
                script_path = self.create_load_test_script(f'load_test_{i}.py', load_type)
                
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                processes.append({
                    'process': process,
                    'name': f'load_test_{i}',
                    'type': load_type,
                    'start_time': time.time()
                })
                self.test_processes.append(process)
                
                time.sleep(0.5)  # ì‹œì‘ ê°„ê²©
            
            print(f"ğŸš€ {process_count}ê°œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘ ì™„ë£Œ")
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ í™•ì¸
            time.sleep(5)
            running_count = 0
            
            for proc_info in processes:
                process = proc_info['process']
                if process.poll() is None:
                    running_count += 1
                    
                    # ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ í™•ì¸
                    if psutil.pid_exists(process.pid):
                        ps_process = psutil.Process(process.pid)
                        cpu_percent = ps_process.cpu_percent()
                        memory_mb = ps_process.memory_info().rss / 1024 / 1024
                        
                        print(f"âœ… {proc_info['name']} ({proc_info['type']}) - "
                              f"CPU: {cpu_percent:.1f}%, MEM: {memory_mb:.1f}MB")
                else:
                    print(f"âŒ {proc_info['name']} ì¢…ë£Œë¨")
            
            self.assertEqual(running_count, process_count, 
                           f"ì¼ë¶€ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ ({running_count}/{process_count})")
            
            # ë¶€í•˜ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (10ì´ˆê°„)
            print("âš¡ ë¶€í•˜ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘ (10ì´ˆ)...")
            time.sleep(10)
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
            system_cpu = psutil.cpu_percent(interval=1)
            system_memory = psutil.virtual_memory().percent
            
            print(f"ğŸ“Š ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥  - CPU: {system_cpu:.1f}%, MEM: {system_memory:.1f}%")
            
            # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ê°€ ì—¬ì „íˆ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
            still_running = 0
            for proc_info in processes:
                if proc_info['process'].poll() is None:
                    still_running += 1
            
            self.assertGreaterEqual(still_running, process_count * 0.8,  # 80% ì´ìƒ ì‹¤í–‰ ì¤‘
                                  f"ë„ˆë¬´ ë§ì€ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë¨ ({still_running}/{process_count})")
            
            # ìˆœì°¨ì  ì¢…ë£Œ
            print("ğŸ›‘ í”„ë¡œì„¸ìŠ¤ ìˆœì°¨ ì¢…ë£Œ ì¤‘...")
            for proc_info in processes:
                process = proc_info['process']
                if process.poll() is None:
                    process.terminate()
                    try:
                        process.wait(timeout=3)
                        print(f"âœ… {proc_info['name']} ì •ìƒ ì¢…ë£Œ")
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
                        print(f"âš ï¸ {proc_info['name']} ê°•ì œ ì¢…ë£Œ")
            
            print("âœ… ë™ì‹œ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ë™ì‹œ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_high_load_stability(self):
        """ê³ ë¶€í•˜ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ê³ ë¶€í•˜ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸...")
        
        try:
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ê¸°ì¤€ì„  ì¸¡ì •
            baseline_cpu = psutil.cpu_percent(interval=1)
            baseline_memory = psutil.virtual_memory().percent
            
            print(f"ğŸ“Š ê¸°ì¤€ì„  - CPU: {baseline_cpu:.1f}%, MEM: {baseline_memory:.1f}%")
            
            # ê³ ë¶€í•˜ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            high_load_processes = []
            
            for i in range(3):  # CPU ì§‘ì•½ì  í”„ë¡œì„¸ìŠ¤
                script_path = self.create_load_test_script(f'high_cpu_{i}.py', 'cpu')
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                high_load_processes.append(process)
                self.test_processes.append(process)
            
            for i in range(2):  # ë©”ëª¨ë¦¬ ì§‘ì•½ì  í”„ë¡œì„¸ìŠ¤
                script_path = self.create_load_test_script(f'high_mem_{i}.py', 'memory')
                process = subprocess.Popen([
                    sys.executable, script_path
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                cwd=self.test_dir)
                
                high_load_processes.append(process)
                self.test_processes.append(process)
            
            print(f"ğŸš€ ê³ ë¶€í•˜ í”„ë¡œì„¸ìŠ¤ {len(high_load_processes)}ê°œ ì‹œì‘")
            
            # ë¶€í•˜ ì•ˆì •í™” ëŒ€ê¸°
            time.sleep(5)
            
            # ê³ ë¶€í•˜ ìƒíƒœì—ì„œ ì•ˆì •ì„± í™•ì¸ (30ì´ˆê°„)
            stability_checks = []
            
            for check_round in range(6):  # 5ì´ˆ ê°„ê²©ìœ¼ë¡œ 6ë²ˆ ì²´í¬
                time.sleep(5)
                
                # í”„ë¡œì„¸ìŠ¤ ìƒì¡´ í™•ì¸
                alive_count = sum(1 for p in high_load_processes if p.poll() is None)
                
                # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ í™•ì¸
                current_cpu = psutil.cpu_percent(interval=1)
                current_memory = psutil.virtual_memory().percent
                
                stability_check = {
                    'round': check_round + 1,
                    'alive_processes': alive_count,
                    'total_processes': len(high_load_processes),
                    'cpu_percent': current_cpu,
                    'memory_percent': current_memory,
                    'stable': alive_count >= len(high_load_processes) * 0.8  # 80% ì´ìƒ ìƒì¡´
                }
                
                stability_checks.append(stability_check)
                
                print(f"ğŸ“Š ì•ˆì •ì„± ì²´í¬ {check_round + 1}/6 - "
                      f"ìƒì¡´: {alive_count}/{len(high_load_processes)}, "
                      f"CPU: {current_cpu:.1f}%, MEM: {current_memory:.1f}%")
            
            # ì•ˆì •ì„± í‰ê°€
            stable_rounds = sum(1 for check in stability_checks if check['stable'])
            stability_rate = stable_rounds / len(stability_checks) * 100
            
            print(f"ğŸ“ˆ ì•ˆì •ì„± í‰ê°€: {stable_rounds}/{len(stability_checks)} ë¼ìš´ë“œ ì•ˆì • ({stability_rate:.1f}%)")
            
            # 80% ì´ìƒì˜ ë¼ìš´ë“œì—ì„œ ì•ˆì •ì ì´ì–´ì•¼ í•¨
            self.assertGreaterEqual(stability_rate, 80.0, 
                                  f"ì‹œìŠ¤í…œì´ ê³ ë¶€í•˜ì—ì„œ ë¶ˆì•ˆì •í•¨ (ì•ˆì •ì„±: {stability_rate:.1f}%)")
            
            print("âœ… ê³ ë¶€í•˜ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ê³ ë¶€í•˜ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class FailureSimulationTest(unittest.TestCase):
    """ë‹¤ì–‘í•œ ì˜¤ë¥˜ ì¡°ê±´ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.test_dir = tempfile.mkdtemp()
        self.test_processes = []
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        for process in self.test_processes:
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=3)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                try:
                    process.kill()
                    process.wait()
                except ProcessLookupError:
                    pass
        
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def create_failure_script(self, script_name: str, failure_type: str) -> str:
        """ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        script_path = os.path.join(self.test_dir, script_name)
        
        if failure_type == 'immediate_crash':
            content = '''#!/usr/bin/env python3
import sys
from datetime import datetime

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} simulating immediate crash")
sys.exit(1)  # ì¦‰ì‹œ í¬ë˜ì‹œ
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'delayed_crash':
            content = '''#!/usr/bin/env python3
import time
import sys
from datetime import datetime

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} running normally...")

# 5ì´ˆ í›„ í¬ë˜ì‹œ
time.sleep(5)
print(f"[{datetime.now()}] {script_name} simulating delayed crash")
sys.exit(1)
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'memory_leak':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] {script_name} starting with memory leak simulation...")

try:
    memory_hog = []
    counter = 0
    
    while True:
        # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì‹œë®¬ë ˆì´ì…˜ (ê³„ì† í• ë‹¹, í•´ì œ ì•ˆí•¨)
        chunk = bytearray(1024 * 1024)  # 1MB
        memory_hog.append(chunk)
        
        counter += 1
        if counter % 10 == 0:
            print(f"[{datetime.now()}] {script_name} leaked: {counter}MB")
        
        time.sleep(0.1)
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        elif failure_type == 'infinite_loop':
            content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] {script_name} terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] {script_name} starting...")
print(f"[{datetime.now()}] {script_name} entering infinite loop...")

try:
    counter = 0
    while True:
        counter += 1
        # CPUë¥¼ ë§ì´ ì‚¬ìš©í•˜ëŠ” ë¬´í•œ ë£¨í”„
        for i in range(100000):
            pass
        
        if counter % 1000 == 0:
            print(f"[{datetime.now()}] {script_name} loop iteration: {counter}")
        
except KeyboardInterrupt:
    print(f"[{datetime.now()}] {script_name} interrupted")
    sys.exit(0)
'''.replace('script_name', f'"{script_name}"')
        
        with open(script_path, 'w') as f:
            f.write(content)
        os.chmod(script_path, 0o755)
        
        return script_path
    
    def test_immediate_crash_handling(self):
        """ì¦‰ì‹œ í¬ë˜ì‹œ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ì¦‰ì‹œ í¬ë˜ì‹œ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸...")
        
        try:
            # ì¦‰ì‹œ í¬ë˜ì‹œí•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            crash_script = self.create_failure_script('immediate_crash.py', 'immediate_crash')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, crash_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # í¬ë˜ì‹œ ëŒ€ê¸°
            exit_code = process.wait(timeout=5)
            
            # í¬ë˜ì‹œ í™•ì¸
            self.assertNotEqual(exit_code, 0, "í”„ë¡œì„¸ìŠ¤ê°€ ì •ìƒ ì¢…ë£Œë¨ (í¬ë˜ì‹œ ì˜ˆìƒ)")
            print(f"âœ… ì¦‰ì‹œ í¬ë˜ì‹œ ê°ì§€ (exit_code: {exit_code})")
            
            # ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜
            print("ğŸ”„ ìë™ ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜...")
            
            # ì •ìƒ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì¬ì‹œì‘
            recovery_script_path = os.path.join(self.test_dir, 'recovery_test.py')
            recovery_content = '''#!/usr/bin/env python3
import time
import sys
import signal
from datetime import datetime

def signal_handler(signum, frame):
    print(f"[{datetime.now()}] Recovery process terminated")
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

print(f"[{datetime.now()}] Recovery process started successfully")

try:
    for i in range(5):
        print(f"[{datetime.now()}] Recovery process running... {i+1}/5")
        time.sleep(1)
    
    print(f"[{datetime.now()}] Recovery process completed")
    
except KeyboardInterrupt:
    sys.exit(0)
'''
            
            with open(recovery_script_path, 'w') as f:
                f.write(recovery_content)
            os.chmod(recovery_script_path, 0o755)
            
            # ë³µêµ¬ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            recovery_process = subprocess.Popen([
                sys.executable, recovery_script_path
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(recovery_process)
            
            # ë³µêµ¬ í™•ì¸
            time.sleep(3)
            self.assertIsNone(recovery_process.poll(), "ë³µêµ¬ í”„ë¡œì„¸ìŠ¤ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ")
            
            # ë³µêµ¬ í”„ë¡œì„¸ìŠ¤ ì •ìƒ ì¢…ë£Œ ëŒ€ê¸°
            exit_code = recovery_process.wait(timeout=10)
            self.assertEqual(exit_code, 0, "ë³µêµ¬ í”„ë¡œì„¸ìŠ¤ê°€ ì •ìƒ ì™„ë£Œë˜ì§€ ì•ŠìŒ")
            
            print("âœ… ì¦‰ì‹œ í¬ë˜ì‹œ ì²˜ë¦¬ ë° ë³µêµ¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ì¦‰ì‹œ í¬ë˜ì‹œ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_delayed_failure_detection(self):
        """ì§€ì—°ëœ ì‹¤íŒ¨ ê°ì§€ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ì§€ì—°ëœ ì‹¤íŒ¨ ê°ì§€ í…ŒìŠ¤íŠ¸...")
        
        try:
            # ì§€ì—° í¬ë˜ì‹œ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            delayed_crash_script = self.create_failure_script('delayed_crash.py', 'delayed_crash')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, delayed_crash_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # ì´ˆê¸°ì—ëŠ” ì •ìƒ ì‹¤í–‰ í™•ì¸
            time.sleep(2)
            self.assertIsNone(process.poll(), "í”„ë¡œì„¸ìŠ¤ê°€ ì˜ˆìƒë³´ë‹¤ ì¼ì° ì¢…ë£Œë¨")
            print("âœ… ì´ˆê¸° ì •ìƒ ì‹¤í–‰ í™•ì¸")
            
            # í¬ë˜ì‹œ ëŒ€ê¸° (5ì´ˆ í›„ í¬ë˜ì‹œ ì˜ˆìƒ)
            exit_code = process.wait(timeout=10)
            
            # ì§€ì—°ëœ í¬ë˜ì‹œ í™•ì¸
            self.assertNotEqual(exit_code, 0, "í”„ë¡œì„¸ìŠ¤ê°€ ì •ìƒ ì¢…ë£Œë¨ (í¬ë˜ì‹œ ì˜ˆìƒ)")
            print(f"âœ… ì§€ì—°ëœ í¬ë˜ì‹œ ê°ì§€ (exit_code: {exit_code})")
            
            print("âœ… ì§€ì—°ëœ ì‹¤íŒ¨ ê°ì§€ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ì§€ì—°ëœ ì‹¤íŒ¨ ê°ì§€ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
    
    def test_resource_exhaustion_handling(self):
        """ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        print("ğŸ§ª ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸...")
        
        try:
            # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
            memory_leak_script = self.create_failure_script('memory_leak.py', 'memory_leak')
            
            # í”„ë¡œì„¸ìŠ¤ ì‹œì‘
            process = subprocess.Popen([
                sys.executable, memory_leak_script
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=self.test_dir)
            
            self.test_processes.append(process)
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
            initial_memory = psutil.virtual_memory().percent
            print(f"ğŸ“Š ì´ˆê¸° ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {initial_memory:.1f}%")
            
            # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì§„í–‰ ëª¨ë‹ˆí„°ë§ (ìµœëŒ€ 20ì´ˆ)
            max_memory_increase = 0
            monitoring_duration = 20
            
            for i in range(monitoring_duration):
                time.sleep(1)
                
                # í”„ë¡œì„¸ìŠ¤ê°€ ì—¬ì „íˆ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
                if process.poll() is not None:
                    print(f"âš ï¸ í”„ë¡œì„¸ìŠ¤ê°€ {i+1}ì´ˆ í›„ ì¢…ë£Œë¨")
                    break
                
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
                current_memory = psutil.virtual_memory().percent
                memory_increase = current_memory - initial_memory
                max_memory_increase = max(max_memory_increase, memory_increase)
                
                if i % 5 == 0:  # 5ì´ˆë§ˆë‹¤ ì¶œë ¥
                    print(f"ğŸ“Š ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {current_memory:.1f}% (+{memory_increase:.1f}%)")
                
                # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë„ˆë¬´ ë†’ì•„ì§€ë©´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
                if current_memory > 90:  # 90% ì´ìƒ ì‚¬ìš© ì‹œ
                    print("âš ï¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ìœ„í—˜ ìˆ˜ì¤€ì— ë„ë‹¬, í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ")
                    process.terminate()
                    break
            
            # í”„ë¡œì„¸ìŠ¤ ì •ë¦¬
            if process.poll() is None:
                process.terminate()
                process.wait(timeout=5)
            
            print(f"ğŸ“Š ìµœëŒ€ ë©”ëª¨ë¦¬ ì¦ê°€ëŸ‰: {max_memory_increase:.1f}%")
            
            # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ê°ì§€ë˜ì—ˆëŠ”ì§€ í™•ì¸
            self.assertGreater(max_memory_increase, 1.0, "ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ê°ì§€ë˜ì§€ ì•ŠìŒ")
            
            print("âœ… ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            self.fail(f"ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")


class ContinuousIntegrationTest(unittest.TestCase):
    """ì§€ì†ì ì¸ ê²€ì¦ì„ ìœ„í•œ ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸"""
    
    def setUp(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.test_results = []
        self.start_time = datetime.now()
        
    def tearDown(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        self.end_time = datetime.now()
        self.generate_ci_report()
    
    def run_test_suite(self, test_class, test_name: str) -> Dict:
        """í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ ì‹¤í–‰"""
        print(f"ğŸ§ª {test_name} ì‹¤í–‰ ì¤‘...")
        
        suite = unittest.TestLoader().loadTestsFromTestCase(test_class)
        runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
        
        start_time = time.time()
        result = runner.run(suite)
        end_time = time.time()
        
        test_result = {
            'name': test_name,
            'duration': end_time - start_time,
            'tests_run': result.testsRun,
            'failures': len(result.failures),
            'errors': len(result.errors),
            'success': result.wasSuccessful(),
            'success_rate': ((result.testsRun - len(result.failures) - len(result.errors)) / result.testsRun * 100) if result.testsRun > 0 else 0
        }
        
        status = "âœ… ì„±ê³µ" if test_result['success'] else "âŒ ì‹¤íŒ¨"
        print(f"{status} {test_name} - "
              f"{test_result['tests_run']}ê°œ í…ŒìŠ¤íŠ¸, "
              f"ì„±ê³µë¥ : {test_result['success_rate']:.1f}%, "
              f"ì†Œìš”ì‹œê°„: {test_result['duration']:.2f}ì´ˆ")
        
        return test_result
    
    def test_continuous_integration_suite(self):
        """ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸"""
        print("ğŸš€ ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ ì‹œì‘")
        print("=" * 80)
        
        # ê°œë³„ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ ì‹¤í–‰
        test_suites = [
            (EndToEndSystemTest, "ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"),
            (StressTest, "ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸"),
            (FailureSimulationTest, "ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸")
        ]
        
        for test_class, test_name in test_suites:
            try:
                result = self.run_test_suite(test_class, test_name)
                self.test_results.append(result)
            except Exception as e:
                print(f"âŒ {test_name} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
                self.test_results.append({
                    'name': test_name,
                    'duration': 0,
                    'tests_run': 0,
                    'failures': 1,
                    'errors': 1,
                    'success': False,
                    'success_rate': 0,
                    'error': str(e)
                })
        
        # ì „ì²´ ê²°ê³¼ í‰ê°€
        total_suites = len(self.test_results)
        successful_suites = sum(1 for r in self.test_results if r['success'])
        
        print("\n" + "=" * 80)
        print("ğŸ“Š ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
        print("=" * 80)
        
        for result in self.test_results:
            status = "âœ…" if result['success'] else "âŒ"
            print(f"{status} {result['name']}: {result['success_rate']:.1f}% ì„±ê³µë¥ ")
        
        overall_success_rate = (successful_suites / total_suites * 100) if total_suites > 0 else 0
        print(f"\nğŸ¯ ì „ì²´ ì„±ê³µë¥ : {overall_success_rate:.1f}% ({successful_suites}/{total_suites} ìŠ¤ìœ„íŠ¸)")
        
        # CI í†µê³¼ ê¸°ì¤€: 80% ì´ìƒì˜ ìŠ¤ìœ„íŠ¸ê°€ ì„±ê³µ
        ci_threshold = 80.0
        if overall_success_rate >= ci_threshold:
            print(f"ğŸ‰ ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼! (ê¸°ì¤€: {ci_threshold}%)")
            self.assertTrue(True)
        else:
            print(f"âŒ ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ (ê¸°ì¤€: {ci_threshold}%, ì‹¤ì œ: {overall_success_rate:.1f}%)")
            self.fail(f"CI í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {overall_success_rate:.1f}% < {ci_threshold}%")
    
    def generate_ci_report(self):
        """CI ë³´ê³ ì„œ ìƒì„±"""
        if not hasattr(self, 'end_time'):
            self.end_time = datetime.now()
        
        total_duration = (self.end_time - self.start_time).total_seconds()
        
        report = f"""
# ì—°ì† í†µí•© í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ

## ì‹¤í–‰ ì •ë³´
- ì‹œì‘ ì‹œê°„: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}
- ì¢…ë£Œ ì‹œê°„: {self.end_time.strftime('%Y-%m-%d %H:%M:%S')}
- ì´ ì†Œìš” ì‹œê°„: {total_duration:.2f}ì´ˆ

## í…ŒìŠ¤íŠ¸ ê²°ê³¼
"""
        
        for result in self.test_results:
            status = "âœ… PASS" if result['success'] else "âŒ FAIL"
            report += f"""
### {result['name']} {status}
- ì‹¤í–‰ëœ í…ŒìŠ¤íŠ¸: {result['tests_run']}ê°œ
- ì‹¤íŒ¨: {result['failures']}ê°œ
- ì˜¤ë¥˜: {result['errors']}ê°œ
- ì„±ê³µë¥ : {result['success_rate']:.1f}%
- ì†Œìš”ì‹œê°„: {result['duration']:.2f}ì´ˆ
"""
            
            if 'error' in result:
                report += f"- ì˜¤ë¥˜ ë©”ì‹œì§€: {result['error']}\n"
        
        # CI ë³´ê³ ì„œ íŒŒì¼ ì €ì¥
        report_file = os.path.join(current_dir, 'ci_test_report.md')
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report)
            print(f"ğŸ“„ CI ë³´ê³ ì„œ ì €ì¥: {report_file}")
        except Exception as e:
            print(f"âš ï¸ CI ë³´ê³ ì„œ ì €ì¥ ì‹¤íŒ¨: {e}")


def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ğŸš€ POSCO WatchHamster v3.0 ì—”ë“œíˆ¬ì—”ë“œ í†µí•© í…ŒìŠ¤íŠ¸ ì‹œì‘")
    print("=" * 80)
    
    # í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ êµ¬ì„±
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # ê°œë³„ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ì¶”ê°€
    suite.addTests(loader.loadTestsFromTestCase(EndToEndSystemTest))
    suite.addTests(loader.loadTestsFromTestCase(StressTest))
    suite.addTests(loader.loadTestsFromTestCase(FailureSimulationTest))
    suite.addTests(loader.loadTestsFromTestCase(ContinuousIntegrationTest))
    
    # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # ê²°ê³¼ ì¶œë ¥
    print("\n" + "=" * 80)
    print("ğŸ“Š ì—”ë“œíˆ¬ì—”ë“œ í†µí•© í…ŒìŠ¤íŠ¸ ìµœì¢… ê²°ê³¼")
    print("=" * 80)
    
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    success_count = total_tests - failures - errors
    success_rate = (success_count / total_tests * 100) if total_tests > 0 else 0
    
    print(f"ì´ í…ŒìŠ¤íŠ¸: {total_tests}ê°œ")
    print(f"ì„±ê³µ: {success_count}ê°œ")
    print(f"ì‹¤íŒ¨: {failures}ê°œ")
    print(f"ì˜¤ë¥˜: {errors}ê°œ")
    print(f"ì„±ê³µë¥ : {success_rate:.1f}%")
    
    if result.wasSuccessful():
        print("\nğŸ‰ ëª¨ë“  ì—”ë“œíˆ¬ì—”ë“œ í†µí•© í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!")
        return 0
    else:
        print("\nâŒ ì¼ë¶€ ì—”ë“œíˆ¬ì—”ë“œ í†µí•© í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        return 1


if __name__ == '__main__':
    sys.exit(main())