#!/usr/bin/env python3
"""
Python ë“¤ì—¬ì“°ê¸° ë¬¸ì œ ì „ìš© ìˆ˜ì • ë„êµ¬
Specialized Python Indentation Fixer

ë“¤ì—¬ì“°ê¸° ì˜¤ë¥˜ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³  ìˆ˜ì •í•©ë‹ˆë‹¤.
"""

import posco_news_250808_monitor.log
import system_functionality_verification.py
import verify_folder_reorganization.py
import shutil
from pathlib import Path
from typing import deployment_verification_checklist.md, Dict, Tuple
from datetime import datetime
import logging
import sys
import datetime
import re

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class IndentationFixer:
    """ë“¤ì—¬ì“°ê¸° ë¬¸ì œ ì „ìš© ìˆ˜ì •ê¸°"""
    
    def __init__(self):
        self.workspace_root = Path.cwd()
        self.backup_dir = self.workspace_root / ".indentation_backup"
        self.backup_dir.mkdir(exist_ok=True)
        
        # í•µì‹¬ ëª¨ë“ˆë“¤
        self.core_modules = [
            'naming_convention_manager.py',
            'file_renaming_system.py', 
            'python_naming_standardizer.py',
            'shell_batch_script_standardizer.py',
            'documentation_standardizer.py',
            'config_data_standardizer.py',
            'system_output_message_standardizer.py',
            'folder_structure_reorganizer.py',
            'naming_standardization_verification_system.py'
        ]

    def fix_all_core_modules(self):
        """ëª¨ë“  í•µì‹¬ ëª¨ë“ˆì˜ ë“¤ì—¬ì“°ê¸° ìˆ˜ì •"""
        logger.info("ğŸ”§ í•µì‹¬ ëª¨ë“ˆ ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ì‹œì‘")
        
        results = []
        for module_name in self.core_modules:
            module_path = self.workspace_root / module_name
            if module_path.exists():
                result = self.fix_file_indentation(module_path)
                results.append(result)
                logger.info(f"{'âœ…' if result['success'] else 'âŒ'} {module_name}: {result['message']}")
            else:
                logger.warning(f"âš ï¸ {module_name} íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
        return results

    def fix_file_indentation(self, file_path: Path) -> Dict:
        """ê°œë³„ íŒŒì¼ì˜ ë“¤ì—¬ì“°ê¸° ìˆ˜ì •"""
        try:
            # ë°±ì—… ìƒì„±
            backup_path = self._create_backup(file_path)
            
            # íŒŒì¼ ì½ê¸°
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # ë“¤ì—¬ì“°ê¸° ìˆ˜ì •
            fixed_content = self._fix_indentation(content)
            
            # ìˆ˜ì •ëœ ë‚´ìš© ì €ì¥
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            # êµ¬ë¬¸ ê²€ì¦
            try:
                compile(fixed_content, str(file_path), 'exec')
                return {
                    'success': True,
                    'message': 'ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ë° êµ¬ë¬¸ ê²€ì¦ ì™„ë£Œ',
                    'backup_path': backup_path
                }
            except SyntaxError as e:
                return {
                    'success': False,
                    'message': f'êµ¬ë¬¸ ê²€ì¦ ì‹¤íŒ¨: {e.msg} (ë¼ì¸ {e.lineno})',
                    'backup_path': backup_path
                }
                
        except Exception as e:
            return {
                'success': False,
                'message': f'ìˆ˜ì • ì‹¤íŒ¨: {str(e)}',
                'backup_path': None
            }

    def _fix_indentation(self, content: str) -> str:
        """ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ë¡œì§"""
        lines = content.split('/n')
        fixed_lines = []
        
        # í˜„ì¬ ë“¤ì—¬ì“°ê¸° ë ˆë²¨ ì¶”ì 
        indent_level = 0
        in_multiline_string = False
        string_delimiter = None
        
        for i, line in enumerate(lines):
            original_line = line
            stripped_line = line.strip()
            
            # ë¹ˆ ì¤„ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
            if not stripped_line:
                fixed_lines.append('')
                continue
            
            # ì£¼ì„ë§Œ ìˆëŠ” ì¤„ì€ í˜„ì¬ ë“¤ì—¬ì“°ê¸° ë ˆë²¨ ìœ ì§€
            if stripped_line.startswith('#'):
                fixed_lines.append('    ' * indent_level + stripped_line)
                continue
            
            # ë©€í‹°ë¼ì¸ ë¬¸ìì—´ ì²˜ë¦¬
            if in_multiline_string:
                fixed_lines.append(original_line)
                if string_delimiter in line and line.count(string_delimiter) % 2 == 1:
                    in_multiline_string = False
                    string_delimiter = None
                continue
            
            # ë©€í‹°ë¼ì¸ ë¬¸ìì—´ ì‹œì‘ ê°ì§€
            for delimiter in ['"""', "'''"]:
                if delimiter in stripped_line and stripped_line.count(delimiter) % 2 == 1:
                    in_multiline_string = True
                    string_delimiter = delimiter
                    break
            
            # ë“¤ì—¬ì“°ê¸° ë ˆë²¨ ì¡°ì •
            if self._should_decrease_indent(stripped_line):
                indent_level = max(0, indent_level - 1)
            
            # í˜„ì¬ ë¼ì¸ ë“¤ì—¬ì“°ê¸° ì ìš©
            fixed_line = '    ' * indent_level + stripped_line
            fixed_lines.append(fixed_line)
            
            # ë‹¤ìŒ ë¼ì¸ì„ ìœ„í•œ ë“¤ì—¬ì“°ê¸° ë ˆë²¨ ì¡°ì •
            if self._should_increase_indent(stripped_line):
                indent_level += 1
        
        return '/n'.join(fixed_lines)

    def _should_increase_indent(self, line: str) -> bool:
        """ë“¤ì—¬ì“°ê¸°ë¥¼ ì¦ê°€ì‹œì¼œì•¼ í•˜ëŠ” ë¼ì¸ì¸ì§€ í™•ì¸"""
        line = line.strip()
        
        # ì½œë¡ ìœ¼ë¡œ ëë‚˜ëŠ” êµ¬ë¬¸ë“¤
        if line.endswith(':'):
            # ë‹¨ìˆœí•œ ë”•ì…”ë„ˆë¦¬ë‚˜ ë¦¬ìŠ¤íŠ¸ê°€ ì•„ë‹Œ ê²½ìš°
            if not re.match(r'^["/'].*["/']:/s*', line):  # ë”•ì…”ë„ˆë¦¬ í‚¤ê°€ ì•„ë‹Œ ê²½ìš°
                return True
        
        # íŠ¹ì • í‚¤ì›Œë“œë¡œ ì‹œì‘í•˜ëŠ” êµ¬ë¬¸ë“¤
        keywords = ['def ', 'class ', 'if ', 'elif ', 'else:', 'for ', 'while ', 'try:', 'except', 'finally:', 'with ']
        for keyword in keywords:
            if line.startswith(keyword):
                return True
        
        return False

    def _should_decrease_indent(self, line: str) -> bool:
        """ë“¤ì—¬ì“°ê¸°ë¥¼ ê°ì†Œì‹œì¼œì•¼ í•˜ëŠ” ë¼ì¸ì¸ì§€ í™•ì¸"""
        line = line.strip()
        
        # ë¸”ë¡ì„ ì¢…ë£Œí•˜ëŠ” í‚¤ì›Œë“œë“¤
        decrease_keywords = ['elif ', 'else:', 'except', 'finally:', 'def ', 'class ']
        for keyword in decrease_keywords:
            if line.startswith(keyword):
                return True
        
        return False

    def _create_backup(self, file_path: Path) -> Path:
        """íŒŒì¼ ë°±ì—… ìƒì„±"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{file_path.name}.indent_backup_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        shutil.copy2(file_path, backup_path)
        return backup_path

    def test_imports(self) -> Dict:
# REMOVED:         """ìˆ˜ì • í›„ import í…ŒìŠ¤íŠ¸"""
        logger.info("ğŸ§ª ëª¨ë“ˆ import .naming_backup/scripts/ğŸ§ªPOSCO_í…ŒìŠ¤íŠ¸_ì‹¤í–‰.bat ì¤‘...")
        
        results = {}
        for module_name in self.core_modules:
            module_import_name = module_name.replace('.py', '')
            try:
                # ê¸°ì¡´ ëª¨ë“ˆ ìºì‹œ ì œê±°
                if module_import_name in sys.modules:
                    del sys.modules[module_import_name]
                
                # import ì‹œë„
                __import__(module_import_name)
                results[module_import_name] = {'success': True, 'error': None}
                logger.info(f"âœ… {module_import_name}: Import ì„±ê³µ")
                
            except Exception as e:
                results[module_import_name] = {'success': False, 'error': str(e)}
                logger.error(f"âŒ {module_import_name}: {str(e)}")
        
        return results

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ”§ POSCO í•µì‹¬ ëª¨ë“ˆ ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ì‹œì‘")
    print("=" * 60)
    
    fixer = IndentationFixer()
    
    # 1. ë“¤ì—¬ì“°ê¸° ìˆ˜ì •
    print("/n1ï¸âƒ£ ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ì¤‘...")
    fix_results = fixer.fix_all_core_modules()
    
    successful_fixes = sum(1 for r in fix_results if r['success'])
    print(f"âœ… ì„±ê³µì  ìˆ˜ì •: {successful_fixes}/{len(fix_results)}ê°œ íŒŒì¼")
    
    # 2. Import í…ŒìŠ¤íŠ¸
    print("/n2ï¸âƒ£ ëª¨ë“ˆ import .naming_backup/scripts/ğŸ§ªPOSCO_í…ŒìŠ¤íŠ¸_ì‹¤í–‰.bat ì¤‘...")
    import_results = fixer.test_imports()
    
    successful_imports = sum(1 for r in import_results.values() if r['success'])
    print(f"âœ… ì„±ê³µì  import: {successful_imports}/{len(import_results)}ê°œ ëª¨ë“ˆ")
    
    # 3. ê²°ê³¼ ìš”ì•½
    print("/n" + "=" * 60)
    print("ğŸ‰ í•µì‹¬ ëª¨ë“ˆ ë“¤ì—¬ì“°ê¸° ìˆ˜ì • ì™„ë£Œ!")
    print("=" * 60)
    
    print("/nğŸ“Š ìˆ˜ì • ê²°ê³¼:")
    for result in fix_results:
        if 'backup_path' in result and result['backup_path']:
            module_name = result['backup_path'].name.split('.')[0]
            status = "âœ…" if result['success'] else "âŒ"
            print(f"  {status} {module_name}: {result['message']}")
    
    print("/nğŸ“Š Import ê²°ê³¼:")
    for module_name, result in import_results.items():
        status = "âœ…" if result['success'] else "âŒ"
        message = "ì„±ê³µ" if result['success'] else result['error'][:50] + "..."
        print(f"  {status} {module_name}: {message}")
    
    if successful_imports == len(import_results):
        print("/nğŸŠ ëª¨ë“  í•µì‹¬ ëª¨ë“ˆì´ ì„±ê³µì ìœ¼ë¡œ importë©ë‹ˆë‹¤!")
        return 0
    else:
# REMOVED:         print(f"/nâš ï¸ {len(import_results) - successful_imports}ê°œ ëª¨ë“ˆì´ ì—¬ì „íˆ import ì‹¤íŒ¨í•©ë‹ˆë‹¤.")
        return 1

if __name__ == "__main__":
    sys.exit(main())