#!/usr/bin/env python3
"""
Enhanced POSCO ì‹œìŠ¤í…œ ìë™í™”ëœ ìˆ˜ë¦¬ ë„êµ¬
Enhanced Automated Repair System for POSCO System

ê¸°ì¡´ ì‹œìŠ¤í…œì˜ ë¬¸ì œì ì„ ê°œì„ í•œ í–¥ìƒëœ ìë™ ìˆ˜ë¦¬ ë„êµ¬ì…ë‹ˆë‹¤.
- ë” ì•ˆì „í•œ ë°±ì—… ì‹œìŠ¤í…œ
- í–¥ìƒëœ êµ¬ë¬¸ ì˜¤ë¥˜ ê°ì§€ ë° ìˆ˜ì •
- ê°œì„ ëœ Import ë¬¸ì œ í•´ê²°
- ê°•í™”ëœ íŒŒì¼ ì°¸ì¡° ë³µêµ¬
"""

import ast
import os
import re
import sys
import json
import shutil
import hashlib
import importlib
import traceback
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import subprocess
import tempfile
import datetime
import pathlib


@dataclass
class RepairTask:
    """ìˆ˜ë¦¬ ì‘ì—…ì„ ë‚˜íƒ€ë‚´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    task_id: str
    file_path: str
    task_type: str  # 'syntax', 'import', 'reference'
    description: str
    priority: int  # 1=high, 2=medium, 3=low
    estimated_time: int  # seconds
    dependencies: List[str] = None  # ì˜ì¡´í•˜ëŠ” ë‹¤ë¥¸ task_idë“¤


@dataclass
class RepairResult:
    """ìˆ˜ë¦¬ ê²°ê³¼ë¥¼ ì €ì¥í•˜ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    task_id: str
    file_path: str
    success: bool
    changes_made: List[str]
    backup_created: bool
    execution_time: float
    error_message: Optional[str] = None


class SafeBackupManager:
    """ì•ˆì „í•œ ë°±ì—… ê´€ë¦¬ì"""
    
    def __init__(self, backup_dir: str = ".enhanced_repair_backups"):
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(exist_ok=True)
        self.backup_registry = {}
        self.max_backups_per_file = 5
    
    def create_file_backup(self, file_path: Path) -> str:
        """ê°œë³„ íŒŒì¼ì˜ ì•ˆì „í•œ ë°±ì—… ìƒì„±"""
        try:
            if not file_path.exists():
                return ""
            
            # íŒŒì¼ í¬ê¸° ì œí•œ (10MB)
            if file_path.stat().st_size > 10 * 1024 * 1024:
                print(f"íŒŒì¼ì´ ë„ˆë¬´ í¼, ë°±ì—… ê±´ë„ˆë›°ê¸°: {file_path}")
                return ""
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_name = str(file_path).replace("/", "_").replace("\\", "_")
            backup_name = f"{safe_name}.backup_{timestamp}"
            backup_path = self.backup_dir / backup_name
            
            # ë°±ì—… ê²½ë¡œ ê¸¸ì´ ì œí•œ
            if len(str(backup_path)) > 200:
                backup_name = f"file_{hashlib.md5(str(file_path).encode()).hexdigest()[:8]}.backup_{timestamp}"
                backup_path = self.backup_dir / backup_name
            
            shutil.copy2(file_path, backup_path)
            
            # ë°±ì—… ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— ë“±ë¡
            file_key = str(file_path)
            if file_key not in self.backup_registry:
                self.backup_registry[file_key] = []
            
            self.backup_registry[file_key].append({
                "backup_path": str(backup_path),
                "timestamp": timestamp,
                "file_hash": self._calculate_hash(file_path)
            })
            
            # ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬
            self._cleanup_old_backups(file_key)
            
            return str(backup_path)
        except Exception as e:
            print(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨ {file_path}: {e}")
            return ""
    
    def restore_file(self, file_path: str) -> bool:
        """íŒŒì¼ì„ ìµœì‹  ë°±ì—…ì—ì„œ ë³µì›"""
        try:
            if file_path not in self.backup_registry:
                return False
            
            backups = self.backup_registry[file_path]
            if not backups:
                return False
            
            latest_backup = backups[-1]
            backup_path = Path(latest_backup["backup_path"])
            
            if backup_path.exists():
                shutil.copy2(backup_path, file_path)
                return True
            
            return False
        except Exception as e:
            print(f"íŒŒì¼ ë³µì› ì‹¤íŒ¨ {file_path}: {e}")
            return False
    
    def _calculate_hash(self, file_path: Path) -> str:
        """íŒŒì¼ í•´ì‹œ ê³„ì‚°"""
        try:
            with open(file_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except:
            return ""
    
    def _cleanup_old_backups(self, file_key: str):
        """ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬"""
        if file_key not in self.backup_registry:
            return
        
        backups = self.backup_registry[file_key]
        if len(backups) > self.max_backups_per_file:
            # ì˜¤ë˜ëœ ë°±ì—… ì‚­ì œ
            old_backups = backups[:-self.max_backups_per_file]
            for backup in old_backups:
                try:
                    Path(backup["backup_path"]).unlink(missing_ok=True)
                except:
                    pass
            
            # ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì—…ë°ì´íŠ¸
            self.backup_registry[file_key] = backups[-self.max_backups_per_file:]


class EnhancedSyntaxRepairer:
    """í–¥ìƒëœ êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì •ê¸°"""
    
    def __init__(self, backup_manager: SafeBackupManager):
        self.backup_manager = backup_manager
        self.common_fixes = {
            # f-string ì˜¤ë¥˜ íŒ¨í„´
            r'f"([^"]*\{[^}]*\}[^}]*)\}"': r'f"\1"',
            r"f'([^']*\{[^}]*\}[^}]*)\}'": r"f'\1'",
            
            # ì¼ë°˜ì ì¸ ë„¤ì´ë° ìˆ˜ì •
            r'\bPOSCO News 250808\b': 'POSCO_NEWS_250808',
            r'\bWatchHamster v3\.0\b': 'WATCHHAMSTER_V30',
            r'\bposco news\b': 'posco_news',
        }
    
    def repair_file_syntax(self, file_path: Path) -> RepairResult:
        """íŒŒì¼ì˜ êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì •"""
        task_id = f"syntax_{file_path.name}_{datetime.now().strftime('%H%M%S')}"
        start_time = datetime.now()
        changes_made = []
        
        try:
            # ë°±ì—… ìƒì„±
            backup_path = self.backup_manager.create_file_backup(file_path)
            backup_created = bool(backup_path)
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            content = original_content
            
            # 1. ê¸°ë³¸ êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì •
            content, basic_changes = self._fix_basic_syntax_errors(content)
            changes_made.extend(basic_changes)
            
            # 2. ë“¤ì—¬ì“°ê¸° ìˆ˜ì •
            content, indent_changes = self._fix_indentation(content)
            changes_made.extend(indent_changes)
            
            # 3. ì¼ë°˜ì ì¸ íŒ¨í„´ ìˆ˜ì •
            content, pattern_changes = self._fix_common_patterns(content)
            changes_made.extend(pattern_changes)
            
            # 4. AST ê²€ì¦
            try:
                ast.parse(content)
                syntax_valid = True
            except SyntaxError as e:
                syntax_valid = False
                changes_made.append(f"êµ¬ë¬¸ ê²€ì¦ ì‹¤íŒ¨: {e}")
            
            # ë³€ê²½ì‚¬í•­ì´ ìˆê³  êµ¬ë¬¸ì´ ìœ íš¨í•˜ë©´ ì €ì¥
            if content != original_content and syntax_valid:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            elif content != original_content and not syntax_valid:
                # êµ¬ë¬¸ì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì›ë³¸ìœ¼ë¡œ ë³µì›
                changes_made.append("êµ¬ë¬¸ ì˜¤ë¥˜ë¡œ ì¸í•´ ë³€ê²½ì‚¬í•­ ë¡¤ë°±")
                content = original_content
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=len(changes_made) > 0 and syntax_valid,
                changes_made=changes_made,
                backup_created=backup_created,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=False,
                changes_made=[],
                backup_created=False,
                execution_time=execution_time,
                error_message=str(e)
            )
    
    def _fix_basic_syntax_errors(self, content: str) -> Tuple[str, List[str]]:
        """ê¸°ë³¸ êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì •"""
        changes = []
        
        # ì¼ë°˜ì ì¸ íŒ¨í„´ ìˆ˜ì •
        for pattern, replacement in self.common_fixes.items():
            if re.search(pattern, content):
                content = re.sub(pattern, replacement, content)
                changes.append(f"íŒ¨í„´ ìˆ˜ì •: {pattern} -> {replacement}")
        
        return content, changes
    
    def _fix_indentation(self, content: str) -> Tuple[str, List[str]]:
        """ë“¤ì—¬ì“°ê¸° ìˆ˜ì •"""
        changes = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            if line.strip():  # ë¹ˆ ë¼ì¸ì´ ì•„ë‹Œ ê²½ìš°
                # íƒ­ì„ 4ì¹¸ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
                if '\t' in line:
                    lines[i] = line.replace('\t', '    ')
                    changes.append(f"ë¼ì¸ {i+1}: íƒ­ì„ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜")
        
        return '\n'.join(lines), changes
    
    def _fix_common_patterns(self, content: str) -> Tuple[str, List[str]]:
        """ì¼ë°˜ì ì¸ ì˜¤ë¥˜ íŒ¨í„´ ìˆ˜ì •"""
        changes = []
        
        # with_open ì˜¤ë¥˜ ìˆ˜ì •
        if 'with_open(' in content:
            content = content.replace('with_open(', 'with open(')
            changes.append("with_openì„ with openìœ¼ë¡œ ìˆ˜ì •")
        
        # ì˜ëª»ëœ ì–¸ë”ìŠ¤ì½”ì–´ íŒ¨í„´ ìˆ˜ì •
        content = re.sub(r',_\'', ', \'', content)
        content = re.sub(r'_encoding\s*=', ' encoding=', content)
        if ',_\'' in content or '_encoding' in content:
            changes.append("ì˜ëª»ëœ ì–¸ë”ìŠ¤ì½”ì–´ íŒ¨í„´ ìˆ˜ì •")
        
        # ì˜ëª»ëœ ì¤„ë°”ê¿ˆ ë¬¸ì ìˆ˜ì •
        if '/n' in content:
            content = content.replace('/n', '\\n')
            changes.append("ì˜ëª»ëœ ì¤„ë°”ê¿ˆ ë¬¸ì ìˆ˜ì •")
        
        return content, changes


class EnhancedImportRepairer:
    """í–¥ìƒëœ Import ë¬¸ì œ í•´ê²°ê¸°"""
    
    def __init__(self, backup_manager: SafeBackupManager):
        self.backup_manager = backup_manager
        self.import_mappings = {
            'Posco_News_mini': 'POSCO_News_250808',
            'POSCO_WatchHamster_v3': 'WatchHamster_v3.0',
            'posco_news_mini': 'posco_news_250808',
        }
    
    def repair_file_imports(self, file_path: Path) -> RepairResult:
        """íŒŒì¼ì˜ Import ë¬¸ì œ ìˆ˜ì •"""
        task_id = f"import_{file_path.name}_{datetime.now().strftime('%H%M%S')}"
        start_time = datetime.now()
        changes_made = []
        
        try:
            # ë°±ì—… ìƒì„±
            backup_path = self.backup_manager.create_file_backup(file_path)
            backup_created = bool(backup_path)
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            content = original_content
            
            # Import ê²½ë¡œ ìˆ˜ì •
            content, import_changes = self._fix_import_paths(content)
            changes_made.extend(import_changes)
            
            # í•„ìš”í•œ import ì¶”ê°€
            content, missing_changes = self._add_missing_imports(content)
            changes_made.extend(missing_changes)
            
            # ë³€ê²½ì‚¬í•­ì´ ìˆìœ¼ë©´ ì €ì¥
            if content != original_content:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=len(changes_made) > 0,
                changes_made=changes_made,
                backup_created=backup_created,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=False,
                changes_made=[],
                backup_created=False,
                execution_time=execution_time,
                error_message=str(e)
            )
    
    def _fix_import_paths(self, content: str) -> Tuple[str, List[str]]:
        """Import ê²½ë¡œ ìˆ˜ì •"""
        changes = []
        
        for old_path, new_path in self.import_mappings.items():
            patterns = [
                f'from {old_path}',
                f'import {old_path}',
            ]
            
            for pattern in patterns:
                if pattern in content:
                    new_pattern = pattern.replace(old_path, new_path)
                    content = content.replace(pattern, new_pattern)
                    changes.append(f"Import ê²½ë¡œ ìˆ˜ì •: {pattern} -> {new_pattern}")
        
        return content, changes
    
    def _add_missing_imports(self, content: str) -> Tuple[str, List[str]]:
        """í•„ìš”í•œ import ì¶”ê°€"""
        changes = []
        lines = content.split('\n')
        
        # ìì£¼ ì‚¬ìš©ë˜ëŠ” ëª¨ë“ˆ íŒ¨í„´ í™•ì¸
        common_patterns = {
            'os': ['os.path', 'os.environ', 'os.getcwd'],
            'sys': ['sys.path', 'sys.argv', 'sys.exit'],
            'json': ['json.load', 'json.dump', 'json.loads'],
            'datetime': ['datetime.now', 'datetime.strftime'],
            'pathlib': ['Path('],
            're': ['re.search', 're.match', 're.sub', 're.findall'],
        }
        
        existing_imports = set()
        import_section_end = 0
        
        # ê¸°ì¡´ import í™•ì¸
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped.startswith(('import ', 'from ')):
                existing_imports.add(stripped)
                import_section_end = i + 1
        
        # í•„ìš”í•œ import ì°¾ê¸°
        imports_to_add = []
        for module, patterns in common_patterns.items():
            for pattern in patterns:
                if pattern in content:
                    import_stmt = f'import {module}'
                    if import_stmt not in existing_imports and import_stmt not in imports_to_add:
                        imports_to_add.append(import_stmt)
                        changes.append(f"í•„ìš”í•œ import ì¶”ê°€: {module}")
                        break
        
        # import ì¶”ê°€
        if imports_to_add:
            for imp in imports_to_add:
                lines.insert(import_section_end, imp)
                import_section_end += 1
        
        return '\n'.join(lines), changes


class EnhancedReferenceRepairer:
    """í–¥ìƒëœ íŒŒì¼ ì°¸ì¡° ë³µêµ¬ê¸°"""
    
    def __init__(self, backup_manager: SafeBackupManager):
        self.backup_manager = backup_manager
        self.reference_mappings = {
            'Posco_News_mini.py': 'POSCO_News_250808.py',
            'POSCO_WatchHamster_v3': 'WatchHamster_v3.0',
            'posco_news_mini': 'posco_news_250808',
        }
    
    def repair_file_references(self, file_path: Path) -> RepairResult:
        """íŒŒì¼ì˜ ì°¸ì¡° ë¬¸ì œ ìˆ˜ì •"""
        task_id = f"reference_{file_path.name}_{datetime.now().strftime('%H%M%S')}"
        start_time = datetime.now()
        changes_made = []
        
        try:
            # ë°±ì—… ìƒì„±
            backup_path = self.backup_manager.create_file_backup(file_path)
            backup_created = bool(backup_path)
            
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            content = original_content
            
            # íŒŒì¼ ì°¸ì¡° ìˆ˜ì •
            content, ref_changes = self._fix_file_references(content)
            changes_made.extend(ref_changes)
            
            # ê²½ë¡œ êµ¬ë¶„ì í‘œì¤€í™”
            content, path_changes = self._standardize_path_separators(content)
            changes_made.extend(path_changes)
            
            # ë³€ê²½ì‚¬í•­ì´ ìˆìœ¼ë©´ ì €ì¥
            if content != original_content:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=len(changes_made) > 0,
                changes_made=changes_made,
                backup_created=backup_created,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            return RepairResult(
                task_id=task_id,
                file_path=str(file_path),
                success=False,
                changes_made=[],
                backup_created=False,
                execution_time=execution_time,
                error_message=str(e)
            )
    
    def _fix_file_references(self, content: str) -> Tuple[str, List[str]]:
        """íŒŒì¼ ì°¸ì¡° ìˆ˜ì •"""
        changes = []
        
        for old_ref, new_ref in self.reference_mappings.items():
            if old_ref in content:
                content = content.replace(old_ref, new_ref)
                changes.append(f"íŒŒì¼ ì°¸ì¡° ìˆ˜ì •: {old_ref} -> {new_ref}")
        
        return content, changes
    
    def _standardize_path_separators(self, content: str) -> Tuple[str, List[str]]:
        """ê²½ë¡œ êµ¬ë¶„ì í‘œì¤€í™”"""
        changes = []
        
        # Windows ê²½ë¡œë¥¼ Unix ìŠ¤íƒ€ì¼ë¡œ ë³€ê²½
        if '\\' in content:
            # ë¬¸ìì—´ ë‚´ì˜ ë°±ìŠ¬ë˜ì‹œë§Œ ë³€ê²½ (ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ì œì™¸)
            content = re.sub(r'\\(?![nrt"\'\\])', '/', content)
            changes.append("ê²½ë¡œ êµ¬ë¶„ì í‘œì¤€í™” (\\ë¥¼ /ë¡œ ë³€ê²½)")
        
        return content, changes


class EnhancedAutomatedRepairSystem:
    """í–¥ìƒëœ í†µí•© ìë™í™” ìˆ˜ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.backup_manager = SafeBackupManager()
        self.syntax_repairer = EnhancedSyntaxRepairer(self.backup_manager)
        self.import_repairer = EnhancedImportRepairer(self.backup_manager)
        self.reference_repairer = EnhancedReferenceRepairer(self.backup_manager)
        
        self.repair_tasks = []
        self.repair_results = []
    
    def analyze_system(self) -> Dict[str, Any]:
        """ì‹œìŠ¤í…œ ë¶„ì„ ë° ìˆ˜ë¦¬ ì‘ì—… ê³„íš ìˆ˜ë¦½"""
        print("ğŸ” ì‹œìŠ¤í…œ ë¶„ì„ ì‹œì‘...")
        
        analysis_results = {
            "timestamp": datetime.now().isoformat(),
            "total_files": 0,
            "python_files": 0,
            "files_with_issues": 0,
            "estimated_repair_time": 0,
            "repair_tasks": []
        }
        
        # Python íŒŒì¼ ë¶„ì„
        python_files = list(Path(".").glob("**/*.py"))
        # ë°±ì—… ë””ë ‰í† ë¦¬ ì œì™¸
        python_files = [f for f in python_files if not any(
            exclude in str(f) for exclude in [
                ".git", "__pycache__", ".backup", "backup_", 
                "full_system_backup", ".enhanced_repair_backups"
            ]
        )]
        
        analysis_results["total_files"] = len(python_files)
        analysis_results["python_files"] = len(python_files)
        
        # ê° íŒŒì¼ ë¶„ì„
        for py_file in python_files[:50]:  # ì²˜ìŒ 50ê°œ íŒŒì¼ë§Œ ë¶„ì„
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                file_issues = []
                
                # êµ¬ë¬¸ ì˜¤ë¥˜ í™•ì¸
                try:
                    ast.parse(content)
                except SyntaxError:
                    file_issues.append("syntax_error")
                
                # ì¼ë°˜ì ì¸ ë¬¸ì œ íŒ¨í„´ í™•ì¸
                if 'with_open(' in content:
                    file_issues.append("with_open_error")
                if 'Posco_News_mini' in content:
                    file_issues.append("legacy_import")
                if '\\' in content and not content.count('\\n'):
                    file_issues.append("path_separator")
                
                if file_issues:
                    analysis_results["files_with_issues"] += 1
                    
                    # ìˆ˜ë¦¬ ì‘ì—… ìƒì„±
                    for issue in file_issues:
                        task = RepairTask(
                            task_id=f"{issue}_{py_file.name}_{len(self.repair_tasks)}",
                            file_path=str(py_file),
                            task_type=self._get_task_type(issue),
                            description=f"{issue} in {py_file.name}",
                            priority=self._get_priority(issue),
                            estimated_time=self._estimate_time(issue)
                        )
                        self.repair_tasks.append(task)
                        analysis_results["repair_tasks"].append(asdict(task))
            
            except Exception as e:
                print(f"íŒŒì¼ ë¶„ì„ ì¤‘ ì˜¤ë¥˜: {py_file} - {e}")
                continue
        
        analysis_results["estimated_repair_time"] = sum(
            task.estimated_time for task in self.repair_tasks
        )
        
        print(f"âœ… ë¶„ì„ ì™„ë£Œ: {analysis_results['files_with_issues']}ê°œ íŒŒì¼ì—ì„œ {len(self.repair_tasks)}ê°œ ì‘ì—… ë°œê²¬")
        return analysis_results
    
    def execute_repairs(self, max_files: int = 20) -> Dict[str, Any]:
        """ìˆ˜ë¦¬ ì‘ì—… ì‹¤í–‰"""
        print(f"ğŸ”§ ìˆ˜ë¦¬ ì‘ì—… ì‹¤í–‰ ì‹œì‘ (ìµœëŒ€ {max_files}ê°œ íŒŒì¼)...")
        
        execution_results = {
            "timestamp": datetime.now().isoformat(),
            "total_tasks": len(self.repair_tasks),
            "executed_tasks": 0,
            "successful_tasks": 0,
            "failed_tasks": 0,
            "total_execution_time": 0,
            "results": []
        }
        
        # ìš°ì„ ìˆœìœ„ë³„ë¡œ ì •ë ¬
        sorted_tasks = sorted(self.repair_tasks, key=lambda x: x.priority)
        
        # íŒŒì¼ë³„ë¡œ ê·¸ë£¹í™”
        files_processed = set()
        
        for task in sorted_tasks:
            if len(files_processed) >= max_files:
                break
            
            if task.file_path in files_processed:
                continue
            
            files_processed.add(task.file_path)
            file_path = Path(task.file_path)
            
            if not file_path.exists():
                continue
            
            print(f"  ğŸ”§ ìˆ˜ë¦¬ ì¤‘: {file_path.name}")
            
            # íŒŒì¼ë³„ë¡œ ëª¨ë“  ìˆ˜ë¦¬ ì‘ì—… ì‹¤í–‰
            file_results = []
            
            # êµ¬ë¬¸ ìˆ˜ë¦¬
            syntax_result = self.syntax_repairer.repair_file_syntax(file_path)
            file_results.append(syntax_result)
            
            # Import ìˆ˜ë¦¬
            import_result = self.import_repairer.repair_file_imports(file_path)
            file_results.append(import_result)
            
            # ì°¸ì¡° ìˆ˜ë¦¬
            reference_result = self.reference_repairer.repair_file_references(file_path)
            file_results.append(reference_result)
            
            # ê²°ê³¼ ì§‘ê³„
            for result in file_results:
                execution_results["executed_tasks"] += 1
                if result.success:
                    execution_results["successful_tasks"] += 1
                else:
                    execution_results["failed_tasks"] += 1
                
                execution_results["total_execution_time"] += result.execution_time
                execution_results["results"].append(asdict(result))
                self.repair_results.append(result)
        
        print(f"âœ… ìˆ˜ë¦¬ ì™„ë£Œ: {execution_results['successful_tasks']}/{execution_results['executed_tasks']} ì„±ê³µ")
        return execution_results
    
    def verify_repairs(self) -> Dict[str, Any]:
        """ìˆ˜ë¦¬ ê²°ê³¼ ê²€ì¦"""
        print("ğŸ” ìˆ˜ë¦¬ ê²°ê³¼ ê²€ì¦ ì¤‘...")
        
        verification_results = {
            "timestamp": datetime.now().isoformat(),
            "files_checked": 0,
            "syntax_errors": 0,
            "import_errors": 0,
            "overall_success_rate": 0.0,
            "details": []
        }
        
        # ìˆ˜ë¦¬ëœ íŒŒì¼ë“¤ ê²€ì¦
        repaired_files = set(result.file_path for result in self.repair_results if result.success)
        
        for file_path_str in repaired_files:
            file_path = Path(file_path_str)
            if not file_path.exists():
                continue
            
            verification_results["files_checked"] += 1
            file_details = {"file": str(file_path), "issues": []}
            
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # êµ¬ë¬¸ ê²€ì¦
                try:
                    ast.parse(content)
                except SyntaxError as e:
                    verification_results["syntax_errors"] += 1
                    file_details["issues"].append(f"êµ¬ë¬¸ ì˜¤ë¥˜: {e}")
                
                # Import ê²€ì¦ (ê°„ë‹¨í•œ íŒ¨í„´ í™•ì¸)
                if 'Posco_News_mini' in content or 'POSCO_WatchHamster_v3' in content:
                    verification_results["import_errors"] += 1
                    file_details["issues"].append("ë ˆê±°ì‹œ import íŒ¨í„´ ë°œê²¬")
                
                if file_details["issues"]:
                    verification_results["details"].append(file_details)
            
            except Exception as e:
                file_details["issues"].append(f"ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {e}")
                verification_results["details"].append(file_details)
        
        # ì „ì²´ ì„±ê³µë¥  ê³„ì‚°
        total_issues = verification_results["syntax_errors"] + verification_results["import_errors"]
        if verification_results["files_checked"] > 0:
            verification_results["overall_success_rate"] = max(
                0, 100 - (total_issues / verification_results["files_checked"] * 100)
            )
        
        print(f"âœ… ê²€ì¦ ì™„ë£Œ: {verification_results['overall_success_rate']:.1f}% ì„±ê³µë¥ ")
        return verification_results
    
    def _get_task_type(self, issue: str) -> str:
        """ì´ìŠˆ íƒ€ì…ì— ë”°ë¥¸ ì‘ì—… íƒ€ì… ë°˜í™˜"""
        if issue in ['syntax_error', 'with_open_error']:
            return 'syntax'
        elif issue in ['legacy_import']:
            return 'import'
        elif issue in ['path_separator']:
            return 'reference'
        else:
            return 'general'
    
    def _get_priority(self, issue: str) -> int:
        """ì´ìŠˆì— ë”°ë¥¸ ìš°ì„ ìˆœìœ„ ë°˜í™˜"""
        priority_map = {
            'syntax_error': 1,  # ë†’ìŒ
            'with_open_error': 1,
            'legacy_import': 2,  # ì¤‘ê°„
            'path_separator': 3,  # ë‚®ìŒ
        }
        return priority_map.get(issue, 2)
    
    def _estimate_time(self, issue: str) -> int:
        """ì´ìŠˆì— ë”°ë¥¸ ì˜ˆìƒ ì‹œê°„ ë°˜í™˜ (ì´ˆ)"""
        time_map = {
            'syntax_error': 30,
            'with_open_error': 10,
            'legacy_import': 15,
            'path_separator': 5,
        }
        return time_map.get(issue, 20)


def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸš€ Enhanced POSCO ì‹œìŠ¤í…œ ìë™í™”ëœ ìˆ˜ë¦¬ ë„êµ¬ v2.0")
    print("=" * 60)
    
    repair_system = EnhancedAutomatedRepairSystem()
    
    try:
        # 1ë‹¨ê³„: ì‹œìŠ¤í…œ ë¶„ì„
        print("\n1ï¸âƒ£ ì‹œìŠ¤í…œ ë¶„ì„ ë‹¨ê³„")
        analysis_results = repair_system.analyze_system()
        
        if len(repair_system.repair_tasks) == 0:
            print("âœ… ìˆ˜ë¦¬ê°€ í•„ìš”í•œ ë¬¸ì œê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return
        
        print(f"   ë°œê²¬ëœ ë¬¸ì œ: {len(repair_system.repair_tasks)}ê°œ")
        print(f"   ì˜ˆìƒ ìˆ˜ë¦¬ ì‹œê°„: {analysis_results['estimated_repair_time']}ì´ˆ")
        
        # 2ë‹¨ê³„: ìˆ˜ë¦¬ ì‹¤í–‰
        print("\n2ï¸âƒ£ ìˆ˜ë¦¬ ì‹¤í–‰ ë‹¨ê³„")
        execution_results = repair_system.execute_repairs(max_files=20)
        
        # 3ë‹¨ê³„: ê²€ì¦
        print("\n3ï¸âƒ£ ìˆ˜ë¦¬ ê²€ì¦ ë‹¨ê³„")
        verification_results = repair_system.verify_repairs()
        
        # ê²°ê³¼ ìš”ì•½
        print("\n" + "=" * 60)
        print("ğŸ“Š ìµœì¢… ìˆ˜ë¦¬ ê²°ê³¼ ìš”ì•½")
        print("=" * 60)
        print(f"ë¶„ì„ëœ íŒŒì¼: {analysis_results['python_files']}ê°œ")
        print(f"ë¬¸ì œ ë°œê²¬ íŒŒì¼: {analysis_results['files_with_issues']}ê°œ")
        print(f"ì‹¤í–‰ëœ ì‘ì—…: {execution_results['executed_tasks']}ê°œ")
        print(f"ì„±ê³µí•œ ì‘ì—…: {execution_results['successful_tasks']}ê°œ")
        print(f"ì‹¤íŒ¨í•œ ì‘ì—…: {execution_results['failed_tasks']}ê°œ")
        print(f"ì „ì²´ ì‹¤í–‰ ì‹œê°„: {execution_results['total_execution_time']:.1f}ì´ˆ")
        print(f"ê²€ì¦ ì„±ê³µë¥ : {verification_results['overall_success_rate']:.1f}%")
        
        if verification_results['overall_success_rate'] >= 90:
            print("\nğŸ‰ ìˆ˜ë¦¬ ëª©í‘œ ë‹¬ì„±! (90% ì´ìƒ)")
        elif verification_results['overall_success_rate'] >= 70:
            print("\nğŸ‘ ì–‘í˜¸í•œ ìˆ˜ë¦¬ ê²°ê³¼ì…ë‹ˆë‹¤.")
        else:
            print("\nâš ï¸  ì¶”ê°€ ìˆ˜ë¦¬ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        
        # ê²°ê³¼ ì €ì¥
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        results_file = f"enhanced_repair_results_{timestamp}.json"
        
        combined_results = {
            "analysis": analysis_results,
            "execution": execution_results,
            "verification": verification_results
        }
        
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump(combined_results, f, indent=2, ensure_ascii=False)
        
        print(f"\nğŸ’¾ ìƒì„¸ ê²°ê³¼ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {results_file}")
        
    except Exception as e:
        print(f"âŒ ìˆ˜ë¦¬ ì‹œìŠ¤í…œ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        traceback.print_exc()


if __name__ == "__main__":
    main()