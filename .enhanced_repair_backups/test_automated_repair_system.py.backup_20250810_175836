#!/usr/bin/env python3
"""
POSCO ìë™í™”ëœ ìˆ˜ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
Test Suite for Automated Repair System

ì´ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ëŠ” ìë™í™”ëœ ìˆ˜ë¦¬ ì‹œìŠ¤í…œì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ê²€ì¦í•©ë‹ˆë‹¤.
"""

import os
import sys
import json
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch, mock_open

# í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ëª¨ë“ˆ import
from automated_repair_system import (
    AutomatedRepairSystem,
    SyntaxErrorDiagnostic,
    SyntaxErrorRepairer,
    ImportDiagnostic,
    ImportRepairer,
    FileReferenceDiagnostic,
    FileReferenceRepairer,
    BackupManager,
    DiagnosticResult,
    RepairResult,
    BrokenReference
)


class TestBackupManager(unittest.TestCase):
    """ë°±ì—… ê´€ë¦¬ì í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.backup_manager = BackupManager(backup_dir=f"{self.temp_dir}/.test_backups")
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_create_backup(self):
        """íŒŒì¼ ë°±ì—… ìƒì„± í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
        test_file = Path(self.temp_dir) / "test.py"
        test_file.write_text("print('hello world')")
        
        # ë°±ì—… ìƒì„±
        backup_path = self.backup_manager.create_backup(test_file)
        
        # ë°±ì—… íŒŒì¼ ì¡´ì¬ í™•ì¸
        self.assertTrue(Path(backup_path).exists())
        self.assertIn("test.py.backup_", backup_path)
    
    def test_restore_file(self):
        """íŒŒì¼ ë³µì› í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„± ë° ë°±ì—…
        test_file = Path(self.temp_dir) / "test.py"
        original_content = "print('original')"
        test_file.write_text(original_content)
        
        backup_path = self.backup_manager.create_backup(test_file)
        
        # íŒŒì¼ ìˆ˜ì •
        test_file.write_text("print('modified')")
        
        # ë³µì›
        success = self.backup_manager.restore_file(str(test_file))
        
        # ë³µì› í™•ì¸
        self.assertTrue(success)
        self.assertEqual(test_file.read_text(), original_content)


class TestSyntaxErrorDiagnostic(unittest.TestCase):
    """êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.diagnostic = SyntaxErrorDiagnostic()
    
    def test_diagnose_syntax_error(self):
        """êµ¬ë¬¸ ì˜¤ë¥˜ ì§„ë‹¨ í…ŒìŠ¤íŠ¸"""
        # êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ìˆëŠ” ì½”ë“œ
        error_code = '''
def test_function(
    print("missing closing parenthesis")
'''
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(error_code)
            f.flush()
            
            results = self.diagnostic.diagnose_file(Path(f.name))
            
            # êµ¬ë¬¸ ì˜¤ë¥˜ ê°ì§€ í™•ì¸
            self.assertTrue(len(results) > 0)
            self.assertEqual(results[0].error_type, "SyntaxError")
        
        os.unlink(f.name)
    
    def test_diagnose_valid_syntax(self):
        """ì •ìƒ êµ¬ë¬¸ ì§„ë‹¨ í…ŒìŠ¤íŠ¸"""
        # ì •ìƒ ì½”ë“œ
        valid_code = '''
def test_function():
    print("valid syntax")
    return True
'''
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(valid_code)
            f.flush()
            
            results = self.diagnostic.diagnose_file(Path(f.name))
            
            # êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ì—†ì–´ì•¼ í•¨
            syntax_errors = [r for r in results if r.error_type == "SyntaxError"]
            self.assertEqual(len(syntax_errors), 0)
        
        os.unlink(f.name)


class TestSyntaxErrorRepairer(unittest.TestCase):
    """êµ¬ë¬¸ ì˜¤ë¥˜ ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.backup_manager = BackupManager(backup_dir=f"{self.temp_dir}/.test_backups")
        self.repairer = SyntaxErrorRepairer(self.backup_manager)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_repair_indentation(self):
        """ë“¤ì—¬ì“°ê¸° ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
        # íƒ­ì´ í¬í•¨ëœ ì½”ë“œ
        code_with_tabs = "def test():\n\tprint('tab indentation')\n\treturn True"
        
        test_file = Path(self.temp_dir) / "test_indent.py"
        test_file.write_text(code_with_tabs)
        
        # ìˆ˜ì • ì‹¤í–‰
        result = self.repairer.repair_file(test_file)
        
        # ìˆ˜ì • í™•ì¸
        self.assertTrue(result.success)
        self.assertTrue(any("íƒ­ì„ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜" in change for change in result.changes_made))
        
        # íŒŒì¼ ë‚´ìš© í™•ì¸
        repaired_content = test_file.read_text()
        self.assertNotIn('\t', repaired_content)
        self.assertIn('    ', repaired_content)  # 4ì¹¸ ìŠ¤í˜ì´ìŠ¤
    
    def test_repair_naming_convention(self):
        """ë„¤ì´ë° ê·œì¹™ ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
        # ì˜ëª»ëœ ë„¤ì´ë°ì´ í¬í•¨ëœ ì½”ë“œ
        code_with_bad_naming = "POSCO News 250808 = 'test'\nprint(POSCO News 250808)"
        
        test_file = Path(self.temp_dir) / "test_naming.py"
        test_file.write_text(code_with_bad_naming)
        
        # ìˆ˜ì • ì‹¤í–‰
        result = self.repairer.repair_file(test_file)
        
        # ìˆ˜ì • í™•ì¸
        self.assertTrue(result.success)
        
        # íŒŒì¼ ë‚´ìš© í™•ì¸
        repaired_content = test_file.read_text()
        self.assertIn('POSCO_NEWS_250808', repaired_content)


class TestImportDiagnostic(unittest.TestCase):
    """Import ì§„ë‹¨ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.diagnostic = ImportDiagnostic()
    
    def test_extract_imports(self):
        """Import ì¶”ì¶œ í…ŒìŠ¤íŠ¸"""
        code_with_imports = '''
import os
import sys
from pathlib import Path
from datetime import datetime
'''
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(code_with_imports)
            f.flush()
            
            imports = self.diagnostic._extract_imports(Path(f.name))
            
            # Import ì¶”ì¶œ í™•ì¸
            self.assertIn('os', imports)
            self.assertIn('sys', imports)
            self.assertIn('pathlib', imports)
            self.assertIn('datetime', imports)
        
        os.unlink(f.name)
    
    def test_module_exists(self):
        """ëª¨ë“ˆ ì¡´ì¬ í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë“ˆ
        self.assertTrue(self.diagnostic._module_exists('os'))
        self.assertTrue(self.diagnostic._module_exists('sys'))
        
        # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ëª¨ë“ˆ
        self.assertFalse(self.diagnostic._module_exists('nonexistent_module_12345'))


class TestImportRepairer(unittest.TestCase):
    """Import ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.backup_manager = BackupManager(backup_dir=f"{self.temp_dir}/.test_backups")
        self.repairer = ImportRepairer(self.backup_manager)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_add_missing_imports(self):
        """ëˆ„ë½ëœ import ì¶”ê°€ í…ŒìŠ¤íŠ¸"""
        # os.pathë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ importê°€ ì—†ëŠ” ì½”ë“œ
        code_without_import = '''
def test_function():
    path = os.path.join('a', 'b')
    return path
'''
        
        test_file = Path(self.temp_dir) / "test_import.py"
        test_file.write_text(code_without_import)
        
        # ìˆ˜ì • ì‹¤í–‰
        result = self.repairer.repair_missing_imports(test_file)
        
        # ìˆ˜ì • í™•ì¸
        self.assertTrue(result.success)
        
        # íŒŒì¼ ë‚´ìš© í™•ì¸
        repaired_content = test_file.read_text()
        self.assertIn('import os', repaired_content)
    
    def test_fix_import_paths(self):
        """Import ê²½ë¡œ ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
        # ì˜ëª»ëœ import ê²½ë¡œê°€ ìˆëŠ” ì½”ë“œ
        code_with_wrong_import = '''
from POSCO_News_250808 import some_function
import WatchHamster_v3.0
'''
        
        test_file = Path(self.temp_dir) / "test_import_path.py"
        test_file.write_text(code_with_wrong_import)
        
        # ìˆ˜ì • ì‹¤í–‰
        result = self.repairer.repair_missing_imports(test_file)
        
        # ìˆ˜ì • í™•ì¸
        self.assertTrue(result.success)
        
        # íŒŒì¼ ë‚´ìš© í™•ì¸
        repaired_content = test_file.read_text()
        self.assertIn('from POSCO_News_250808', repaired_content)
        self.assertIn('import WatchHamster_v3.0', repaired_content)


class TestFileReferenceDiagnostic(unittest.TestCase):
    """íŒŒì¼ ì°¸ì¡° ì§„ë‹¨ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.diagnostic = FileReferenceDiagnostic()
        self.temp_dir = tempfile.mkdtemp()
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_scan_python_file(self):
        """Python íŒŒì¼ ì°¸ì¡° ìŠ¤ìº” í…ŒìŠ¤íŠ¸"""
        # íŒŒì¼ ì°¸ì¡°ê°€ ìˆëŠ” ì½”ë“œ
        code_with_references = '''
with open("nonexistent_file.txt", "r") as f:
    content = f.read()

from pathlib import Path
config_path = Path("missing_config.json")
'''
        
        test_file = Path(self.temp_dir) / "test_ref.py"
        test_file.write_text(code_with_references)
        
        # í˜„ì¬ ë””ë ‰í† ë¦¬ë¥¼ ì„ì‹œ ë””ë ‰í† ë¦¬ë¡œ ë³€ê²½
        original_cwd = os.getcwd()
        os.chdir(self.temp_dir)
        
        try:
            broken_refs = self.diagnostic._scan_python_file(test_file)
            
            # ê¹¨ì§„ ì°¸ì¡° í™•ì¸
            self.assertTrue(len(broken_refs) > 0)
            ref_paths = [ref.referenced_path for ref in broken_refs]
            self.assertIn("nonexistent_file.txt", ref_paths)
            self.assertIn("missing_config.json", ref_paths)
        finally:
            os.chdir(original_cwd)


class TestFileReferenceRepairer(unittest.TestCase):
    """íŒŒì¼ ì°¸ì¡° ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.backup_manager = BackupManager(backup_dir=f"{self.temp_dir}/.test_backups")
        self.repairer = FileReferenceRepairer(self.backup_manager)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_repair_file_references(self):
        """íŒŒì¼ ì°¸ì¡° ìˆ˜ì • í…ŒìŠ¤íŠ¸"""
        # ì˜ëª»ëœ íŒŒì¼ ì°¸ì¡°ê°€ ìˆëŠ” ì½”ë“œ
        code_with_wrong_refs = '''
from POSCO_News_250808 import function
config_file = "POSCO_WatchHamster_v3\\config.json"
'''
        
        test_file = Path(self.temp_dir) / "test_ref_repair.py"
        test_file.write_text(code_with_wrong_refs)
        
        # ìˆ˜ì • ì‹¤í–‰
        result = self.repairer.repair_broken_references(test_file)
        
        # ìˆ˜ì • í™•ì¸
        self.assertTrue(result.success)
        
        # íŒŒì¼ ë‚´ìš© í™•ì¸
        repaired_content = test_file.read_text()
        self.assertIn('POSCO_News_250808', repaired_content)
        self.assertIn('WatchHamster_v3.0', repaired_content)
        self.assertIn('/', repaired_content)  # ê²½ë¡œ êµ¬ë¶„ì í‘œì¤€í™”
        self.assertNotIn('\\', repaired_content)


class TestAutomatedRepairSystem(unittest.TestCase):
    """í†µí•© ìë™í™” ìˆ˜ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.repair_system = AutomatedRepairSystem()
        self.temp_dir = tempfile.mkdtemp()
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    @patch('automated_repair_system.Path.glob')
    def test_run_full_diagnosis(self, mock_glob):
        """ì „ì²´ ì§„ë‹¨ ì‹¤í–‰ í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ìš© Python íŒŒì¼ ëª©ë¡ ëª¨í‚¹
        test_files = [Path("test1.py"), Path("test2.py")]
        mock_glob.return_value = test_files
        
        # íŒŒì¼ ë‚´ìš© ëª¨í‚¹
        with patch('builtins.open', mock_open(read_data="print('test')")):
            with patch('automated_repair_system.ast.parse'):  # AST íŒŒì‹± ì„±ê³µìœ¼ë¡œ ëª¨í‚¹
                diagnosis_results = self.repair_system.run_full_diagnosis()
        
        # ì§„ë‹¨ ê²°ê³¼ í™•ì¸
        self.assertIn("backup_created", diagnosis_results)
        self.assertIn("syntax_errors", diagnosis_results)
        self.assertIn("import_problems", diagnosis_results)
        self.assertIn("broken_references", diagnosis_results)
    
    def test_data_classes(self):
        """ë°ì´í„° í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸"""
        # DiagnosticResult í…ŒìŠ¤íŠ¸
        diagnostic = DiagnosticResult(
            file_path="test.py",
            error_type="SyntaxError",
            error_message="Invalid syntax",
            line_number=10,
            severity="high"
        )
        self.assertEqual(diagnostic.file_path, "test.py")
        self.assertEqual(diagnostic.error_type, "SyntaxError")
        
        # RepairResult í…ŒìŠ¤íŠ¸
        repair = RepairResult(
            file_path="test.py",
            repair_type="SyntaxRepair",
            success=True,
            changes_made=["Fixed indentation"],
            backup_created=True
        )
        self.assertTrue(repair.success)
        self.assertEqual(len(repair.changes_made), 1)
        
        # BrokenReference í…ŒìŠ¤íŠ¸
        broken_ref = BrokenReference(
            source_file="test.py",
            referenced_path="missing.txt",
            reference_type="file_path",
            line_number=5
        )
        self.assertEqual(broken_ref.source_file, "test.py")
        self.assertEqual(broken_ref.reference_type, "file_path")


class TestIntegration(unittest.TestCase):
    """í†µí•© í…ŒìŠ¤íŠ¸"""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.original_cwd = os.getcwd()
        os.chdir(self.temp_dir)
    
    def tearDown(self):
        os.chdir(self.original_cwd)
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_end_to_end_repair(self):
        """ì¢…ë‹¨ê°„ ìˆ˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # ë¬¸ì œê°€ ìˆëŠ” Python íŒŒì¼ ìƒì„±
        problematic_code = '''
import nonexistent_module
from POSCO_News_250808 import function
import pathlib

def test_function(
	print("tab indentation and missing parenthesis")
	POSCO News 250808 = "bad naming"
	with open("missing_file.txt") as f:
		content = f.read()
'''
        
        test_file = Path("problematic.py")
        test_file.write_text(problematic_code)
        
        # ìˆ˜ë¦¬ ì‹œìŠ¤í…œ ì‹¤í–‰
        repair_system = AutomatedRepairSystem()
        
        # ì§„ë‹¨ ì‹¤í–‰
        diagnosis_results = repair_system.run_full_diagnosis()
        
        # ë¬¸ì œê°€ ê°ì§€ë˜ì—ˆëŠ”ì§€ í™•ì¸
        self.assertTrue(len(diagnosis_results["syntax_errors"]) > 0)
        
        # ìˆ˜ë¦¬ ì‹¤í–‰
        repair_results = repair_system.run_automated_repair()
        
        # ìˆ˜ë¦¬ê°€ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        self.assertTrue(repair_results["total_files_processed"] > 0)
        
        # ê²€ì¦ ì‹¤í–‰
        verification_results = repair_system.verify_repairs()
        
        # ê°œì„ ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ì™„ì „í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì§€ë§Œ ì‹œë„ëŠ” í–ˆì–´ì•¼ í•¨)
        self.assertIsInstance(verification_results["overall_success_rate"], (int, float))


def run_comprehensive_tests():
    """í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    print("ğŸ§ª POSCO ìë™í™”ëœ ìˆ˜ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ì‹œì‘")
    print("=" * 60)
    
    # í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ êµ¬ì„±
    test_classes = [
        TestBackupManager,
        TestSyntaxErrorDiagnostic,
        TestSyntaxErrorRepairer,
        TestImportDiagnostic,
        TestImportRepairer,
        TestFileReferenceDiagnostic,
        TestFileReferenceRepairer,
        TestAutomatedRepairSystem,
        TestIntegration
    ]
    
    total_tests = 0
    passed_tests = 0
    failed_tests = 0
    
    for test_class in test_classes:
        print(f"\nğŸ“‹ {test_class.__name__} í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        
        suite = unittest.TestLoader().loadTestsFromTestCase(test_class)
        runner = unittest.TextTestRunner(verbosity=1, stream=open(os.devnull, 'w'))
        result = runner.run(suite)
        
        class_total = result.testsRun
        class_passed = class_total - len(result.failures) - len(result.errors)
        class_failed = len(result.failures) + len(result.errors)
        
        total_tests += class_total
        passed_tests += class_passed
        failed_tests += class_failed
        
        print(f"   âœ… í†µê³¼: {class_passed}/{class_total}")
        if class_failed > 0:
            print(f"   âŒ ì‹¤íŒ¨: {class_failed}")
            for failure in result.failures + result.errors:
                print(f"      - {failure[0]}: {failure[1].split('AssertionError:')[-1].strip()}")
    
    # ì „ì²´ ê²°ê³¼ ìš”ì•½
    print("\n" + "=" * 60)
    print("ğŸ“Š í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
    print("=" * 60)
    print(f"ì „ì²´ í…ŒìŠ¤íŠ¸: {total_tests}")
    print(f"í†µê³¼: {passed_tests}")
    print(f"ì‹¤íŒ¨: {failed_tests}")
    print(f"ì„±ê³µë¥ : {(passed_tests/total_tests*100):.1f}%")
    
    if failed_tests == 0:
        print("\nğŸ‰ ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼!")
        return True
    else:
        print(f"\nâš ï¸  {failed_tests}ê°œ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨")
        return False


if __name__ == "__main__":
    success = run_comprehensive_tests()
    sys.exit(0 if success else 1)